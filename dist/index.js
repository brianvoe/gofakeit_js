const FUNC_SHORT = [{ "value": "phraseadverb", "display": "Adverb Phrase", "category": "word" }, { "value": "country", "display": "Country", "category": "address" }, { "value": "latituderange", "display": "Latitude Range", "category": "address" }, { "value": "longituderange", "display": "Longitude Range", "category": "address" }, { "value": "bs", "display": "BS", "category": "company" }, { "value": "hackerabbreviation", "display": "Hacker Abbreviation", "category": "hacker" }, { "value": "hackeringverb", "display": "Hackering Verb", "category": "hacker" }, { "value": "uint64", "display": "Uint64", "category": "number" }, { "value": "hobby", "display": "Hobby", "category": "person" }, { "value": "errorhttpclient", "display": "HTTP client error", "category": "error" }, { "value": "programminglanguage", "display": "Programming Language", "category": "language" }, { "value": "minecraftarmortier", "display": "Minecraft armor tier", "category": "minecraft" }, { "value": "songname", "display": "Song Name", "category": "song" }, { "value": "nouncommon", "display": "Noun Common", "category": "word" }, { "value": "nouncollectivepeople", "display": "Noun Collective People", "category": "word" }, { "value": "verbaction", "display": "Action Verb", "category": "word" }, { "value": "celebrityactor", "display": "Celebrity Actor", "category": "celebrity" }, { "value": "safecolor", "display": "Safe Color", "category": "color" }, { "value": "minecraftvillagerstation", "display": "Minecraft villager station", "category": "minecraft" }, { "value": "company", "display": "Company", "category": "company" }, { "value": "productaudience", "display": "Product Audience", "category": "product" }, { "value": "beerhop", "display": "Beer Hop", "category": "beer" }, { "value": "hackerverb", "display": "Hacker Verb", "category": "hacker" }, { "value": "int32", "display": "Int32", "category": "number" }, { "value": "longitude", "display": "Longitude", "category": "address" }, { "value": "beeryeast", "display": "Beer Yeast", "category": "beer" }, { "value": "emojicategory", "display": "Emoji Category", "category": "emoji" }, { "value": "snack", "display": "Snack", "category": "food" }, { "value": "minecraftbiome", "display": "Minecraft biome", "category": "minecraft" }, { "value": "flipacoin", "display": "Flip A Coin", "category": "misc" }, { "value": "uintrange", "display": "UintRange", "category": "number" }, { "value": "verbhelping", "display": "Helping Verb", "category": "word" }, { "value": "blurb", "display": "Blurb", "category": "company" }, { "value": "emoji", "display": "Emoji", "category": "emoji" }, { "value": "uintn", "display": "UintN", "category": "number" }, { "value": "price", "display": "Price", "category": "payment" }, { "value": "adjectiveproper", "display": "Proper Adjective", "category": "word" }, { "value": "nouncountable", "display": "Noun Countable", "category": "word" }, { "value": "username", "display": "Username", "category": "auth" }, { "value": "buzzword", "display": "Buzzword", "category": "company" }, { "value": "map", "display": "Map", "category": "generate" }, { "value": "loremipsumsentence", "display": "Lorem Ipsum Sentence", "category": "word" }, { "value": "moviegenre", "display": "Genre", "category": "movie" }, { "value": "int16", "display": "Int16", "category": "number" }, { "value": "namesuffix", "display": "Name Suffix", "category": "person" }, { "value": "weighted", "display": "Weighted", "category": "misc" }, { "value": "emojidescription", "display": "Emoji Description", "category": "emoji" }, { "value": "minecraftanimal", "display": "Minecraft animal", "category": "minecraft" }, { "value": "shuffleints", "display": "Shuffle Ints", "category": "number" }, { "value": "creditcardtype", "display": "Credit Card Type", "category": "payment" }, { "value": "bitcoinaddress", "display": "Bitcoin Address", "category": "payment" }, { "value": "drink", "display": "Drink", "category": "food" }, { "value": "intrange", "display": "IntRange", "category": "number" }, { "value": "currencylong", "display": "Currency Long", "category": "payment" }, { "value": "teams", "display": "Teams", "category": "person" }, { "value": "adjectivequantitative", "display": "Quantitative Adjective", "category": "word" }, { "value": "adjectivepossessive", "display": "Possessive Adjective", "category": "word" }, { "value": "bird", "display": "Bird", "category": "animal" }, { "value": "pastdate", "display": "PastDate", "category": "time" }, { "value": "ipv4address", "display": "IPv4 Address", "category": "internet" }, { "value": "shufflestrings", "display": "Shuffle Strings", "category": "string" }, { "value": "verblinking", "display": "Linking Verb", "category": "word" }, { "value": "interjection", "display": "Interjection", "category": "word" }, { "value": "second", "display": "Second", "category": "time" }, { "value": "pronounpossessive", "display": "Pronoun Possessive", "category": "word" }, { "value": "errorobject", "display": "Error object word", "category": "error" }, { "value": "middlename", "display": "Middle Name", "category": "person" }, { "value": "email_text", "display": "Random text email Document", "category": "template" }, { "value": "streetnumber", "display": "Street Number", "category": "address" }, { "value": "minute", "display": "Minute", "category": "time" }, { "value": "productupc", "display": "Product UPC", "category": "product" }, { "value": "template", "display": "Template", "category": "template" }, { "value": "pronoun", "display": "Pronoun", "category": "word" }, { "value": "zip", "display": "Zip", "category": "address" }, { "value": "day", "display": "Day", "category": "time" }, { "value": "json", "display": "JSON", "category": "file" }, { "value": "xml", "display": "XML", "category": "file" }, { "value": "lunch", "display": "Lunch", "category": "food" }, { "value": "connectiveexamplify", "display": "Connective Examplify", "category": "word" }, { "value": "productname", "display": "Product Name", "category": "product" }, { "value": "productusecase", "display": "Product Use Case", "category": "product" }, { "value": "productsuffix", "display": "Product Suffix", "category": "product" }, { "value": "randomstring", "display": "Random String", "category": "string" }, { "value": "timezone", "display": "Timezone", "category": "time" }, { "value": "dessert", "display": "Dessert", "category": "food" }, { "value": "imagejpeg", "display": "Image JPEG", "category": "image" }, { "value": "creditcardnumber", "display": "Credit Card Number", "category": "payment" }, { "value": "nouncollectivething", "display": "Noun Collective Thing", "category": "word" }, { "value": "verbintransitive", "display": "Intransitive Verb", "category": "word" }, { "value": "streetsuffix", "display": "Street Suffix", "category": "address" }, { "value": "isin", "display": "ISIN", "category": "finance" }, { "value": "person", "display": "Person", "category": "person" }, { "value": "cartransmissiontype", "display": "Car Transmission Type", "category": "car" }, { "value": "email", "display": "Email", "category": "person" }, { "value": "productbenefit", "display": "Product Benefit", "category": "product" }, { "value": "lettern", "display": "LetterN", "category": "string" }, { "value": "adverb", "display": "Adverb", "category": "word" }, { "value": "preposition", "display": "Preposition", "category": "word" }, { "value": "prepositiondouble", "display": "Preposition Double", "category": "word" }, { "value": "timezonefull", "display": "Timezone Full", "category": "time" }, { "value": "errordatabase", "display": "Database error", "category": "error" }, { "value": "fileextension", "display": "File Extension", "category": "file" }, { "value": "cusip", "display": "CUSIP", "category": "finance" }, { "value": "movie", "display": "Movie", "category": "movie" }, { "value": "nameprefix", "display": "Name Prefix", "category": "person" }, { "value": "product", "display": "Product", "category": "product" }, { "value": "connectivelisting", "display": "Connective Listing", "category": "word" }, { "value": "timezoneabv", "display": "Timezone Abbreviation", "category": "time" }, { "value": "lastname", "display": "Last Name", "category": "person" }, { "value": "vowel", "display": "Vowel", "category": "string" }, { "value": "markdown", "display": "Random markdown document", "category": "template" }, { "value": "connectivetime", "display": "Connective Time", "category": "word" }, { "value": "phrase", "display": "Phrase", "category": "word" }, { "value": "countryabr", "display": "Country Abbreviation", "category": "address" }, { "value": "beermalt", "display": "Beer Malt", "category": "beer" }, { "value": "nouncollectiveanimal", "display": "Noun Collective Animal", "category": "word" }, { "value": "emojialias", "display": "Emoji Alias", "category": "emoji" }, { "value": "httpstatuscode", "display": "HTTP Status Code", "category": "internet" }, { "value": "adjectiveindefinite", "display": "Indefinite Adjective", "category": "word" }, { "value": "question", "display": "Question", "category": "word" }, { "value": "cat", "display": "Cat", "category": "animal" }, { "value": "carmaker", "display": "Car Maker", "category": "car" }, { "value": "ipv6address", "display": "IPv6 Address", "category": "internet" }, { "value": "httpstatuscodesimple", "display": "HTTP Status Code Simple", "category": "internet" }, { "value": "minecraftarmorpart", "display": "Minecraft armor part", "category": "minecraft" }, { "value": "minecraftmobneutral", "display": "Minecraft mob neutral", "category": "minecraft" }, { "value": "currencyshort", "display": "Currency Short", "category": "payment" }, { "value": "achaccount", "display": "ACH Account Number", "category": "payment" }, { "value": "song", "display": "Song", "category": "song" }, { "value": "prepositionsimple", "display": "Preposition Simple", "category": "word" }, { "value": "verbtransitive", "display": "Transitive Verb", "category": "word" }, { "value": "slogan", "display": "Slogan", "category": "company" }, { "value": "loglevel", "display": "Log Level", "category": "internet" }, { "value": "currency", "display": "Currency", "category": "payment" }, { "value": "creditcardcvv", "display": "Credit Card CVV", "category": "payment" }, { "value": "phoneformatted", "display": "Phone Formatted", "category": "person" }, { "value": "adjective", "display": "Adjective", "category": "word" }, { "value": "connectivecomplaint", "display": "Connective Complaint", "category": "word" }, { "value": "productcategory", "display": "Product Category", "category": "product" }, { "value": "beeralcohol", "display": "Beer Alcohol", "category": "beer" }, { "value": "date", "display": "Date", "category": "time" }, { "value": "nanosecond", "display": "Nanosecond", "category": "time" }, { "value": "language", "display": "Language", "category": "language" }, { "value": "productisbn", "display": "Product ISBN", "category": "product" }, { "value": "hexcolor", "display": "Hex Color", "category": "color" }, { "value": "daterange", "display": "DateRange", "category": "time" }, { "value": "minecraftvillagerjob", "display": "Minecraft villager job", "category": "minecraft" }, { "value": "noundeterminer", "display": "Noun Determiner", "category": "word" }, { "value": "password", "display": "Password", "category": "auth" }, { "value": "job", "display": "Job", "category": "company" }, { "value": "safariuseragent", "display": "Safari User Agent", "category": "internet" }, { "value": "randomint", "display": "Random Int", "category": "number" }, { "value": "hexuint", "display": "HexUint", "category": "number" }, { "value": "comment", "display": "Comment", "category": "word" }, { "value": "state", "display": "State", "category": "address" }, { "value": "breakfast", "display": "Breakfast", "category": "food" }, { "value": "dinner", "display": "Dinner", "category": "food" }, { "value": "banktype", "display": "Bank Type", "category": "payment" }, { "value": "streetname", "display": "Street Name", "category": "address" }, { "value": "errorgrpc", "display": "gRPC error", "category": "error" }, { "value": "operauseragent", "display": "Opera User Agent", "category": "internet" }, { "value": "minecraftmobboss", "display": "Minecraft mob boss", "category": "minecraft" }, { "value": "float32", "display": "Float32", "category": "number" }, { "value": "songgenre", "display": "Genre", "category": "song" }, { "value": "phrasenoun", "display": "Noun Phrase", "category": "word" }, { "value": "monthstring", "display": "Month String", "category": "time" }, { "value": "loremipsumword", "display": "Lorem Ipsum Word", "category": "word" }, { "value": "productmaterial", "display": "Product Material", "category": "product" }, { "value": "adjectiveinterrogative", "display": "Interrogative Adjective", "category": "word" }, { "value": "booktitle", "display": "Title", "category": "book" }, { "value": "uint32", "display": "Uint32", "category": "number" }, { "value": "phrasepreposition", "display": "Preposition Phrase", "category": "word" }, { "value": "animal", "display": "Animal", "category": "animal" }, { "value": "fruit", "display": "Fruit", "category": "food" }, { "value": "regex", "display": "Regex", "category": "generate" }, { "value": "minecraftweapon", "display": "Minecraft weapon", "category": "minecraft" }, { "value": "beeribu", "display": "Beer IBU", "category": "beer" }, { "value": "minecraftmobhostile", "display": "Minecraft mob hostile", "category": "minecraft" }, { "value": "randomuint", "display": "Random Uint", "category": "number" }, { "value": "achrouting", "display": "ACH Routing Number", "category": "payment" }, { "value": "bankname", "display": "Bank Name", "category": "payment" }, { "value": "gender", "display": "Gender", "category": "person" }, { "value": "pronoundemonstrative", "display": "Pronoun Demonstrative", "category": "word" }, { "value": "pronounrelative", "display": "Pronoun Relative", "category": "word" }, { "value": "street", "display": "Street", "category": "address" }, { "value": "year", "display": "Year", "category": "time" }, { "value": "gamertag", "display": "Gamertag", "category": "game" }, { "value": "int", "display": "Int", "category": "number" }, { "value": "cartype", "display": "Car Type", "category": "car" }, { "value": "timezoneoffset", "display": "Timezone Offset", "category": "time" }, { "value": "name", "display": "Name", "category": "person" }, { "value": "hackernoun", "display": "Hacker Noun", "category": "hacker" }, { "value": "inputname", "display": "Input Name", "category": "html" }, { "value": "float32range", "display": "Float32 Range", "category": "number" }, { "value": "beerstyle", "display": "Beer Style", "category": "beer" }, { "value": "book", "display": "Book", "category": "book" }, { "value": "celebritybusiness", "display": "Celebrity Business", "category": "celebrity" }, { "value": "month", "display": "Month", "category": "time" }, { "value": "macaddress", "display": "MAC Address", "category": "internet" }, { "value": "uint8", "display": "Uint8", "category": "number" }, { "value": "firstname", "display": "First Name", "category": "person" }, { "value": "adjectivedescriptive", "display": "Descriptive Adjective", "category": "word" }, { "value": "dog", "display": "Dog", "category": "animal" }, { "value": "beername", "display": "Beer Name", "category": "beer" }, { "value": "vegetable", "display": "Vegetable", "category": "food" }, { "value": "useragent", "display": "User Agent", "category": "internet" }, { "value": "minecraftore", "display": "Minecraft ore", "category": "minecraft" }, { "value": "nounconcrete", "display": "Noun Concrete", "category": "word" }, { "value": "verb", "display": "Verb", "category": "word" }, { "value": "stateabr", "display": "State Abbreviation", "category": "address" }, { "value": "error", "display": "Error", "category": "error" }, { "value": "loremipsumparagraph", "display": "Lorem Ipsum Paragraph", "category": "word" }, { "value": "digit", "display": "Digit", "category": "string" }, { "value": "numerify", "display": "Numerify", "category": "string" }, { "value": "hipstersentence", "display": "Hipster Sentence", "category": "hipster" }, { "value": "hipsterparagraph", "display": "Hipster Paragraph", "category": "hipster" }, { "value": "float64", "display": "Float64", "category": "number" }, { "value": "sentencesimple", "display": "Simple Sentence", "category": "word" }, { "value": "farmanimal", "display": "Farm Animal", "category": "animal" }, { "value": "carmodel", "display": "Car Model", "category": "car" }, { "value": "dice", "display": "Dice", "category": "game" }, { "value": "minecraftvillagerlevel", "display": "Minecraft villager level", "category": "minecraft" }, { "value": "productfeature", "display": "Product Feature", "category": "product" }, { "value": "lexify", "display": "Lexify", "category": "string" }, { "value": "word", "display": "Word", "category": "word" }, { "value": "httpversion", "display": "HTTP Version", "category": "internet" }, { "value": "companysuffix", "display": "Company Suffix", "category": "company" }, { "value": "errorhttp", "display": "HTTP error", "category": "error" }, { "value": "connectivecomparative", "display": "Connective Comparitive", "category": "word" }, { "value": "carfueltype", "display": "Car Fuel Type", "category": "car" }, { "value": "letter", "display": "Letter", "category": "string" }, { "value": "adjectivedemonstrative", "display": "Demonstrative Adjective", "category": "word" }, { "value": "streetprefix", "display": "Street Prefix", "category": "address" }, { "value": "rgbcolor", "display": "RGB Color", "category": "color" }, { "value": "sql", "display": "SQL", "category": "database" }, { "value": "fixed_width", "display": "Fixed Width", "category": "generate" }, { "value": "imagepng", "display": "Image PNG", "category": "image" }, { "value": "domainsuffix", "display": "Domain Suffix", "category": "internet" }, { "value": "languageabbreviation", "display": "Language Abbreviation", "category": "language" }, { "value": "uint", "display": "Uint", "category": "number" }, { "value": "bookauthor", "display": "Author", "category": "book" }, { "value": "joblevel", "display": "Job Level", "category": "company" }, { "value": "filemimetype", "display": "File Mime Type", "category": "file" }, { "value": "domainname", "display": "Domain Name", "category": "internet" }, { "value": "number", "display": "Number", "category": "number" }, { "value": "productdimension", "display": "Product Dimension", "category": "product" }, { "value": "adverbplace", "display": "Adverb Place", "category": "word" }, { "value": "phraseverb", "display": "Verb Phrase", "category": "word" }, { "value": "appname", "display": "App Name", "category": "app" }, { "value": "celebritysport", "display": "Celebrity Sport", "category": "celebrity" }, { "value": "hour", "display": "Hour", "category": "time" }, { "value": "hipsterword", "display": "Hipster Word", "category": "hipster" }, { "value": "languagebcp", "display": "Language BCP", "category": "language" }, { "value": "minecraftdye", "display": "Minecraft dye", "category": "minecraft" }, { "value": "moviename", "display": "Movie Name", "category": "movie" }, { "value": "float64range", "display": "Float64 Range", "category": "number" }, { "value": "emojitag", "display": "Emoji Tag", "category": "emoji" }, { "value": "url", "display": "URL", "category": "internet" }, { "value": "creditcardexp", "display": "Credit Card Exp", "category": "payment" }, { "value": "adverbmanner", "display": "Adverb Manner", "category": "word" }, { "value": "adverbtimeindefinite", "display": "Adverb Time Indefinite", "category": "word" }, { "value": "adverbfrequencydefinite", "display": "Adverb Frequency Definite", "category": "word" }, { "value": "connectivecasual", "display": "Connective Casual", "category": "word" }, { "value": "nounproper", "display": "Noun Proper", "category": "word" }, { "value": "bookgenre", "display": "Genre", "category": "book" }, { "value": "timezoneregion", "display": "Timezone Region", "category": "time" }, { "value": "hackeradjective", "display": "Hacker Adjective", "category": "hacker" }, { "value": "httpmethod", "display": "HTTP Method", "category": "internet" }, { "value": "minecrafttool", "display": "Minecraft tool", "category": "minecraft" }, { "value": "minecraftfood", "display": "Minecraft food", "category": "minecraft" }, { "value": "minecraftweather", "display": "Minecraft weather", "category": "minecraft" }, { "value": "petname", "display": "Pet Name", "category": "animal" }, { "value": "beerblg", "display": "Beer BLG", "category": "beer" }, { "value": "csv", "display": "CSV", "category": "file" }, { "value": "hackerphrase", "display": "Hacker Phrase", "category": "hacker" }, { "value": "school", "display": "School", "category": "school" }, { "value": "prepositioncompound", "display": "Preposition Compound", "category": "word" }, { "value": "address", "display": "Address", "category": "address" }, { "value": "futuredate", "display": "FutureDate", "category": "time" }, { "value": "adverbtimedefinite", "display": "Adverb Time Definite", "category": "word" }, { "value": "pronounreflective", "display": "Pronoun Reflective", "category": "word" }, { "value": "appauthor", "display": "App Author", "category": "app" }, { "value": "jobdescriptor", "display": "Job Descriptor", "category": "company" }, { "value": "errorhttpserver", "display": "HTTP server error", "category": "error" }, { "value": "int64", "display": "Int64", "category": "number" }, { "value": "noununcountable", "display": "Noun Uncountable", "category": "word" }, { "value": "color", "display": "Color", "category": "color" }, { "value": "nicecolors", "display": "Nice Colors", "category": "color" }, { "value": "jobtitle", "display": "Job Title", "category": "company" }, { "value": "chromeuseragent", "display": "Chrome User Agent", "category": "internet" }, { "value": "minecraftmobpassive", "display": "Minecraft mob passive", "category": "minecraft" }, { "value": "latitude", "display": "Latitude", "category": "address" }, { "value": "appversion", "display": "App Version", "category": "app" }, { "value": "car", "display": "Car", "category": "car" }, { "value": "uint16", "display": "Uint16", "category": "number" }, { "value": "adverbdegree", "display": "Adverb Degree", "category": "word" }, { "value": "svg", "display": "Image SVG", "category": "html" }, { "value": "int8", "display": "Int8", "category": "number" }, { "value": "digitn", "display": "DigitN", "category": "string" }, { "value": "adverbfrequencyindefinite", "display": "Adverb Frequency Indefinite", "category": "word" }, { "value": "noun", "display": "Noun", "category": "word" }, { "value": "pronounobject", "display": "Pronoun Object", "category": "word" }, { "value": "errorruntime", "display": "Runtime error", "category": "error" }, { "value": "errorvalidation", "display": "Validation error", "category": "error" }, { "value": "firefoxuseragent", "display": "Firefox User Agent", "category": "internet" }, { "value": "uuid", "display": "UUID", "category": "misc" }, { "value": "creditcard", "display": "Credit Card", "category": "payment" }, { "value": "phone", "display": "Phone", "category": "person" }, { "value": "intn", "display": "IntN", "category": "number" }, { "value": "bitcoinprivatekey", "display": "Bitcoin Private Key", "category": "payment" }, { "value": "pronounpersonal", "display": "Pronoun Personal", "category": "word" }, { "value": "sentence", "display": "Sentence", "category": "word" }, { "value": "generate", "display": "Generate", "category": "generate" }, { "value": "ssn", "display": "SSN", "category": "person" }, { "value": "connective", "display": "Connective", "category": "word" }, { "value": "pronounindefinite", "display": "Pronoun Indefinite", "category": "word" }, { "value": "quote", "display": "Quote", "category": "word" }, { "value": "animaltype", "display": "Animal Type", "category": "animal" }, { "value": "weekday", "display": "Weekday", "category": "time" }, { "value": "pronouninterrogative", "display": "Pronoun Interrogative", "category": "word" }, { "value": "paragraph", "display": "Paragraph", "category": "word" }, { "value": "city", "display": "City", "category": "address" }, { "value": "minecraftwood", "display": "Minecraft wood", "category": "minecraft" }, { "value": "bool", "display": "Boolean", "category": "misc" }, { "value": "productdescription", "display": "Product Description", "category": "product" }, { "value": "songartist", "display": "Song Artist", "category": "song" }, { "value": "nounabstract", "display": "Noun Abstract", "category": "word" }];
const FUNC_SHORT_VALUES = new Set(
  FUNC_SHORT.map((e) => e.value.toLowerCase())
);
function hasFunc(name) {
  return FUNC_SHORT_VALUES.has(name.toLowerCase());
}
const GOFAKEIT_COLORS = {
  primary: "#ffa000"
};
function showFieldError(element, message) {
  const existingError = document.querySelector(".gofakeit-error-tooltip");
  if (existingError) {
    existingError.remove();
  }
  const tooltip = document.createElement("div");
  tooltip.className = "gofakeit-error-tooltip";
  tooltip.style.cssText = `
    position: absolute;
    z-index: 10001;
    color: var(--color-error);
    font-size: var(--font-size);
    font-family: var(--font-family);
    background-color: var(--color-background);
    padding: var(--spacing-quarter) var(--spacing-half);
    border-radius: var(--border-radius);
    border: 1px solid var(--color-error);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    max-width: 300px;
    word-wrap: break-word;
    opacity: 0;
    transform: translateY(-10px);
    transition: opacity 0.3s ease, transform 0.3s ease;
    pointer-events: none;
  `;
  tooltip.textContent = message;
  document.body.appendChild(tooltip);
  function updateTooltipPosition() {
    const rect = element.getBoundingClientRect();
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
    const left = rect.left + scrollLeft;
    const top = rect.top + scrollTop - tooltip.offsetHeight - 8;
    tooltip.style.left = `${left}px`;
    tooltip.style.top = `${top}px`;
  }
  updateTooltipPosition();
  const scrollHandler = () => updateTooltipPosition();
  const resizeHandler = () => updateTooltipPosition();
  window.addEventListener("scroll", scrollHandler, { passive: true });
  window.addEventListener("resize", resizeHandler, { passive: true });
  const scrollableElements = document.querySelectorAll("*");
  const scrollableListeners = [];
  scrollableElements.forEach((el) => {
    const style = window.getComputedStyle(el);
    if (style.overflow === "scroll" || style.overflowY === "scroll" || style.overflow === "auto" || style.overflowY === "auto") {
      const listener = () => updateTooltipPosition();
      el.addEventListener("scroll", listener, { passive: true });
      scrollableListeners.push({ element: el, handler: listener });
    }
  });
  requestAnimationFrame(() => {
    tooltip.style.opacity = "1";
    tooltip.style.transform = "translateY(0)";
  });
  setTimeout(() => {
    tooltip.style.opacity = "0";
    tooltip.style.transform = "translateY(-10px)";
    window.removeEventListener("scroll", scrollHandler);
    window.removeEventListener("resize", resizeHandler);
    scrollableListeners.forEach(({ element: element2, handler }) => {
      element2.removeEventListener("scroll", handler);
    });
    setTimeout(() => {
      if (tooltip.parentElement) {
        tooltip.parentElement.removeChild(tooltip);
      }
    }, 300);
  }, 5e3);
}
const GOFAKEIT_API_BASE = "https://api.gofakeit.com/funcs";
async function fetchGofakeitData(func) {
  const questionMarkIndex = func.indexOf("?");
  if (questionMarkIndex !== -1) {
    const functionName = func.substring(0, questionMarkIndex);
    const queryString = func.substring(questionMarkIndex + 1);
    const params = {};
    const searchParams = new URLSearchParams(queryString);
    for (const [key, value] of searchParams.entries()) {
      const numValue = parseFloat(value);
      params[key] = isNaN(numValue) ? value : numValue;
    }
    return makeRequest("POST", `${GOFAKEIT_API_BASE}/${functionName}`, params);
  } else {
    return makeRequest("GET", `${GOFAKEIT_API_BASE}/${func}`);
  }
}
async function fetchRandomString(strings) {
  return makeRequest("POST", `${GOFAKEIT_API_BASE}/randomstring`, { strs: strings });
}
async function makeRequest(method, url, body) {
  try {
    const options = {
      method,
      headers: {
        "Content-Type": "application/json"
      }
    };
    if (method === "POST" && body) {
      options.body = JSON.stringify(body);
    }
    const response = await fetch(url, options);
    if (!response.ok) {
      return {
        success: false,
        error: `HTTP error! status: ${response.status}`,
        status: response.status
      };
    }
    const data = await response.text();
    return {
      success: true,
      data
    };
  } catch (error) {
    console.error(`[Gofakeit Autofill] Error in ${method} request to ${url}:`, error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error"
    };
  }
}
function getISOWeek(date) {
  const d = new Date(date.getTime());
  d.setUTCHours(0, 0, 0, 0);
  d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
  const week1 = new Date(d.getUTCFullYear(), 0, 4);
  const week = Math.ceil(((d.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getUTCDay() || 7)) / 7);
  return week;
}
async function handleDateTimeInput(element, gofakeitFunc) {
  const inputType = element.type.toLowerCase();
  try {
    switch (inputType) {
      case "date":
        const dateFunc = gofakeitFunc === "true" ? "date" : gofakeitFunc;
        const dateResponse = await fetchGofakeitData(dateFunc);
        if (!dateResponse.success) {
          console.warn(`[Gofakeit Autofill] Error for ${inputType} input:`, dateResponse.error);
          if (dateResponse.status === 400) {
            handleError(element, `Failed to get random ${inputType}`);
          }
          return { success: false, usedFunc: dateFunc };
        }
        try {
          const dateString = dateResponse.data;
          const dateMatch = dateString.match(/^(\d{4}-\d{2}-\d{2})/);
          if (dateMatch) {
            element.value = dateMatch[1];
          } else {
            console.warn("[Gofakeit Autofill] Could not parse date from response:", dateString);
            return { success: false, usedFunc: dateFunc };
          }
        } catch (error) {
          console.warn("[Gofakeit Autofill] Error parsing date response:", error);
          return { success: false, usedFunc: dateFunc };
        }
        break;
      case "time":
        const hourResponse = await fetchGofakeitData("hour");
        const minuteResponse = await fetchGofakeitData("minute");
        if (!hourResponse.success || !minuteResponse.success) {
          console.warn("[Gofakeit Autofill] Error getting hour or minute:", hourResponse.error || minuteResponse.error);
          if (hourResponse.status === 400 || minuteResponse.status === 400) {
            handleError(element, "Failed to get random time");
          }
          return { success: false, usedFunc: "hour/minute" };
        }
        const hour = hourResponse.data.padStart(2, "0");
        const minute = minuteResponse.data.padStart(2, "0");
        element.value = `${hour}:${minute}`;
        break;
      case "datetime-local":
        const datetimeFunc = gofakeitFunc === "true" ? "date" : gofakeitFunc;
        const datetimeResponse = await fetchGofakeitData(datetimeFunc);
        if (!datetimeResponse.success) {
          console.warn(`[Gofakeit Autofill] Error for ${inputType} input:`, datetimeResponse.error);
          if (datetimeResponse.status === 400) {
            handleError(element, `Failed to get random ${inputType}`);
          }
          return { success: false, usedFunc: datetimeFunc };
        }
        try {
          const datetimeString = datetimeResponse.data;
          const datetimeMatch = datetimeString.match(/^(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}):\d{2}/);
          if (datetimeMatch) {
            element.value = datetimeMatch[1];
          } else {
            console.warn("[Gofakeit Autofill] Could not parse datetime from response:", datetimeString);
            return { success: false, usedFunc: datetimeFunc };
          }
        } catch (error) {
          console.warn("[Gofakeit Autofill] Error parsing datetime response:", error);
          return { success: false, usedFunc: datetimeFunc };
        }
        break;
      case "month":
        const yearResponse = await fetchGofakeitData("year");
        const monthResponse = await fetchGofakeitData("month");
        if (!yearResponse.success || !monthResponse.success) {
          console.warn("[Gofakeit Autofill] Error getting year or month:", yearResponse.error || monthResponse.error);
          if (yearResponse.status === 400 || monthResponse.status === 400) {
            handleError(element, "Failed to get random month");
          }
          return { success: false, usedFunc: "year/month" };
        }
        const month = monthResponse.data.padStart(2, "0");
        element.value = `${yearResponse.data}-${month}`;
        break;
      case "week":
        const weekFunc = gofakeitFunc === "true" ? "date" : gofakeitFunc;
        if (weekFunc === "date" || weekFunc.startsWith("daterange")) {
          const weekDateResponse = await fetchGofakeitData(weekFunc);
          if (!weekDateResponse.success) {
            console.warn("[Gofakeit Autofill] Error getting date for week:", weekDateResponse.error);
            if (weekDateResponse.status === 400) {
              handleError(element, "Failed to get random week");
            }
            return { success: false, usedFunc: weekFunc };
          }
          try {
            const dateString = weekDateResponse.data;
            const dateMatch = dateString.match(/^(\d{4}-\d{2}-\d{2})/);
            if (dateMatch) {
              const date = new Date(dateMatch[1]);
              const year = date.getFullYear();
              const week = getISOWeek(date);
              element.value = `${year}-W${week.toString().padStart(2, "0")}`;
            } else {
              console.warn("[Gofakeit Autofill] Could not parse date for week from response:", dateString);
              return { success: false, usedFunc: weekFunc };
            }
          } catch (error) {
            console.warn("[Gofakeit Autofill] Error parsing date for week:", error);
            return { success: false, usedFunc: weekFunc };
          }
        } else {
          const weekYearResponse = await fetchGofakeitData("year");
          const weekResponse = await fetchGofakeitData("number?min=1&max=53");
          if (!weekYearResponse.success || !weekResponse.success) {
            console.warn("[Gofakeit Autofill] Error getting year or week:", weekYearResponse.error || weekResponse.error);
            if (weekYearResponse.status === 400 || weekResponse.status === 400) {
              handleError(element, "Failed to get random week");
            }
            return { success: false, usedFunc: "year/number?min=1&max=53" };
          }
          const week = weekResponse.data.padStart(2, "0");
          element.value = `${weekYearResponse.data}-W${week}`;
        }
        break;
      default:
        console.warn("[Gofakeit Autofill] Unknown date/time input type:", inputType);
        return { success: false, usedFunc: gofakeitFunc };
    }
    element.dispatchEvent(new Event("input", { bubbles: true }));
    element.dispatchEvent(new Event("change", { bubbles: true }));
    return { success: true, usedFunc: gofakeitFunc === "true" ? inputType : gofakeitFunc };
  } catch (error) {
    console.warn(`[Gofakeit Autofill] Unexpected error handling ${inputType} input:`, error);
    return { success: false, usedFunc: gofakeitFunc };
  }
}
async function handleTextInput(element, gofakeitFunc) {
  const inputType = element.type.toLowerCase();
  let functionToCall = gofakeitFunc;
  if (gofakeitFunc === "true") {
    switch (inputType) {
      case "email":
        functionToCall = "email";
        break;
      case "tel":
        functionToCall = "phone";
        break;
      case "password":
        functionToCall = "password";
        break;
      case "search":
        functionToCall = "word";
        break;
      case "url":
        functionToCall = "url";
        break;
      case "color":
        functionToCall = "hexcolor";
        break;
      default:
        functionToCall = "word";
    }
  }
  const response = await fetchGofakeitData(functionToCall);
  if (!response.success) {
    console.warn(`[Gofakeit Autofill] Error for function ${functionToCall}:`, response.error);
    if (response.status === 400) {
      handleError(element, "", functionToCall);
    }
    return { success: false, usedFunc: functionToCall };
  }
  element.value = response.data;
  element.dispatchEvent(new Event("input", { bubbles: true }));
  element.dispatchEvent(new Event("change", { bubbles: true }));
  return { success: true, usedFunc: functionToCall };
}
async function handleTextarea(element, gofakeitFunc) {
  const functionToCall = gofakeitFunc === "true" ? "sentence" : gofakeitFunc;
  const response = await fetchGofakeitData(functionToCall);
  if (!response.success) {
    console.warn(`[Gofakeit Autofill] Error for function ${functionToCall}:`, response.error);
    if (response.status === 400) {
      handleError(element, "", functionToCall);
    }
    return { success: false, usedFunc: functionToCall };
  }
  element.value = response.data;
  element.dispatchEvent(new Event("input", { bubbles: true }));
  element.dispatchEvent(new Event("change", { bubbles: true }));
  return { success: true, usedFunc: functionToCall };
}
async function handleCheckbox(element, gofakeitFunc) {
  const checkboxGroup = findCheckboxGroup(element);
  if (checkboxGroup.length === 0) {
    console.warn("[Gofakeit Autofill] No checkbox group found for element:", element);
    return { success: false, usedFunc: "bool" };
  }
  const functionToCall = gofakeitFunc === "true" ? "bool" : gofakeitFunc;
  if (gofakeitFunc === "true") {
    const numToSelect = Math.max(1, Math.ceil(checkboxGroup.length / 2));
    checkboxGroup.forEach((cb) => {
      cb.checked = false;
      cb.dispatchEvent(new Event("change", { bubbles: true }));
    });
    const selectedIndices = /* @__PURE__ */ new Set();
    for (let i = 0; i < numToSelect; i++) {
      const boolResponse = await fetchGofakeitData("bool");
      if (boolResponse.success) {
        const shouldSelect = boolResponse.data.toLowerCase() === "true" || boolResponse.data.toLowerCase() === "1";
        if (shouldSelect) {
          const availableIndices = Array.from({ length: checkboxGroup.length }, (_, i2) => i2).filter((i2) => !selectedIndices.has(i2));
          if (availableIndices.length > 0) {
            const randomIndex = availableIndices[Math.floor(Math.random() * availableIndices.length)];
            selectedIndices.add(randomIndex);
            checkboxGroup[randomIndex].checked = true;
            checkboxGroup[randomIndex].dispatchEvent(new Event("change", { bubbles: true }));
          }
        }
      }
    }
  } else {
    const response = await fetchGofakeitData(functionToCall);
    if (!response.success) {
      console.warn(`[Gofakeit Autofill] Error for function ${functionToCall}:`, response.error);
      if (response.status === 400) {
        handleError(element, "", functionToCall);
      }
      return { success: false, usedFunc: functionToCall };
    }
    checkboxGroup.forEach((cb) => {
      cb.checked = false;
      cb.dispatchEvent(new Event("change", { bubbles: true }));
    });
    const values = response.data.split(",").map((v) => v.trim());
    checkboxGroup.forEach((cb, index) => {
      const shouldCheck = values.includes(cb.value) || values.includes(index.toString());
      cb.checked = shouldCheck;
      cb.dispatchEvent(new Event("change", { bubbles: true }));
    });
  }
  return { success: true, usedFunc: functionToCall };
}
async function handleRadio(element, gofakeitFunc) {
  const radioGroup = findRadioGroup(element);
  if (radioGroup.length === 0) {
    console.warn("[Gofakeit Autofill] No radio group found for element:", element);
    return { success: false, usedFunc: "bool" };
  }
  const functionToCall = gofakeitFunc === "true" ? "bool" : gofakeitFunc;
  if (gofakeitFunc === "true") {
    radioGroup.forEach((rb) => {
      rb.checked = false;
      rb.dispatchEvent(new Event("change", { bubbles: true }));
    });
    const boolResponse = await fetchGofakeitData("bool");
    if (boolResponse.success) {
      const shouldSelect = boolResponse.data.toLowerCase() === "true" || boolResponse.data.toLowerCase() === "1";
      if (shouldSelect) {
        const randomIndex = Math.floor(Math.random() * radioGroup.length);
        radioGroup[randomIndex].checked = true;
        radioGroup[randomIndex].dispatchEvent(new Event("change", { bubbles: true }));
      }
    }
  } else {
    const response = await fetchGofakeitData(functionToCall);
    if (!response.success) {
      console.warn(`[Gofakeit Autofill] Error for function ${functionToCall}:`, response.error);
      if (response.status === 400) {
        handleError(element, "", functionToCall);
      }
      return { success: false, usedFunc: functionToCall };
    }
    radioGroup.forEach((rb) => {
      rb.checked = false;
      rb.dispatchEvent(new Event("change", { bubbles: true }));
    });
    const value = response.data.trim();
    let selectedRadio = radioGroup.find((rb) => rb.value === value);
    if (!selectedRadio && !isNaN(Number(value))) {
      const index = parseInt(value);
      if (index >= 0 && index < radioGroup.length) {
        selectedRadio = radioGroup[index];
      }
    }
    if (selectedRadio) {
      selectedRadio.checked = true;
      selectedRadio.dispatchEvent(new Event("change", { bubbles: true }));
    }
  }
  return { success: true, usedFunc: functionToCall };
}
function findCheckboxGroup(element) {
  if (element.type !== "checkbox") return [element];
  const name = element.name;
  const container = element.closest("form, div, fieldset") || document;
  if (name) {
    return Array.from(container.querySelectorAll(`input[type="checkbox"][name="${name}"]`));
  } else {
    return Array.from(container.querySelectorAll('input[type="checkbox"]'));
  }
}
function findRadioGroup(element) {
  if (element.type !== "radio") return [element];
  const name = element.name;
  const container = element.closest("form, div, fieldset") || document;
  if (name) {
    return Array.from(container.querySelectorAll(`input[type="radio"][name="${name}"]`));
  } else {
    return Array.from(container.querySelectorAll('input[type="radio"]'));
  }
}
async function handleSelectWithFunction(element, gofakeitFunc) {
  const options = Array.from(element.options).map((option) => option.value).filter((value) => value !== "");
  if (options.length === 0) {
    console.warn("[Gofakeit Autofill] Select element has no valid options:", element);
    return { success: false, usedFunc: gofakeitFunc };
  }
  let response;
  if (gofakeitFunc === "true") {
    response = await fetchRandomString(options);
  } else {
    response = await fetchGofakeitData(gofakeitFunc);
  }
  if (!response.success) {
    console.warn(`[Gofakeit Autofill] Error for select:`, response.error);
    if (response.status === 400) {
      handleError(element, "Failed to get selection");
    }
    return { success: false, usedFunc: gofakeitFunc };
  }
  if (element.multiple) {
    Array.from(element.options).forEach((option) => option.selected = false);
    if (gofakeitFunc === "true") {
      const numToSelect = Math.min(Math.ceil(options.length / 2), options.length);
      const selectedValues = [response.data];
      const remainingOptions = options.filter((opt) => opt !== response.data);
      for (let i = 1; i < numToSelect && remainingOptions.length > 0; i++) {
        const randomIndex = Math.floor(Math.random() * remainingOptions.length);
        selectedValues.push(remainingOptions.splice(randomIndex, 1)[0]);
      }
      selectedValues.forEach((value) => {
        const option = element.options.namedItem(value) || Array.from(element.options).find((opt) => opt.value === value);
        if (option) option.selected = true;
      });
    } else {
      const selectedValues = response.data.split(",").map((val) => val.trim()).filter((val) => val !== "");
      selectedValues.forEach((value) => {
        const option = element.options.namedItem(value) || Array.from(element.options).find((opt) => opt.value === value);
        if (option) option.selected = true;
      });
    }
  } else {
    element.value = response.data;
  }
  element.dispatchEvent(new Event("change", { bubbles: true }));
  return { success: true, usedFunc: gofakeitFunc === "true" ? "random" : gofakeitFunc };
}
async function handleNumberInput(element, gofakeitFunc) {
  const functionToCall = gofakeitFunc === "true" ? "number" : gofakeitFunc;
  const response = await fetchGofakeitData(functionToCall);
  if (!response.success) {
    console.warn(`[Gofakeit Autofill] Error for function ${functionToCall}:`, response.error);
    if (response.status === 400) {
      handleError(element, "", functionToCall);
    }
    return { success: false, usedFunc: functionToCall };
  }
  element.value = response.data;
  element.dispatchEvent(new Event("input", { bubbles: true }));
  element.dispatchEvent(new Event("change", { bubbles: true }));
  return { success: true, usedFunc: functionToCall };
}
async function handleRangeInput(element, _gofakeitFunc) {
  const min = parseFloat(element.min) || 0;
  const max = parseFloat(element.max) || 100;
  const functionToCall = `number?min=${min}&max=${max}`;
  const response = await fetchGofakeitData(functionToCall);
  if (!response.success) {
    console.warn(`[Gofakeit Autofill] Error for range input:`, response.error);
    if (response.status === 400) {
      handleError(element, "Failed to get random number for range");
    }
    return { success: false, usedFunc: functionToCall };
  }
  element.value = response.data;
  element.dispatchEvent(new Event("input", { bubbles: true }));
  element.dispatchEvent(new Event("change", { bubbles: true }));
  return { success: true, usedFunc: functionToCall };
}
async function autofillAll() {
  const elements = queryFormElements();
  const smartEnabled = await isSmartFillEnabled();
  const targetsBase = smartEnabled ? elements : elements.filter((el) => el.hasAttribute("data-gofakeit"));
  const targets = targetsBase.filter((el) => !isDataGofakeitFalse(el));
  if (targets.length === 0) {
    if (!smartEnabled) {
      showNotification("No data-gofakeit fields exist. Turn on Smart-fill to fill this page.", "info");
    } else {
      showNotification("No form fields found to autofill", "info");
    }
    return;
  }
  console.log(`[Gofakeit] Found ${targets.length} elements to generate data for`);
  showNotification(`Starting data generation for ${targets.length} fields...`, "info");
  const results = await processElements(targets);
  showResults(results.success, results.failed, "Autofill");
}
async function autofillContainer(container) {
  const elements = queryFormElements(container);
  const smartEnabled = await isSmartFillEnabled();
  const targetsBase = smartEnabled ? elements : elements.filter((el) => el.hasAttribute("data-gofakeit"));
  const targets = targetsBase.filter((el) => !isDataGofakeitFalse(el));
  if (targets.length === 0) {
    if (!smartEnabled) {
      showNotification("No data-gofakeit fields exist in this section. Turn on Smart-fill to fill it.", "info");
    } else {
      showNotification("No form fields found in this container", "info");
    }
    return;
  }
  console.log(`[Gofakeit] Found ${targets.length} elements to generate data for in container`);
  showNotification(`Starting data generation for ${targets.length} fields...`, "info");
  const results = await processElements(targets);
  showResults(results.success, results.failed, "Container autofill");
}
async function autofillElement(element) {
  const gofakeitFunc = element.getAttribute("data-gofakeit");
  if (typeof gofakeitFunc === "string" && gofakeitFunc.trim().toLowerCase() === "false") {
    return false;
  }
  const smartEnabled = await isSmartFillEnabled();
  if (!gofakeitFunc && !smartEnabled) {
    return false;
  }
  try {
    if (element instanceof HTMLSelectElement) {
      const funcToUse = gofakeitFunc && gofakeitFunc !== "true" ? gofakeitFunc : "true";
      const { success, usedFunc } = await handleSelectWithFunction(element, funcToUse);
      if (success) {
        showFunctionBadge(element, usedFunc);
      }
      return success;
    }
    if (element instanceof HTMLTextAreaElement) {
      const funcToUse = gofakeitFunc && gofakeitFunc !== "true" ? gofakeitFunc : "sentence";
      const { success, usedFunc } = await handleTextarea(element, funcToUse);
      if (success) {
        showFunctionBadge(element, usedFunc);
      }
      return success;
    }
    if (element instanceof HTMLInputElement) {
      const inputType = element.type.toLowerCase();
      if (inputType === "checkbox") {
        const passToHandler = gofakeitFunc && gofakeitFunc !== "true" ? gofakeitFunc : "true";
        const { success: success2, usedFunc: usedFunc2 } = await handleCheckbox(element, passToHandler);
        if (success2) {
          showFunctionBadge(element, usedFunc2);
        }
        return success2;
      }
      if (inputType === "radio") {
        const passToHandler = gofakeitFunc && gofakeitFunc !== "true" ? gofakeitFunc : "true";
        const { success: success2, usedFunc: usedFunc2 } = await handleRadio(element, passToHandler);
        if (success2) {
          showFunctionBadge(element, usedFunc2);
        }
        return success2;
      }
      if (inputType === "number") {
        const inferred2 = gofakeitFunc && gofakeitFunc !== "true" ? gofakeitFunc : await inferFunctionForInput(element);
        const { success: success2, usedFunc: usedFunc2 } = await handleNumberInput(element, inferred2);
        if (success2) {
          showFunctionBadge(element, usedFunc2);
        }
        return success2;
      }
      if (inputType === "range") {
        const inferred2 = gofakeitFunc && gofakeitFunc !== "true" ? gofakeitFunc : await inferFunctionForInput(element);
        const { success: success2, usedFunc: usedFunc2 } = await handleRangeInput(element, inferred2);
        if (success2) {
          showFunctionBadge(element, usedFunc2);
        }
        return success2;
      }
      if (inputType === "date" || inputType === "time" || inputType === "datetime-local" || inputType === "month" || inputType === "week") {
        const inferred2 = gofakeitFunc && gofakeitFunc !== "true" ? gofakeitFunc : await inferFunctionForInput(element);
        const { success: success2, usedFunc: usedFunc2 } = await handleDateTimeInput(element, inferred2);
        if (success2) {
          showFunctionBadge(element, usedFunc2);
        }
        return success2;
      }
      const inferred = gofakeitFunc && gofakeitFunc !== "true" ? gofakeitFunc : await inferFunctionForInput(element);
      const { success, usedFunc } = await handleTextInput(element, inferred);
      if (success) {
        showFunctionBadge(element, usedFunc);
      }
      return success;
    }
    console.warn("[Gofakeit] Unsupported element type:", element);
    return false;
  } catch (error) {
    console.error("[Gofakeit] Unexpected error generating data for element:", element, error);
    return false;
  }
}
function queryFormElements(container) {
  const selector = "input, textarea, select";
  const nodeList = container ? container.querySelectorAll(selector) : document.querySelectorAll(selector);
  const elements = [];
  nodeList.forEach((el) => {
    if (el instanceof HTMLInputElement) {
      if (el.type === "hidden" || el.disabled || el.readOnly) return;
      elements.push(el);
    } else if (el instanceof HTMLTextAreaElement) {
      if (el.disabled || el.readOnly) return;
      elements.push(el);
    } else if (el instanceof HTMLSelectElement) {
      if (el.disabled) return;
      elements.push(el);
    }
  });
  return elements;
}
function isDataGofakeitFalse(el) {
  const val = el.getAttribute && el.getAttribute("data-gofakeit");
  return typeof val === "string" && val.trim().toLowerCase() === "false";
}
function getUniqueElements(elements) {
  const uniqueElements = [];
  const processedGroups = /* @__PURE__ */ new Set();
  for (const element of elements) {
    if (element instanceof HTMLInputElement) {
      const inputType = element.type.toLowerCase();
      if (inputType === "checkbox" || inputType === "radio") {
        const name = element.name;
        if (name && processedGroups.has(name)) {
          continue;
        }
        if (name) {
          processedGroups.add(name);
        }
      }
    }
    uniqueElements.push(element);
  }
  return uniqueElements;
}
async function processElements(elements, _context) {
  let successfulCount = 0;
  let failedCount = 0;
  const uniqueElements = getUniqueElements(elements);
  for (const element of uniqueElements) {
    try {
      const success = await autofillElement(element);
      if (success) {
        successfulCount++;
        setTimeout(() => {
          if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {
            if (element.value === "") {
              console.warn("[Gofakeit Autofill] Value was cleared for element:", element);
            }
          } else if (element instanceof HTMLSelectElement) {
            if (element.value === "") {
              console.warn("[Gofakeit Autofill] Value was cleared for select:", element);
            }
          }
        }, 1e3);
      } else {
        failedCount++;
      }
    } catch (error) {
      failedCount++;
      console.warn(`[Gofakeit Autofill] Failed to autofill element:`, element, error);
    }
  }
  return { success: successfulCount, failed: failedCount };
}
function showResults(successfulCount, failedCount, context) {
  if (successfulCount > 0) {
    console.log(`[Gofakeit] ${context} completed successfully for ${successfulCount} fields`);
    showNotification(`Successfully generated data for ${successfulCount} fields!`, "success");
  }
  if (failedCount > 0) {
    console.error(`[Gofakeit] ${context} failed for ${failedCount} fields`);
    showNotification(`Failed to generate data for ${failedCount} fields.`, "error");
  }
  if (successfulCount === 0 && failedCount === 0) {
    console.log(`[Gofakeit] ${context} - no fields were processed`);
    showNotification(`No fields were processed.`, "info");
  }
}
function handleError(element, error, functionName) {
  if (element instanceof HTMLElement) {
    element.style.border = `2px solid var(--color-error)`;
    setTimeout(() => {
      element.style.border = "";
    }, 5e3);
  }
  const message = functionName ? `Invalid function: ${functionName}` : error;
  showFieldError(element, message);
}
function showFunctionBadge(element, funcName) {
  if (!(element instanceof HTMLElement)) return;
  const badge = document.createElement("div");
  badge.textContent = funcName;
  badge.style.position = "fixed";
  badge.style.background = GOFAKEIT_COLORS.primary;
  badge.style.color = "#000";
  badge.style.fontFamily = "Arial, sans-serif";
  badge.style.fontSize = "11px";
  badge.style.padding = "3px 8px";
  badge.style.borderRadius = "6px";
  badge.style.boxShadow = "0 2px 6px rgba(0,0,0,0.25)";
  badge.style.zIndex = "2147483647";
  badge.style.opacity = "0";
  badge.style.transform = "translateY(-6px)";
  badge.style.transition = "opacity 200ms ease, transform 200ms ease";
  badge.style.pointerEvents = "none";
  const updatePosition = () => {
    const rect = element.getBoundingClientRect();
    const vh = window.innerHeight || document.documentElement.clientHeight;
    const vw = window.innerWidth || document.documentElement.clientWidth;
    const outOfView = rect.bottom <= 0 || rect.top >= vh || rect.right <= 0 || rect.left >= vw;
    if (outOfView) {
      badge.style.display = "none";
      return;
    }
    if (badge.style.display === "none") badge.style.display = "block";
    const top = rect.top - 8;
    const left = rect.left;
    badge.style.top = `${top}px`;
    badge.style.left = `${left}px`;
  };
  document.body.appendChild(badge);
  updatePosition();
  requestAnimationFrame(() => {
    badge.style.opacity = "1";
    badge.style.transform = "translateY(-12px)";
  });
  const onScroll = () => updatePosition();
  const onResize = () => updatePosition();
  window.addEventListener("scroll", onScroll, true);
  window.addEventListener("resize", onResize, true);
  let ro = null;
  if (typeof ResizeObserver !== "undefined") {
    ro = new ResizeObserver(() => updatePosition());
    try {
      ro.observe(element);
    } catch {
    }
  }
  const DISPLAY_MS = 6e3;
  setTimeout(() => {
    badge.style.opacity = "0";
    badge.style.transform = "translateY(-6px)";
    setTimeout(() => {
      window.removeEventListener("scroll", onScroll, true);
      window.removeEventListener("resize", onResize, true);
      if (ro) {
        try {
          ro.disconnect();
        } catch {
        }
        ro = null;
      }
      if (badge.parentNode) badge.parentNode.removeChild(badge);
    }, 220);
  }, DISPLAY_MS);
}
async function isSmartFillEnabled() {
  return new Promise((resolve) => {
    try {
      chrome.storage.sync.get({ gofakeitSmartFill: true }, (items) => {
        resolve(!!items.gofakeitSmartFill);
      });
    } catch {
      resolve(false);
    }
  });
}
function getAssociatedLabelText(input) {
  const texts = [];
  const id = input.id;
  const labelledBy = input.getAttribute("aria-labelledby");
  if (labelledBy) {
    labelledBy.split(/\s+/).forEach((ref) => {
      const el = document.getElementById(ref);
      if (el && el.textContent) texts.push(el.textContent);
    });
  }
  if (id) {
    try {
      const lbl = document.querySelector('label[for="' + id.replace(/"/g, '\\"') + '"]');
      if (lbl && lbl.textContent) texts.push(lbl.textContent);
    } catch {
    }
  }
  const closestLabel = input.closest("label");
  if (closestLabel && closestLabel.textContent) texts.push(closestLabel.textContent);
  const prev = input.previousElementSibling;
  if (prev && prev.tagName === "LABEL" && prev.textContent) texts.push(prev.textContent);
  return texts.join(" ").toLowerCase();
}
async function inferFunctionForInput(input) {
  const type = input.type.toLowerCase();
  const name = (input.name || "").toLowerCase();
  const id = (input.id || "").toLowerCase();
  const placeholder = (input.placeholder || "").toLowerCase();
  const autocomplete = (input.autocomplete || "").toLowerCase();
  const ariaLabel = (input.getAttribute("aria-label") || "").toLowerCase();
  const labelText = getAssociatedLabelText(input);
  const text = `${name} ${id} ${placeholder} ${autocomplete} ${ariaLabel} ${labelText}`;
  const pick = (fn, fallback = "word") => hasFunc(fn) ? fn : fallback;
  if (type === "email" || /email/.test(text)) return pick("email");
  if (type === "password" || /password|pass/.test(text)) return pick("password");
  if (type === "tel" || /phone|tel|mobile/.test(text)) return pick("phone");
  if (type === "url" || /url|website/.test(text)) return pick("url");
  if (type === "color" || /color/.test(text)) return pick("hexcolor");
  if (type === "number" || /\b(?:age|qty|quantity|count|amount)\b/.test(text)) {
    return hasFunc("number") ? "number?min=1&max=9999" : "word";
  }
  if (type === "" || type === "text") {
    const placeholderRaw = (input.placeholder || "").trim();
    if (/^[+-]?\d+$/.test(placeholderRaw)) {
      const digits = Math.min(placeholderRaw.replace(/[^0-9]/g, "").length || 1, 9);
      const max = Math.pow(10, digits) - 1;
      return `number?min=0&max=${max}`;
    }
    if (/^[+-]?\d+\.\d+$/.test(placeholderRaw)) {
      const parts = placeholderRaw.replace(/[^0-9.]/g, "").split(".");
      const fracDigits = Math.min((parts[1] || "2").length, 6);
      return `generate?str={number:0,100}.{generate:${"#".repeat(fracDigits)}}`;
    }
  }
  const looksLikeCcField = /credit\s*card|card\b|cc\b/.test(text) && /(number|no|num)/.test(text) || /card[-_ ]?number|credit[-_ ]?card[-_ ]?number/.test(text) || ariaLabel.includes("credit card number") || placeholder.includes("") || input.maxLength >= 16 && input.maxLength <= 19 && /card|credit/.test(text);
  if (looksLikeCcField) {
    return "creditcardnumber";
  }
  if (/\bcvv\b|\bcvc\b|security\s*code|card\s*code|\bcid\b|\bcv2\b/.test(text)) {
    if (hasFunc("creditcardcvv")) return "creditcardcvv";
  }
  if (/\bexp(iry|iration)?\b|valid\s*(thru|through)|mm\s*\/\s*yy|yy\s*\/\s*mm|mm\s*yy|yy\s*mm|expiry\s*date|exp\.?\s*date/.test(text) || /\b\d{2}\s*\/\s*\d{2}\b/.test((input.value || "").toLowerCase())) {
    if (hasFunc("creditcardexp")) return "creditcardexp";
  }
  if (type === "date" || /\bdate\b|\bdob\b|birthday/.test(text)) return pick("date");
  if (type === "time" || /\btime\b/.test(text)) return pick("date");
  if (type === "datetime-local" || /\bdatetime\b|appointment/.test(text)) return pick("date");
  if (/\baccount\b\s*(?:number|no)\b|\bacct\b/.test(text) || /\baccount\s*number\b/.test(placeholder)) {
    if (hasFunc("achaccount")) return "achaccount";
  }
  if (/routing\s*(number|no)|\baba\b/.test(text)) {
    if (hasFunc("achrouting")) return "achrouting";
  }
  if (/(^|\b)(apartment|apt|suite|unit|floor|bldg|building|room|ste|address[-_ ]?line[-_ ]?2|address2|addr2|line[-_ ]?2)(\b|$)/.test(text)) {
    return pick("unit");
  }
  if (/first\s*name|firstname|first_name|given/.test(text)) return pick("firstname");
  if (/last\s*name|lastname|last_name|surname|family/.test(text)) return pick("lastname");
  if (/full\s*name|fullname/.test(text)) return pick("name");
  if (/city/.test(text)) return pick("city");
  if (/state|province|region/.test(text)) return pick("state");
  if (/\bpostal\b|\bpostal[-_ ]?code\b|\bpostcode\b|\bzip\b|\bzip[-_ ]?code\b/.test(text)) {
    return hasFunc("postcode") ? "postcode" : "zip";
  }
  if (/address|street/.test(text)) return pick("street");
  if (/company|organization|org/.test(text)) return pick("company");
  if (/job|title|role/.test(text)) return pick("jobtitle", pick("job"));
  if (/website|domain/.test(text)) return pick("url");
  if (/username|user\b/.test(text)) return pick("username");
  if (type === "search") return "word";
  if (hasFunc("word")) return "word";
  return "word";
}
function showNotification(message, type = "info") {
  console.log(`[Gofakeit ${type.toUpperCase()}] ${message}`);
}
export {
  autofillAll,
  autofillContainer,
  autofillElement
};
//# sourceMappingURL=index.js.map
