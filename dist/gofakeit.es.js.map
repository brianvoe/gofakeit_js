{"version":3,"file":"gofakeit.es.js","sources":["../src/api.ts","../src/styles.ts","../src/autofill.ts"],"sourcesContent":["// Base URL for the Gofakeit API\nconst GOFAKEIT_API_BASE = 'https://api.gofakeit.com/funcs';\n\n// Interface for function parameters\nexport interface FetchFuncParams {\n  [key: string]: string | number | boolean | string[];\n}\n\nexport interface FetchFuncResponse {\n  success: boolean;\n  data?: string;\n  error?: string;\n  status?: number;\n}\n\n// Multi-function request interface\nexport interface FetchFuncMultiRequest {\n  id?: string;\n  func: string;\n  params?: FetchFuncParams;\n}\n\n// Multi-function response item interface\nexport interface FetchFuncMultiResponseItem {\n  id?: string;\n  value: string | number | boolean | null;\n  error?: string;\n}\n\n// Multi-function response interface\nexport interface FetchFuncMultiResponse {\n  success: boolean;\n  data?: FetchFuncMultiResponseItem[];\n  error?: string;\n  status?: number;\n}\n\n// Function search request interface\nexport interface FetchFuncSearchRequest {\n  id: string;\n  query: string;\n}\n\n// Function search result interface\nexport interface FetchFuncSearchResult {\n  name: string; // function name for API usage\n  score: number; // relevance score (0-100)\n  reasons: string[]; // why it matched\n}\n\n// Function search response item interface\nexport interface FetchFuncSearchResponseItem {\n  id: string;\n  query: string;\n  results: FetchFuncSearchResult[];\n}\n\n// Multi-function search response interface\nexport interface FetchFuncSearchResponse {\n  success: boolean;\n  data?: FetchFuncSearchResponseItem[];\n  error?: string;\n  status?: number;\n}\n\n// Fetch data from gofakeit API\nexport async function fetchFunc(\n  func: string,\n  params?: FetchFuncParams\n): Promise<FetchFuncResponse> {\n  const { func: funcName, params: extractedParams } = parseFunctionString(func);\n\n  // Merge extracted params with provided params (provided params take precedence)\n  const finalParams = { ...extractedParams, ...(params || {}) };\n\n  // Always use POST request\n  return makeRequest('POST', `${GOFAKEIT_API_BASE}/${funcName}`, finalParams);\n}\n\n// Call multiple functions in a single request\nexport async function fetchFuncMulti(\n  requests: FetchFuncMultiRequest[]\n): Promise<FetchFuncMultiResponse> {\n  if (requests.length === 0) {\n    return {\n      success: false,\n      error: 'No functions provided',\n    };\n  }\n\n  // Process each request to extract function name and parameters\n  const processedRequests: FetchFuncMultiRequest[] = requests.map(\n    (req, index) => {\n      const { func, id, params } = req;\n      const { func: funcName, params: extractedParams } =\n        parseFunctionString(func);\n\n      // Merge extracted params with provided params (provided params take precedence)\n      const finalParams = { ...extractedParams, ...(params || {}) };\n\n      return {\n        id: id || `req_${index}`,\n        func: funcName,\n        params: finalParams,\n      };\n    }\n  );\n\n  return makeRequest<FetchFuncMultiResponse>(\n    'POST',\n    `${GOFAKEIT_API_BASE}/multi`,\n    processedRequests\n  );\n}\n\n// Search for multiple functions in a single request\nexport async function fetchFuncSearch(\n  requests: FetchFuncSearchRequest[]\n): Promise<FetchFuncSearchResponse> {\n  if (requests.length === 0) {\n    return {\n      success: false,\n      error: 'No search queries provided',\n    };\n  }\n\n  return makeRequest<FetchFuncSearchResponse>(\n    'POST',\n    `${GOFAKEIT_API_BASE}/search`,\n    requests\n  );\n}\n\n// Base HTTP request function\n// Unified HTTP request function for all API calls\nasync function makeRequest<T>(\n  method: 'GET' | 'POST',\n  url: string,\n  body?: FetchFuncParams | FetchFuncMultiRequest[] | FetchFuncSearchRequest[]\n): Promise<T> {\n  try {\n    const options: {\n      method: string;\n      headers: Record<string, string>;\n      body?: string;\n    } = {\n      method: method,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    };\n\n    if (method === 'POST' && body) {\n      options.body = JSON.stringify(body);\n    }\n\n    const response = await fetch(url, options);\n\n    if (!response.ok) {\n      return {\n        success: false,\n        error: `HTTP error! status: ${response.status}`,\n        status: response.status,\n      } as T;\n    }\n\n    // Determine response parsing based on URL\n    let data;\n    if (url.includes('/multi') || url.includes('/search')) {\n      data = await response.json();\n    } else {\n      data = await response.text();\n    }\n\n    return {\n      success: true,\n      data: data,\n    } as T;\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    } as T;\n  }\n}\n\n// Parse function string to extract function name and parameters\nexport function parseFunctionString(func: string): {\n  func: string;\n  params: FetchFuncParams;\n} {\n  const questionMarkIndex = func.indexOf('?');\n\n  if (questionMarkIndex !== -1) {\n    // Function has query parameters - extract them\n    const functionName = func.substring(0, questionMarkIndex);\n    const queryString = func.substring(questionMarkIndex + 1);\n\n    // Parse query parameters into an object\n    const params: FetchFuncParams = {};\n    const searchParams = new URLSearchParams(queryString);\n\n    for (const [key, value] of searchParams.entries()) {\n      // Try to parse as number if possible\n      const numValue = parseFloat(value);\n      params[key] = isNaN(numValue) ? value : numValue;\n    }\n\n    return { func: functionName, params };\n  } else {\n    // Simple function with no parameters\n    return { func: func, params: {} };\n  }\n}\n","// Centralized style tokens for injected UI (avoid dependency on site CSS)\n\nexport const GOFAKEIT_COLORS = {\n  primary: '#ffa000',\n  white: '#ffffff',\n  success: '#48c774',\n  error: '#ff3860',\n  info: '#209cee',\n  text: '#333333',\n  border: '#686868',\n  background: '#22272e',\n};\n\nexport const GOFAKEIT_SPACING = {\n  base: 16, // px\n  half: 8, // px\n  quarter: 4, // px\n};\n\nexport const GOFAKEIT_BORDER = {\n  radius: 4, // px\n  width: 2, // px\n};\n\nexport const GOFAKEIT_FONT = {\n  size: 12, // px\n  family: 'Helvetica, Arial, sans-serif',\n};\n","import {\n  fetchFuncMulti,\n  FetchFuncMultiRequest,\n  fetchFuncSearch,\n  FetchFuncSearchRequest,\n  FetchFuncParams,\n} from './api';\nimport {\n  GOFAKEIT_COLORS,\n  GOFAKEIT_SPACING,\n  GOFAKEIT_BORDER,\n  GOFAKEIT_FONT,\n} from './styles';\n\nexport enum AutofillStatus {\n  STARTING = 'starting',\n  FOUND = 'found',\n  DETERMINED = 'determined',\n  GENERATED = 'generated',\n  SET = 'set',\n  COMPLETED = 'completed',\n  ERROR = 'error',\n}\n\nexport interface AutofillSettings {\n  mode?: 'auto' | 'manual';\n  stagger?: number;\n  badges?: number;\n  debug?: boolean;\n\n  // Callbacks\n  onStatusChange?: (\n    status: AutofillStatus,\n    elements: AutofillElement[]\n  ) => void;\n}\n\nexport interface AutofillState {\n  status?: AutofillStatus;\n  elements: AutofillElement[];\n}\n\nexport interface AutofillElement {\n  id: string; // id of the element\n  name: string; // name of the element\n  element: Element; // element to autofill\n  type: string; // element type\n  function: string; // function that will be used to autofill the element\n  search: string; // search query that will be used to autofill the element\n  value: string; // value of the autofill result\n  error: string; // error message\n}\n\nexport interface AutofillResult {\n  elements: AutofillElement[];\n  error?: string;\n}\n\nexport interface AutofillResults {\n  success: number;\n  failed: number;\n  elements: AutofillElement[];\n}\n\nexport class Autofill {\n  public settings: AutofillSettings;\n  public state: AutofillState;\n\n  constructor(settings: AutofillSettings = {}) {\n    this.settings = {\n      mode: 'auto',\n      stagger: 50,\n      badges: 3000,\n      debug: false,\n      ...settings,\n    };\n\n    this.state = {\n      elements: [],\n    };\n  }\n\n  public updateSettings(settings: AutofillSettings): void {\n    this.settings = { ...this.settings, ...settings };\n  }\n\n  // ============================================================================\n  // MAIN FILL FUNCTION\n  // ============================================================================\n\n  async fill(\n    target?: HTMLElement | Element | string\n  ): Promise<AutofillResults> {\n    this.state.elements = []; // Clear previous elements\n    this.updateStatus(AutofillStatus.STARTING);\n\n    // Step 1: Set all target elements based on the target parameter\n    this.setElements(target);\n    if (this.state.elements.length === 0) {\n      this.debug('info', 'No form fields found to fill');\n      this.updateStatus(AutofillStatus.COMPLETED);\n      return this.results();\n    }\n    this.updateStatus(AutofillStatus.FOUND);\n\n    // Step 2: Determine functions for elements that need search\n    await this.setElementFunctions();\n    this.updateStatus(AutofillStatus.DETERMINED);\n\n    // Step 3: Get values for all elements via multi-function API\n    await this.getElementValues();\n    this.updateStatus(AutofillStatus.GENERATED);\n\n    // Step 4: set values to the actual form elements\n    await this.setElementValues();\n    this.updateStatus(AutofillStatus.SET);\n\n    // Return the results\n    this.updateStatus(AutofillStatus.COMPLETED);\n    return this.results();\n  }\n\n  // ============================================================================\n  // Step 1: Set all target elements based on the target parameter\n  // ============================================================================\n\n  // Public method to set form elements based on target parameter\n  public setElements(target?: HTMLElement | Element | string): void {\n    const allFormElements: Element[] = [];\n\n    if (target) {\n      if (typeof target === 'string') {\n        // For string selectors, get the matching elements and search within them\n        const elements = document.querySelectorAll(target);\n        if (elements.length === 0) {\n          this.debug('error', `No element found with selector: \"${target}\"`);\n          this.updateStatus(AutofillStatus.ERROR);\n          this.state.elements = [];\n          return;\n        }\n        // Search within each matching element for form elements\n        elements.forEach(el => {\n          if (\n            el instanceof HTMLInputElement ||\n            el instanceof HTMLTextAreaElement ||\n            el instanceof HTMLSelectElement\n          ) {\n            // If the element itself is a form element, add it\n            if (this.shouldSkipElement(el)) return;\n            allFormElements.push(el);\n          } else {\n            // If it's not a form element, search within it for form elements\n            const selector = 'input, textarea, select';\n            const nodeList = el.querySelectorAll(selector);\n\n            nodeList.forEach(formEl => {\n              // Skip hidden, disabled, or readonly elements\n              if (this.shouldSkipElement(formEl)) return;\n              allFormElements.push(formEl);\n            });\n          }\n        });\n      } else if (target instanceof HTMLElement || target instanceof Element) {\n        // For element targets, check if the element itself is a form element\n        if (\n          target instanceof HTMLInputElement ||\n          target instanceof HTMLTextAreaElement ||\n          target instanceof HTMLSelectElement\n        ) {\n          // Skip hidden, disabled, or readonly elements\n          if (this.shouldSkipElement(target)) {\n            this.state.elements = [];\n            return;\n          }\n          allFormElements.push(target);\n        } else {\n          // If it's not a form element, search within it\n          const selector = 'input, textarea, select';\n          const nodeList = target.querySelectorAll(selector);\n\n          nodeList.forEach(el => {\n            // Skip hidden, disabled, or readonly elements\n            if (this.shouldSkipElement(el)) return;\n            allFormElements.push(el);\n          });\n        }\n      }\n    } else {\n      // No target specified, search the entire document\n      const selector = 'input, textarea, select';\n      const nodeList = document.querySelectorAll(selector);\n\n      nodeList.forEach(el => {\n        // Skip hidden, disabled, or readonly elements\n        if (this.shouldSkipElement(el)) return;\n        allFormElements.push(el);\n      });\n    }\n\n    // Step 3: Filter elements based on mode and data-gofakeit attributes\n    const mode = this.settings.mode ?? 'auto';\n    const filteredElements: Element[] = [];\n\n    for (const element of allFormElements) {\n      const gofakeitFunc = element.getAttribute('data-gofakeit');\n\n      // Skip if explicitly disabled\n      if (\n        typeof gofakeitFunc === 'string' &&\n        gofakeitFunc.trim().toLowerCase() === 'false'\n      ) {\n        continue;\n      }\n\n      // In manual mode, only include elements with data-gofakeit attribute\n      if (mode === 'manual' && !gofakeitFunc) {\n        continue;\n      }\n\n      // In auto mode, include all elements (with or without data-gofakeit)\n      filteredElements.push(element);\n    }\n\n    // Loop through filteredElements and create AutofillElement objects\n    const autofillElements: AutofillElement[] = [];\n    for (const element of filteredElements) {\n      // random 8 digit alphanumeric string\n      const id =\n        Math.random().toString(36).substring(2, 15) +\n        Math.random().toString(36).substring(2, 15);\n\n      // add new element to the autofillElements array\n      autofillElements.push({\n        id: id,\n        name: element.getAttribute('name') || '',\n        element,\n        type: this.getElementType(element),\n        function: '',\n        search: this.getElementSearch(element as HTMLInputElement),\n        value: '',\n        error: '',\n      });\n    }\n\n    this.state.elements = autofillElements;\n\n    // Debug output for element selection\n    if (autofillElements.length > 0) {\n      this.debug(\n        'info',\n        `Found ${autofillElements.length} elements to generate data for`\n      );\n    }\n  }\n\n  // Check if an element should be skipped (hidden, disabled, or readonly)\n  public shouldSkipElement(element: Element): boolean {\n    if (element instanceof HTMLInputElement) {\n      return element.type === 'hidden' || element.disabled || element.readOnly;\n    } else if (element instanceof HTMLTextAreaElement) {\n      return element.disabled || element.readOnly;\n    } else if (element instanceof HTMLSelectElement) {\n      return element.disabled;\n    }\n    return false;\n  }\n\n  // Get the element type\n  private getElementType(element: Element): string {\n    if (element instanceof HTMLInputElement) {\n      return element.type.toLowerCase();\n    } else if (element instanceof HTMLTextAreaElement) {\n      return 'textarea';\n    } else if (element instanceof HTMLSelectElement) {\n      return 'select';\n    }\n    return 'unknown';\n  }\n\n  // Get the comprehensive search string for an element\n  public getElementSearch(el: Element): string {\n    // Get label text from various sources\n    const labelTexts: string[] = [];\n    const id = el.id;\n\n    // aria-labelledby\n    const labelledBy = el.getAttribute('aria-labelledby');\n    if (labelledBy) {\n      labelledBy.split(/\\s+/).forEach(ref => {\n        const labelEl = document.getElementById(ref);\n        if (labelEl && labelEl.textContent)\n          labelTexts.push(labelEl.textContent);\n      });\n    }\n\n    // explicit label[for]\n    if (id) {\n      const lbl = document.querySelector(\n        'label[for=\"' + id.replace(/\"/g, '\\\\\"') + '\"]'\n      ) as HTMLLabelElement | null;\n      if (lbl && lbl.textContent) labelTexts.push(lbl.textContent);\n    }\n\n    // implicit parent label\n    const closestLabel = el.closest('label');\n    if (closestLabel && closestLabel.textContent)\n      labelTexts.push(closestLabel.textContent);\n\n    // previous sibling label (common in some UIs)\n    const prev = el.previousElementSibling as HTMLElement | null;\n    if (prev && prev.tagName === 'LABEL' && prev.textContent)\n      labelTexts.push(prev.textContent);\n\n    const labelText = labelTexts.join(' ').toLowerCase();\n\n    // Get additional element attributes for comprehensive search\n    const type = el instanceof HTMLInputElement ? el.type.toLowerCase() : '';\n    const name = (el.getAttribute('name') || '').toLowerCase();\n    const elementId = (el.id || '').toLowerCase();\n    const placeholder =\n      el instanceof HTMLInputElement\n        ? (el.placeholder || '').toLowerCase()\n        : '';\n    const autocomplete =\n      el instanceof HTMLInputElement\n        ? (el.autocomplete || '').toLowerCase()\n        : '';\n    const ariaLabel = (el.getAttribute('aria-label') || '').toLowerCase();\n\n    // Build a comprehensive search query with all available information\n    const queryParts = [\n      type,\n      name,\n      elementId,\n      placeholder,\n      autocomplete,\n      ariaLabel,\n      labelText,\n    ].filter(part => part && part.trim());\n\n    // Join all parts with spaces to create a comprehensive search query\n    const searchQuery = queryParts\n      .join(' ')\n      .toLowerCase()\n      .replace(/[^\\w\\s]/g, ' ') // Remove special characters\n      .replace(/\\s+/g, ' ') // Normalize whitespace\n      .trim();\n\n    return searchQuery;\n  }\n\n  // ============================================================================\n  // Step 2: Determine functions for elements that need search\n  // ============================================================================\n\n  public async setElementFunctions(): Promise<void> {\n    this.debug(\n      'info',\n      `Determining functions for ${this.state.elements.length} elements`\n    );\n\n    // Step 1: Loop through elements and set functions for types that don't need search\n    const elementsNeedingSearch: AutofillElement[] = [];\n\n    for (const el of this.state.elements) {\n      const functionName = this.getElementFunction(el.element);\n\n      if (functionName !== null) {\n        // Function determined - use it directly\n        el.function = functionName;\n      } else {\n        // Function needs search - add to search array\n        elementsNeedingSearch.push(el);\n      }\n    }\n\n    // Step 2: Handle elements that need search\n    if (elementsNeedingSearch.length > 0) {\n      this.debug(\n        'info',\n        `${elementsNeedingSearch.length} elements need function search`\n      );\n\n      // Create search requests using existing search values from state\n      const searchRequests: FetchFuncSearchRequest[] =\n        elementsNeedingSearch.map((el, index) => {\n          return {\n            id:\n              el.element.id ||\n              el.element.getAttribute('name') ||\n              `input_${index}`,\n            query: el.search,\n          };\n        });\n\n      const response = await fetchFuncSearch(searchRequests);\n\n      if (response.success && response.data) {\n        // Map results back to elements - use first result regardless of score\n        for (let i = 0; i < response.data.length; i++) {\n          const searchResult = response.data[i];\n          const el = elementsNeedingSearch[i];\n\n          if (searchResult.results && searchResult.results.length > 0) {\n            // Use the first result, not based on score\n            el.function = searchResult.results[0].name;\n          } else {\n            // Fallback to type-specific function if no search results\n            el.function = this.getElementFunctionFallback(el.element);\n          }\n        }\n      } else {\n        // Fallback to type-specific functions if search fails\n        for (const el of elementsNeedingSearch) {\n          el.function = this.getElementFunctionFallback(el.element);\n        }\n      }\n    }\n\n    this.debug('info', 'Function determination complete');\n  }\n\n  public getElementFunction(element: Element): string | null {\n    const gofakeitFunc = element.getAttribute('data-gofakeit');\n    const elementType = this.getElementType(element);\n\n    if (gofakeitFunc && gofakeitFunc !== 'true') {\n      // Specific function provided - use it directly\n      return gofakeitFunc;\n    } else if (gofakeitFunc === 'true') {\n      // Function is 'true' - check if element type needs search\n      const needsSearch = this.elementTypeNeedsSearch(elementType);\n\n      if (needsSearch) {\n        // Element type needs search - return null\n        return null;\n      } else {\n        // Element type doesn't need search - use fallback function even with data-gofakeit=\"true\"\n        return this.getElementFunctionFallback(element);\n      }\n    } else {\n      // No function specified - check if element type needs search\n      const needsSearch = this.elementTypeNeedsSearch(elementType);\n\n      if (needsSearch) {\n        // Element type needs search - return null\n        return null;\n      } else {\n        // Element type doesn't need search - use fallback function\n        return this.getElementFunctionFallback(element);\n      }\n    }\n  }\n\n  private elementTypeNeedsSearch(elementType: string): boolean {\n    const skipSearchTypes = [\n      'checkbox',\n      'radio',\n      'select',\n      'number',\n      'range',\n      'file',\n      'button',\n      'submit',\n      'reset',\n      'image',\n      'week',\n      'date',\n      'time',\n      'datetime-local',\n      'month',\n      'color',\n    ];\n    return !skipSearchTypes.includes(elementType);\n  }\n\n  // If the element doesnt have a function and search doesnt return a function,\n  // we will use a fallback function\n  private getElementFunctionFallback(element: Element): string {\n    if (element instanceof HTMLInputElement) {\n      const elementType = element.type.toLowerCase();\n\n      switch (elementType) {\n        case 'date':\n        case 'datetime-local':\n        case 'month':\n        case 'week': {\n          // Check if input has min/max attributes to determine if it should use daterange\n          const min = element.getAttribute('min');\n          const max = element.getAttribute('max');\n          return min || max ? 'daterange' : 'date';\n        }\n        case 'time':\n          return 'time';\n        case 'text':\n          return 'word';\n        case 'email':\n          return 'email';\n        case 'tel':\n          return 'phone';\n        case 'url':\n          return 'url';\n        case 'password':\n          return 'password';\n        case 'search':\n          return 'word';\n        case 'number':\n        case 'range': {\n          // Check if input has min/max attributes to determine if it should use number with parameters\n          const min = element.getAttribute('min');\n          const max = element.getAttribute('max');\n          return min || max ? 'number' : 'number'; // Both use 'number' function, but with different parameters\n        }\n        case 'color':\n          return 'hexcolor';\n        case 'checkbox':\n          return 'bool';\n        case 'radio':\n          return 'randomstring';\n        default:\n          return 'word';\n      }\n    } else if (element instanceof HTMLTextAreaElement) {\n      return 'sentence';\n    } else if (element instanceof HTMLSelectElement) {\n      return 'randomstring';\n    }\n\n    return 'word';\n  }\n\n  // ============================================================================\n  // Step 3: Get values for all elements via multi-function API\n  // ============================================================================\n\n  // Get values for all elements via multi-function API\n  public async getElementValues(): Promise<void> {\n    this.debug('info', 'Starting value generation...');\n    const elementsNeedingValues = this.state.elements.filter(\n      el => el.function && !el.error\n    );\n\n    if (elementsNeedingValues.length === 0) {\n      this.debug('info', 'No elements need value generation');\n      return;\n    }\n\n    this.debug(\n      'info',\n      `Getting values for ${elementsNeedingValues.length} elements from API`\n    );\n\n    const requests: FetchFuncMultiRequest[] = [];\n    const processedNames: string[] = []; // Track processed radio group names\n    const requestToElementMap: AutofillElement[] = []; // Map requests to elements\n\n    // Process each element, adding parameters based on function type\n    for (const el of elementsNeedingValues) {\n      // Skip radio elements that are part of a group we've already processed\n      if (el.type === 'radio' && el.name && processedNames.includes(el.name)) {\n        continue;\n      }\n\n      const request: FetchFuncMultiRequest = {\n        id: el.id,\n        func: el.function,\n      };\n\n      // Add parameters based on element type\n      switch (el.type) {\n        case 'select':\n          request.params = this.paramsSelect(el.element as HTMLSelectElement);\n          break;\n        case 'radio': {\n          // For radio groups, get all radio elements with the same name\n          const radioGroup = elementsNeedingValues.filter(\n            otherEl => otherEl.type === 'radio' && otherEl.name === el.name\n          );\n          request.params = this.paramsRadio(radioGroup);\n          // Mark this radio group as processed\n          if (el.name) {\n            processedNames.push(el.name);\n          }\n          break;\n        }\n        case 'date':\n        case 'datetime-local':\n        case 'month': {\n          const params = this.paramsDate(el);\n          if (params && (params.startdate || params.enddate)) {\n            request.func = 'daterange';\n            request.params = params;\n          } else {\n            request.params = params;\n          }\n          break;\n        }\n        case 'time': {\n          // For time inputs, use 'time' function with format\n          request.params = { format: 'HH:mm' };\n          break;\n        }\n        case 'week': {\n          const params = this.paramsWeek(el);\n          if (params && (params.startdate || params.enddate)) {\n            request.func = 'daterange';\n            request.params = params;\n          } else {\n            request.func = 'date';\n            request.params = params;\n          }\n          break;\n        }\n        case 'number':\n        case 'range': {\n          const params = this.paramsNumber(el);\n          request.params = params;\n          break;\n        }\n        // Add other element type cases here as needed\n        default:\n          // No special parameters needed\n          break;\n      }\n\n      requests.push(request);\n      requestToElementMap.push(el);\n    }\n\n    const response = await fetchFuncMulti(requests);\n\n    if (response.success && response.data) {\n      // Map results back to elements using the correct mapping\n      for (let i = 0; i < response.data.length; i++) {\n        const result = response.data[i];\n        const el = requestToElementMap[i];\n\n        if (result.value !== null && result.value !== undefined) {\n          el.value = String(result.value);\n        } else if (result.error) {\n          el.error = result.error;\n        } else {\n          el.error = 'Unknown API error';\n        }\n      }\n    } else {\n      // Set error for all elements if the request failed\n      for (const el of elementsNeedingValues) {\n        el.error = response.error || 'API request failed';\n      }\n    }\n\n    this.debug('info', 'Value generation complete');\n  }\n\n  // ============================================================================\n  // Step 4: Set values to the actual form elements\n  // ============================================================================\n\n  // Set values to the actual form elements\n  public async setElementValues(): Promise<void> {\n    this.debug('info', 'Starting value application...');\n    if (this.state.elements.length === 0) {\n      this.debug('info', 'No elements to apply values to');\n      return;\n    }\n\n    this.debug('info', `Processing ${this.state.elements.length} elements`);\n\n    // Track processed radio group names to avoid duplicate badges\n    const processedRadioNames: string[] = [];\n\n    // Process all elements with optional staggering and show badges for each\n    for (let i = 0; i < this.state.elements.length; i++) {\n      const el = this.state.elements[i];\n      let elementToShowBadge: AutofillElement | null = null;\n\n      // Handle different element types\n      switch (el.type) {\n        case 'radio':\n          // Only process if we haven't already processed this radio group\n          if (el.name && !processedRadioNames.includes(el.name)) {\n            processedRadioNames.push(el.name);\n            elementToShowBadge = this.setRadioGroup(el);\n          }\n          break;\n        default:\n          // Only set value if el has a valid value and no error\n          if (el.value !== undefined && el.value !== null && !el.error) {\n            this.setElementValue(el);\n          }\n          elementToShowBadge = el;\n          break;\n      }\n\n      // Show badge for the appropriate element\n      if (\n        this.settings.badges &&\n        this.settings.badges > 0 &&\n        elementToShowBadge\n      ) {\n        this.showBadge(elementToShowBadge);\n      }\n\n      // Add delay between applications (except for the last one) if stagger is enabled\n      if (\n        this.settings.stagger &&\n        this.settings.stagger > 0 &&\n        i < this.state.elements.length - 1\n      ) {\n        await new Promise(resolve =>\n          setTimeout(resolve, this.settings.stagger)\n        );\n      }\n    }\n\n    this.debug('info', 'Value application complete');\n  }\n\n  private setRadioGroup(el: AutofillElement): AutofillElement | null {\n    // Find all radio elements in the same group\n    const radioGroup = this.state.elements.filter(\n      otherEl => otherEl.type === 'radio' && otherEl.name === el.name\n    );\n\n    // Find the radio element that matches the returned value\n    const selectedRadio = radioGroup.find(radioEl => {\n      const input = radioEl.element as HTMLInputElement;\n\n      // Check if the value attribute is explicitly set\n      const hasExplicitValue = input.hasAttribute('value');\n\n      // First try to match by value attribute if it's explicitly set or not the default \"on\"\n      if (\n        (hasExplicitValue || input.value !== 'on') &&\n        input.value === el.value\n      ) {\n        return true;\n      }\n\n      // If value is \"on\" (default) or no match, try to match by label text\n      const label = document.querySelector(`label[for=\"${input.id}\"]`);\n      if (label && label.textContent && label.textContent.trim() === el.value) {\n        return true;\n      }\n\n      // Final fallback: match by id\n      if (input.id === el.value) {\n        return true;\n      }\n\n      return false;\n    });\n\n    if (selectedRadio && !selectedRadio.error) {\n      // Uncheck all radios in the same group first\n      const radioName = (selectedRadio.element as HTMLInputElement).name;\n      if (radioName) {\n        const otherRadios = document.querySelectorAll(\n          `input[type=\"radio\"][name=\"${radioName}\"]`\n        );\n        otherRadios.forEach(radio => {\n          (radio as HTMLInputElement).checked = false;\n        });\n      }\n\n      // Check the selected radio button\n      (selectedRadio.element as HTMLInputElement).checked = true;\n      (selectedRadio.element as HTMLInputElement).dispatchEvent(\n        new Event('change', { bubbles: true })\n      );\n\n      // Return the selected radio element for badge display\n      return selectedRadio;\n    } else if (el.error) {\n      // Return the original element if there's an error\n      return el;\n    }\n\n    return null;\n  }\n\n  private setElementValue(el: AutofillElement): void {\n    const element = el.element;\n\n    if (element instanceof HTMLInputElement) {\n      const elementType = element.type.toLowerCase();\n\n      switch (elementType) {\n        case 'checkbox':\n          this.setCheckboxValue(element, el.value);\n          break;\n        case 'radio':\n          this.setRadioValue(element, el.value);\n          break;\n        case 'number':\n        case 'range':\n        case 'date':\n        case 'time':\n        case 'datetime-local':\n        case 'month':\n        case 'color':\n          this.setGeneralValue(element, el.value);\n          break;\n        case 'week':\n          // Convert date value to week format\n          this.setGeneralValue(element, this.convertDateToWeek(el.value));\n          break;\n        default:\n          this.setGeneralValue(element, el.value);\n      }\n    } else if (element instanceof HTMLTextAreaElement) {\n      this.setGeneralValue(element, el.value);\n    } else if (element instanceof HTMLSelectElement) {\n      this.setSelectValue(element, el.value);\n    }\n  }\n\n  // ============================================================================\n  // ELEMENT TYPE SPECIFIC FUNCTIONS\n  // ============================================================================\n\n  private setGeneralValue(\n    element: HTMLInputElement | HTMLTextAreaElement,\n    value: string\n  ): void {\n    element.value = value;\n    element.dispatchEvent(new Event('input', { bubbles: true }));\n    element.dispatchEvent(new Event('change', { bubbles: true }));\n  }\n\n  private setCheckboxValue(\n    element: HTMLInputElement,\n    value: string | boolean\n  ): void {\n    const boolValue = value === 'true' || value === true;\n    element.checked = boolValue;\n    element.dispatchEvent(new Event('change', { bubbles: true }));\n  }\n\n  private setRadioValue(\n    element: HTMLInputElement,\n    value: string | boolean\n  ): void {\n    const boolValue = value === 'true' || value === true;\n\n    if (boolValue) {\n      // Uncheck other radios in the same group\n      const radioName = element.name;\n      if (radioName) {\n        const otherRadios = document.querySelectorAll(\n          `input[type=\"radio\"][name=\"${radioName}\"]`\n        );\n        otherRadios.forEach(radio => {\n          if (radio !== element) {\n            (radio as HTMLInputElement).checked = false;\n          }\n        });\n      }\n\n      element.checked = true;\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n    } else {\n      element.checked = false;\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n    }\n  }\n\n  private setSelectValue(element: HTMLSelectElement, value: string): void {\n    // Try to find an option with the exact value\n    const exactMatch = Array.from(element.options).find(\n      option => option.value === value\n    );\n    if (exactMatch) {\n      element.value = value;\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n      return;\n    }\n\n    // Try to find an option with matching text content\n    const textMatch = Array.from(element.options).find(option =>\n      option.textContent?.toLowerCase().includes(value.toLowerCase())\n    );\n    if (textMatch) {\n      element.value = textMatch.value;\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n      return;\n    }\n\n    // Fallback: select a random non-empty option\n    const nonEmptyOptions = Array.from(element.options).filter(\n      option => option.value && option.value.trim() !== ''\n    );\n    if (nonEmptyOptions.length > 0) {\n      const randomOption =\n        nonEmptyOptions[Math.floor(Math.random() * nonEmptyOptions.length)];\n      element.value = randomOption.value;\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n    }\n  }\n\n  private showBadge(el: AutofillElement): void {\n    // Remove any existing badge for this element\n    this.removeBadge(el.id);\n\n    // Create badge element with optimized styling\n    const badge = document.createElement('div');\n    badge.id = `gofakeit-badge-${el.id}`;\n    const isError = Boolean(el.error && el.error.trim() !== '');\n    badge.textContent = isError ? el.error : el.function;\n\n    // Batch all style changes to minimize reflows\n    const badgeStyles = {\n      position: 'fixed',\n      zIndex: '999999',\n      padding: `${GOFAKEIT_SPACING.quarter}px ${GOFAKEIT_SPACING.half}px`,\n      borderRadius: `${GOFAKEIT_BORDER.radius}px`,\n      fontSize: `${GOFAKEIT_FONT.size}px`,\n      fontWeight: 'bold',\n      fontFamily: GOFAKEIT_FONT.family,\n      boxShadow: '0 2px 4px rgba(0,0,0,0.2)',\n      pointerEvents: 'none',\n      userSelect: 'none',\n      transition: 'opacity 0.3s ease-in-out',\n      opacity: '0',\n      whiteSpace: 'nowrap',\n      backgroundColor: isError\n        ? GOFAKEIT_COLORS.error\n        : GOFAKEIT_COLORS.primary,\n      color: isError ? GOFAKEIT_COLORS.white : GOFAKEIT_COLORS.text,\n    };\n\n    // Apply all styles at once\n    Object.assign(badge.style, badgeStyles);\n\n    // Append badge to body\n    document.body.appendChild(badge);\n\n    // Performance optimizations\n    let lastRect: DOMRect | null = null;\n    let animationId: number | null = null;\n    let isVisible = true;\n    let lastVisibilityCheck = 0;\n    const VISIBILITY_CHECK_INTERVAL = 100; // Check visibility every 100ms instead of every frame\n\n    // Cache scrollable parents to avoid repeated DOM traversal\n    const scrollableParents = this.getScrollableParents(el.element);\n    const parentRects = new Map<Element, DOMRect>();\n\n    // Function to check if element is visible (optimized)\n    const checkElementVisibility = (element: Element): boolean => {\n      const rect = element.getBoundingClientRect();\n\n      // Quick window viewport check first\n      if (\n        rect.top < 0 ||\n        rect.left < 0 ||\n        rect.bottom > window.innerHeight ||\n        rect.right > window.innerWidth\n      ) {\n        return false;\n      }\n\n      // Check cached scrollable parents\n      for (const parent of scrollableParents) {\n        let parentRect = parentRects.get(parent);\n        if (!parentRect) {\n          parentRect = parent.getBoundingClientRect();\n          parentRects.set(parent, parentRect);\n        }\n\n        // Check if element is within parent bounds\n        if (\n          rect.top < parentRect.top ||\n          rect.left < parentRect.left ||\n          rect.bottom > parentRect.bottom ||\n          rect.right > parentRect.right\n        ) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    // Optimized position update function\n    const updateBadgePosition = () => {\n      const rect = el.element.getBoundingClientRect();\n\n      // Check if element has moved (position or size changed)\n      const hasMoved =\n        !lastRect ||\n        rect.top !== lastRect.top ||\n        rect.left !== lastRect.left ||\n        rect.width !== lastRect.width ||\n        rect.height !== lastRect.height;\n\n      if (hasMoved) {\n        lastRect = rect;\n\n        // Only check visibility periodically to reduce DOM queries\n        const now = performance.now();\n        if (now - lastVisibilityCheck > VISIBILITY_CHECK_INTERVAL) {\n          isVisible = checkElementVisibility(el.element);\n          lastVisibilityCheck = now;\n          // Clear parent rects cache periodically\n          parentRects.clear();\n        }\n\n        if (isVisible) {\n          // Position badge above the element\n          const top = rect.top - 30; // Offset based upon badge size\n          const left = rect.left;\n\n          // Batch style updates to minimize reflows\n          badge.style.cssText += `top:${top}px;left:${left}px;display:block;`;\n        } else {\n          // Hide badge if element is not visible\n          badge.style.display = 'none';\n        }\n      }\n\n      // Continue the animation loop\n      animationId = requestAnimationFrame(updateBadgePosition);\n    };\n\n    // Start the position tracking loop\n    updateBadgePosition();\n\n    // Store animation ID for cleanup\n    (badge as any)._animationId = animationId;\n\n    // Trigger fade-in animation\n    requestAnimationFrame(() => {\n      badge.style.opacity = '1';\n    });\n\n    // Auto-remove after duration with fade-out animation\n    setTimeout(() => {\n      this.removeBadge(el.id);\n    }, this.settings.badges);\n  }\n\n  // Helper method to cache scrollable parents\n  private getScrollableParents(element: Element): Element[] {\n    const scrollableParents: Element[] = [];\n    let parent = element.parentElement;\n\n    while (parent && parent !== document.body) {\n      const style = getComputedStyle(parent);\n      const overflow = style.overflow + style.overflowY + style.overflowX;\n\n      if (overflow.includes('scroll') || overflow.includes('auto')) {\n        scrollableParents.push(parent);\n      }\n\n      parent = parent.parentElement;\n    }\n\n    return scrollableParents;\n  }\n\n  private removeBadge(autofillElementId: string): void {\n    const existingBadge = document.getElementById(\n      `gofakeit-badge-${autofillElementId}`\n    );\n\n    // If badge doesn't exist, return\n    if (!existingBadge) {\n      return;\n    }\n\n    // Clean up animation frame immediately\n    const animationId = (existingBadge as any)._animationId;\n    if (animationId) {\n      cancelAnimationFrame(animationId);\n      (existingBadge as any)._animationId = null; // Clear reference\n    }\n\n    // Trigger fade-out animation\n    existingBadge.style.opacity = '0';\n\n    // Remove element after animation completes\n    setTimeout(() => {\n      // Double-check badge still exists before removing\n      if (existingBadge.parentNode) {\n        existingBadge.remove();\n      }\n    }, 300); // Match the transition duration\n  }\n\n  // ============================================================================\n  // PARAMETER GENERATION FUNCTIONS\n  // ============================================================================\n\n  private paramsSelect(\n    element: HTMLSelectElement\n  ): FetchFuncParams | undefined {\n    const options = Array.from(element.options)\n      .map(option => option.value)\n      .filter(value => value !== ''); // Filter out empty values\n\n    if (options.length > 0) {\n      return {\n        strs: options,\n      };\n    }\n    return undefined;\n  }\n\n  private paramsRadio(\n    radioGroup: AutofillElement[]\n  ): FetchFuncParams | undefined {\n    const values = radioGroup\n      .map(el => {\n        const input = el.element as HTMLInputElement;\n\n        // Check if the value attribute is explicitly set\n        const hasExplicitValue = input.hasAttribute('value');\n\n        // Use value attribute if it's explicitly set or if it's not the default \"on\"\n        if (\n          hasExplicitValue ||\n          (input.value && input.value.trim() !== '' && input.value !== 'on')\n        ) {\n          return input.value;\n        }\n\n        // Fallback to label text\n        const label = document.querySelector(`label[for=\"${input.id}\"]`);\n        if (label && label.textContent) {\n          return label.textContent.trim();\n        }\n\n        // Final fallback to id\n        return input.id;\n      })\n      .filter(value => value !== ''); // Filter out empty values\n\n    if (values.length > 0) {\n      return {\n        strs: values,\n      };\n    }\n    return undefined;\n  }\n\n  private convertDateToWeek(dateValue: string): string {\n    // Convert date string (yyyy-MM-dd) to week format (yyyy-Www)\n    try {\n      const date = new Date(dateValue + 'T00:00:00');\n      const year = date.getFullYear();\n\n      // Get the week number using ISO week calculation\n      const startOfYear = new Date(year, 0, 1);\n      const days = Math.floor(\n        (date.getTime() - startOfYear.getTime()) / (24 * 60 * 60 * 1000)\n      );\n      const weekNumber = Math.ceil((days + startOfYear.getDay() + 1) / 7);\n\n      // Format as yyyy-Www (with leading zero for week number)\n      return `${year}-W${weekNumber.toString().padStart(2, '0')}`;\n    } catch (error) {\n      // If conversion fails, return a default week value\n      const currentYear = new Date().getFullYear();\n      return `${currentYear}-W01`;\n    }\n  }\n\n  private convertWeekToDate(weekValue: string): string {\n    // Convert week format (yyyy-Www) to date format (yyyy-MM-dd)\n    try {\n      const match = weekValue.match(/^(\\d{4})-W(\\d{2})$/);\n      if (!match) {\n        throw new Error('Invalid week format');\n      }\n\n      const year = parseInt(match[1]);\n      const week = parseInt(match[2]);\n\n      // Calculate the date for the first day of the week\n      const jan1 = new Date(year, 0, 1);\n      const daysToAdd = (week - 1) * 7;\n      const targetDate = new Date(\n        jan1.getTime() + daysToAdd * 24 * 60 * 60 * 1000\n      );\n\n      // Format as yyyy-MM-dd\n      const month = (targetDate.getMonth() + 1).toString().padStart(2, '0');\n      const day = targetDate.getDate().toString().padStart(2, '0');\n      return `${year}-${month}-${day}`;\n    } catch (error) {\n      // If conversion fails, return a default date\n      const currentYear = new Date().getFullYear();\n      return `${currentYear}-01-01`;\n    }\n  }\n\n  private paramsDate(el: AutofillElement): FetchFuncParams | undefined {\n    const input = el.element as HTMLInputElement;\n    const min = input.getAttribute('min');\n    const max = input.getAttribute('max');\n\n    // Determine format based on input type\n    let format: string;\n    switch (el.type) {\n      case 'datetime-local':\n        format = 'yyyy-MM-ddTHH:mm';\n        break;\n      case 'month':\n        format = 'yyyy-MM';\n        break;\n      case 'date':\n      default:\n        format = 'yyyy-MM-dd';\n        break;\n    }\n\n    const params: any = {\n      format: format,\n    };\n\n    // If no min/max attributes, return just format\n    if (!min && !max) {\n      return params;\n    }\n\n    // Set startdate (min) or allow api to use default\n    if (min) {\n      params.startdate = min;\n    }\n\n    // Set enddate (max) or allow api to use default\n    if (max) {\n      params.enddate = max;\n    }\n\n    return params;\n  }\n\n  private paramsWeek(el: AutofillElement): FetchFuncParams {\n    const input = el.element as HTMLInputElement;\n    const min = input.getAttribute('min');\n    const max = input.getAttribute('max');\n\n    const params: any = {\n      format: 'yyyy-MM-dd', // Week inputs use date format for API calls\n    };\n\n    // Convert week format min/max attributes to date format for API\n    if (min) {\n      params.startdate = this.convertWeekToDate(min);\n    }\n\n    if (max) {\n      params.enddate = this.convertWeekToDate(max);\n    }\n\n    return params;\n  }\n\n  private paramsNumber(el: AutofillElement): FetchFuncParams {\n    const input = el.element as HTMLInputElement;\n    const min = input.getAttribute('min');\n    const max = input.getAttribute('max');\n\n    const params: any = {};\n\n    if (min) {\n      params.min = parseInt(min, 10);\n    }\n    if (max) {\n      params.max = parseInt(max, 10);\n    }\n    return params;\n  }\n\n  // ============================================================================\n  // MISC UTILITY FUNCTIONS\n  // ============================================================================\n\n  // Debug logging function controlled by settings.debug\n  private debug(type: 'warning' | 'error' | 'info', message: string): void {\n    if (this.settings.debug) {\n      const prefix = `[Gofakeit] ${type.toUpperCase()}:`;\n\n      switch (type) {\n        case 'error':\n          console.error(prefix, message);\n          break;\n        case 'warning':\n          console.warn(prefix, message);\n          break;\n        case 'info':\n        default:\n          console.log(prefix, message);\n          break;\n      }\n    }\n  }\n\n  // Reset state to initial values - useful for testing\n  public resetState(): void {\n    this.state = {\n      elements: [],\n    };\n  }\n\n  // Update status and trigger callback\n  private updateStatus(status: AutofillStatus): void {\n    this.state.status = status;\n    if (this.settings.onStatusChange) {\n      // Create a copy of elements to prevent reference issues\n      const elementsCopy = [...this.state.elements];\n      this.settings.onStatusChange(status, elementsCopy);\n    }\n  }\n\n  private results(): AutofillResults {\n    const successfulElements = this.state.elements.filter(\n      element => element.value && !element.error\n    );\n    const failedElements = this.state.elements.filter(element => element.error);\n\n    // Prepare results data for callback\n    const resultsData: AutofillResults = {\n      success: successfulElements.length,\n      failed: failedElements.length,\n      elements: this.state.elements,\n    };\n\n    this.debug('info', `\\nðŸŽ¯ Autofill Results Summary:`);\n    this.debug('info', `   Total elements: ${this.state.elements.length}`);\n    this.debug('info', `   Successful: ${successfulElements.length}`);\n    this.debug('info', `   Failed: ${failedElements.length}`);\n\n    // Show notification\n    if (successfulElements.length > 0 && failedElements.length === 0) {\n      this.debug(\n        'warning',\n        `Successfully generated data for ${successfulElements.length} fields!`\n      );\n    } else if (successfulElements.length > 0 && failedElements.length > 0) {\n      this.debug(\n        'warning',\n        `Generated data for ${successfulElements.length} fields, ${failedElements.length} failed`\n      );\n    } else if (failedElements.length > 0) {\n      this.debug(\n        'error',\n        `Failed to generate data for ${failedElements.length} fields`\n      );\n    } else {\n      this.debug('warning', 'No fields were processed');\n    }\n\n    return resultsData;\n  }\n}\n"],"names":["GOFAKEIT_API_BASE","fetchFunc","func","params","funcName","extractedParams","parseFunctionString","finalParams","makeRequest","fetchFuncMulti","requests","processedRequests","req","index","id","fetchFuncSearch","method","url","body","options","response","data","error","questionMarkIndex","functionName","queryString","searchParams","key","value","numValue","GOFAKEIT_COLORS","GOFAKEIT_SPACING","GOFAKEIT_BORDER","GOFAKEIT_FONT","AutofillStatus","Autofill","settings","target","allFormElements","elements","el","formEl","mode","filteredElements","element","gofakeitFunc","autofillElements","labelTexts","labelledBy","ref","labelEl","lbl","closestLabel","prev","labelText","type","name","elementId","placeholder","autocomplete","ariaLabel","part","elementsNeedingSearch","searchRequests","i","searchResult","elementType","min","max","elementsNeedingValues","processedNames","requestToElementMap","request","radioGroup","otherEl","result","processedRadioNames","elementToShowBadge","resolve","selectedRadio","radioEl","input","label","radioName","radio","boolValue","option","textMatch","nonEmptyOptions","randomOption","badge","isError","badgeStyles","lastRect","animationId","isVisible","lastVisibilityCheck","VISIBILITY_CHECK_INTERVAL","scrollableParents","parentRects","checkElementVisibility","rect","parent","parentRect","updateBadgePosition","now","top","left","style","overflow","autofillElementId","existingBadge","values","dateValue","date","year","startOfYear","days","weekNumber","weekValue","match","week","jan1","daysToAdd","targetDate","month","day","format","message","prefix","status","elementsCopy","successfulElements","failedElements","resultsData"],"mappings":"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"}