{"version":3,"file":"gofakeit.es.js","sources":["../src/api.ts","../src/styles.ts","../src/autofill.ts","../index.html?html-proxy&index=1.js"],"sourcesContent":["// Base URL for the Gofakeit API\nconst GOFAKEIT_API_BASE = 'https://api.gofakeit.com/funcs';\n\n// Interface for function parameters\nexport interface FetchFuncParams {\n  [key: string]: string | number | boolean | string[];\n}\n\nexport interface FetchFuncResponse {\n  result?: string;\n  error?: string;\n}\n\n// Multi-function request interface\nexport interface FetchFuncMultiRequest {\n  id?: string;\n  func: string;\n  params?: FetchFuncParams;\n}\n\n// Multi-function response item interface\nexport interface FetchFuncMultiResponseItem {\n  id?: string;\n  value: string | number | boolean | null;\n  error?: string;\n}\n\n// Multi-function response interface\nexport interface FetchFuncMultiResponse {\n  results?: FetchFuncMultiResponseItem[];\n  error?: string;\n}\n\n// Function search request interface\nexport interface FetchFuncSearchRequest {\n  id: string;\n  queries: string[];\n}\n\n// Function search result interface\nexport interface FetchFuncSearchResult {\n  name: string; // function name for API usage\n  score: number; // relevance score (0-100)\n  reasons: string[]; // why it matched\n}\n\n// Function search response item interface\nexport interface FetchFuncSearchResponseItem {\n  id: string;\n  results: FetchFuncSearchResult[];\n}\n\n// Multi-function search response interface\nexport interface FetchFuncSearchResponse {\n  results?: FetchFuncSearchResponseItem | FetchFuncSearchResponseItem[];\n  error?: string;\n}\n\n// Fetch data from gofakeit API\nexport async function fetchFunc(\n  func: string,\n  params?: FetchFuncParams\n): Promise<FetchFuncResponse> {\n  const { func: funcName, params: extractedParams } = parseFunctionString(func);\n\n  // Merge extracted params with provided params (provided params take precedence)\n  const finalParams = { ...extractedParams, ...(params || {}) };\n\n  try {\n    // Always use POST request\n    const result = await makeRequest<string>(\n      'POST',\n      `${GOFAKEIT_API_BASE}/${funcName}`,\n      finalParams\n    );\n    return {\n      result: result,\n    };\n  } catch (error) {\n    return {\n      error: error instanceof Error ? error.message : 'Unknown error',\n    };\n  }\n}\n\n// Call multiple functions in a single request\nexport async function fetchFuncMulti(\n  requests: FetchFuncMultiRequest[]\n): Promise<FetchFuncMultiResponse> {\n  if (requests.length === 0) {\n    return {\n      error: 'No functions provided',\n    };\n  }\n\n  try {\n    // Process each request to extract function name and parameters\n    const processedRequests: FetchFuncMultiRequest[] = requests.map(\n      (req, index) => {\n        const { func, id, params } = req;\n        const { func: funcName, params: extractedParams } =\n          parseFunctionString(func);\n\n        // Merge extracted params with provided params (provided params take precedence)\n        const finalParams = { ...extractedParams, ...(params || {}) };\n\n        return {\n          id: id || `req_${index}`,\n          func: funcName,\n          params: finalParams,\n        };\n      }\n    );\n\n    const response = await makeRequest<FetchFuncMultiResponseItem[]>(\n      'POST',\n      `${GOFAKEIT_API_BASE}/multi`,\n      processedRequests\n    );\n\n    return { results: response };\n  } catch (error) {\n    return {\n      error: error instanceof Error ? error.message : 'Unknown error',\n    };\n  }\n}\n\n// Search for multiple functions in a single request\nexport async function fetchFuncSearch(\n  requests: FetchFuncSearchRequest | FetchFuncSearchRequest[]\n): Promise<FetchFuncSearchResponse> {\n  // Handle single request by converting to array for API call\n  const requestArray = Array.isArray(requests) ? requests : [requests];\n  if (requestArray.length === 0) {\n    return {\n      error: 'No search requests provided',\n    };\n  }\n\n  try {\n    const response = await makeRequest<FetchFuncSearchResponseItem[]>(\n      'POST',\n      `${GOFAKEIT_API_BASE}/search`,\n      requestArray\n    );\n\n    // Maintain input/output structure consistency\n    // If input was a single object, ensure response results is a single object\n    // If input was an array, ensure response results is an array\n    if (!Array.isArray(requests)) {\n      // Input was single object - ensure response is single object\n      return { results: response[0] };\n    } else {\n      // Input was array - ensure response is array\n      return { results: response };\n    }\n  } catch (error) {\n    return {\n      error: error instanceof Error ? error.message : 'Unknown error',\n    };\n  }\n}\n\n// Base HTTP request function\n// Unified HTTP request function for all API calls\nasync function makeRequest<T>(\n  method: 'GET' | 'POST',\n  url: string,\n  body?: FetchFuncParams | FetchFuncMultiRequest[] | FetchFuncSearchRequest[]\n): Promise<T> {\n  try {\n    const options: {\n      method: string;\n      headers: Record<string, string>;\n      body?: string;\n    } = {\n      method: method,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    };\n\n    if (method === 'POST' && body) {\n      options.body = JSON.stringify(body);\n    }\n\n    const response = await fetch(url, options);\n\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    // Determine response parsing based on URL\n    if (url.includes('/multi') || url.includes('/search')) {\n      return await response.json();\n    } else {\n      return (await response.text()) as T;\n    }\n  } catch (error) {\n    throw new Error(error instanceof Error ? error.message : 'Unknown error');\n  }\n}\n\n// Parse function string to extract function name and parameters\nexport function parseFunctionString(func: string): {\n  func: string;\n  params: FetchFuncParams;\n} {\n  const questionMarkIndex = func.indexOf('?');\n\n  if (questionMarkIndex !== -1) {\n    // Function has query parameters - extract them\n    const functionName = func.substring(0, questionMarkIndex);\n    const queryString = func.substring(questionMarkIndex + 1);\n\n    // Parse query parameters into an object\n    const params: FetchFuncParams = {};\n    const searchParams = new URLSearchParams(queryString);\n\n    for (const [key, value] of searchParams.entries()) {\n      // Try to parse as number if possible\n      const numValue = parseFloat(value);\n      params[key] = isNaN(numValue) ? value : numValue;\n    }\n\n    return { func: functionName, params };\n  } else {\n    // Simple function with no parameters\n    return { func: func, params: {} };\n  }\n}\n","// Centralized style tokens for injected UI (avoid dependency on site CSS)\n\nexport const GOFAKEIT_COLORS = {\n  primary: '#ffa000',\n  white: '#ffffff',\n  success: '#48c774',\n  error: '#ff3860',\n  info: '#209cee',\n  text: '#333333',\n  border: '#686868',\n  background: '#22272e',\n};\n\nexport const GOFAKEIT_SPACING = {\n  base: 16, // px\n  half: 8, // px\n  quarter: 4, // px\n};\n\nexport const GOFAKEIT_BORDER = {\n  radius: 4, // px\n  width: 2, // px\n};\n\nexport const GOFAKEIT_FONT = {\n  size: 12, // px\n  family: 'Helvetica, Arial, sans-serif',\n};\n","import {\n  fetchFuncMulti,\n  FetchFuncMultiRequest,\n  fetchFuncSearch,\n  FetchFuncSearchRequest,\n  FetchFuncParams,\n} from './api';\nimport {\n  GOFAKEIT_COLORS,\n  GOFAKEIT_SPACING,\n  GOFAKEIT_BORDER,\n  GOFAKEIT_FONT,\n} from './styles';\n\nexport enum AutofillStatus {\n  STARTING = 'starting',\n  FOUND = 'found',\n  DETERMINED = 'determined',\n  GENERATED = 'generated',\n  SET = 'set',\n  COMPLETED = 'completed',\n  ERROR = 'error',\n}\n\nexport interface AutofillSettings {\n  mode?: 'auto' | 'manual';\n  stagger?: number;\n  badges?: number;\n  debug?: boolean;\n\n  // Callbacks\n  onStatusChange?: (\n    status: AutofillStatus,\n    elements: AutofillElement[]\n  ) => void;\n}\n\nexport interface AutofillState {\n  status?: AutofillStatus;\n  elements: AutofillElement[];\n}\n\nexport interface AutofillElement {\n  id: string; // id of the element\n  name: string; // name of the element\n  element: Element; // element to autofill\n  type: string; // element type\n  function: string; // function that will be used to autofill the element\n  params?: Record<string, any>; // parameters for the function\n  search: string[]; // search queries that will be used to autofill the element\n  value: string; // value of the autofill result\n  error: string; // error message\n}\n\nexport interface AutofillResult {\n  elements: AutofillElement[];\n  error?: string;\n}\n\nexport interface AutofillResults {\n  success: number;\n  failed: number;\n  elements: AutofillElement[];\n}\n\nexport class Autofill {\n  public settings: AutofillSettings;\n  public state: AutofillState;\n\n  constructor(settings: AutofillSettings = {}) {\n    this.settings = {\n      mode: 'auto',\n      stagger: 50,\n      badges: 3000,\n      debug: false,\n      ...settings,\n    };\n\n    this.state = {\n      elements: [],\n    };\n  }\n\n  public updateSettings(settings: AutofillSettings): void {\n    this.settings = { ...this.settings, ...settings };\n  }\n\n  // ============================================================================\n  // MAIN FILL FUNCTION\n  // ============================================================================\n\n  async fill(\n    target?: HTMLElement | Element | string,\n    functionName?: string,\n    params?: Record<string, any>\n  ): Promise<AutofillResults> {\n    this.state.elements = []; // Clear previous elements\n    this.updateStatus(AutofillStatus.STARTING);\n\n    // Step 1: Set all target elements based on the target parameter\n    this.setElements(target);\n    if (this.state.elements.length === 0) {\n      this.debug('info', 'No form fields found to fill');\n      this.updateStatus(AutofillStatus.COMPLETED);\n      return this.results();\n    }\n    this.updateStatus(AutofillStatus.FOUND);\n\n    // Step 2: Determine functions for elements that need search\n    await this.setElementFunctions(functionName, params);\n    this.updateStatus(AutofillStatus.DETERMINED);\n\n    // Step 3: Get values for all elements via multi-function API\n    await this.getElementValues();\n    this.updateStatus(AutofillStatus.GENERATED);\n\n    // Step 4: set values to the actual form elements\n    await this.setElementValues();\n    this.updateStatus(AutofillStatus.SET);\n\n    // Return the results\n    this.updateStatus(AutofillStatus.COMPLETED);\n    return this.results();\n  }\n\n  // ============================================================================\n  // Step 1: Set all target elements based on the target parameter\n  // ============================================================================\n\n  // Public method to set form elements based on target parameter\n  public setElements(target?: HTMLElement | Element | string): void {\n    const allFormElements: Element[] = [];\n\n    if (target) {\n      if (typeof target === 'string') {\n        // For string selectors, get the matching elements and search within them\n        const elements = document.querySelectorAll(target);\n        if (elements.length === 0) {\n          this.debug('error', `No element found with selector: \"${target}\"`);\n          this.updateStatus(AutofillStatus.ERROR);\n          this.state.elements = [];\n          return;\n        }\n        // Search within each matching element for form elements\n        elements.forEach(el => {\n          if (\n            el instanceof HTMLInputElement ||\n            el instanceof HTMLTextAreaElement ||\n            el instanceof HTMLSelectElement\n          ) {\n            // If the element itself is a form element, add it\n            if (this.shouldSkipElement(el)) return;\n            allFormElements.push(el);\n          } else {\n            // If it's not a form element, search within it for form elements\n            const selector = 'input, textarea, select';\n            const nodeList = el.querySelectorAll(selector);\n\n            nodeList.forEach(formEl => {\n              // Skip hidden, disabled, or readonly elements\n              if (this.shouldSkipElement(formEl)) return;\n              allFormElements.push(formEl);\n            });\n          }\n        });\n      } else if (target instanceof HTMLElement || target instanceof Element) {\n        // For element targets, check if the element itself is a form element\n        if (\n          target instanceof HTMLInputElement ||\n          target instanceof HTMLTextAreaElement ||\n          target instanceof HTMLSelectElement\n        ) {\n          // Skip hidden, disabled, or readonly elements\n          if (this.shouldSkipElement(target)) {\n            this.state.elements = [];\n            return;\n          }\n          allFormElements.push(target);\n        } else {\n          // If it's not a form element, search within it\n          const selector = 'input, textarea, select';\n          const nodeList = target.querySelectorAll(selector);\n\n          nodeList.forEach(el => {\n            // Skip hidden, disabled, or readonly elements\n            if (this.shouldSkipElement(el)) return;\n            allFormElements.push(el);\n          });\n        }\n      }\n    } else {\n      // No target specified, search the entire document\n      const selector = 'input, textarea, select';\n      const nodeList = document.querySelectorAll(selector);\n\n      nodeList.forEach(el => {\n        // Skip hidden, disabled, or readonly elements\n        if (this.shouldSkipElement(el)) return;\n        allFormElements.push(el);\n      });\n    }\n\n    // Step 3: Filter elements based on mode and data-gofakeit attributes\n    const mode = this.settings.mode ?? 'auto';\n    const filteredElements: Element[] = [];\n\n    for (const element of allFormElements) {\n      const gofakeitFunc = element.getAttribute('data-gofakeit');\n\n      // Skip if explicitly disabled\n      if (\n        typeof gofakeitFunc === 'string' &&\n        gofakeitFunc.trim().toLowerCase() === 'false'\n      ) {\n        continue;\n      }\n\n      // In manual mode, only include elements with data-gofakeit attribute\n      if (mode === 'manual' && !gofakeitFunc) {\n        continue;\n      }\n\n      // In auto mode, include all elements (with or without data-gofakeit)\n      filteredElements.push(element);\n    }\n\n    // Loop through filteredElements and create AutofillElement objects\n    const autofillElements: AutofillElement[] = [];\n    for (const element of filteredElements) {\n      // random 8 digit alphanumeric string\n      const id =\n        Math.random().toString(36).substring(2, 15) +\n        Math.random().toString(36).substring(2, 15);\n\n      // add new element to the autofillElements array\n      autofillElements.push({\n        id: id,\n        name: element.getAttribute('name') || '',\n        element,\n        type: this.getElementType(element),\n        function: '',\n        search: this.getElementSearch(element),\n        value: '',\n        error: '',\n      });\n    }\n\n    this.state.elements = autofillElements;\n\n    // Debug output for element selection\n    if (autofillElements.length > 0) {\n      this.debug(\n        'info',\n        `Found ${autofillElements.length} elements to generate data for`\n      );\n    }\n  }\n\n  // Check if an element should be skipped (hidden, disabled, or readonly)\n  public shouldSkipElement(element: Element): boolean {\n    if (element instanceof HTMLInputElement) {\n      return element.type === 'hidden' || element.disabled || element.readOnly;\n    } else if (element instanceof HTMLTextAreaElement) {\n      return element.disabled || element.readOnly;\n    } else if (element instanceof HTMLSelectElement) {\n      return element.disabled;\n    }\n    return false;\n  }\n\n  // Get the element type\n  private getElementType(element: Element): string {\n    if (element instanceof HTMLInputElement) {\n      return element.type.toLowerCase();\n    } else if (element instanceof HTMLTextAreaElement) {\n      return 'textarea';\n    } else if (element instanceof HTMLSelectElement) {\n      return 'select';\n    }\n    return 'unknown';\n  }\n\n  // Get search query parts for an element\n  public getElementSearch(el: Element): string[] {\n    const queries: string[] = [];\n\n    // Get label text from various sources (prioritized by relevance)\n    const labelTexts: string[] = [];\n    const id = el.id;\n\n    // aria-labelledby (highest priority - explicit accessibility)\n    const labelledBy = el.getAttribute('aria-labelledby');\n    if (labelledBy) {\n      labelledBy.split(/\\s+/).forEach(ref => {\n        const labelEl = document.getElementById(ref);\n        if (labelEl && labelEl.textContent)\n          labelTexts.push(labelEl.textContent);\n      });\n    }\n\n    // explicit label[for] (high priority - semantic association)\n    if (id) {\n      const lbl = document.querySelector(\n        'label[for=\"' + id.replace(/\"/g, '\\\\\"') + '\"]'\n      ) as HTMLLabelElement | null;\n      if (lbl && lbl.textContent) labelTexts.push(lbl.textContent);\n    }\n\n    // implicit parent label (medium priority)\n    const closestLabel = el.closest('label');\n    if (closestLabel && closestLabel.textContent)\n      labelTexts.push(closestLabel.textContent);\n\n    // previous sibling label (lower priority)\n    const prev = el.previousElementSibling as HTMLElement | null;\n    if (prev && prev.tagName === 'LABEL' && prev.textContent)\n      labelTexts.push(prev.textContent);\n\n    // Add each label text as a separate query\n    labelTexts.forEach(labelText => {\n      if (labelText && labelText.trim()) {\n        queries.push(labelText.trim().toLowerCase());\n      }\n    });\n\n    // Get additional element attributes and add each as separate queries\n    const type = el instanceof HTMLInputElement ? el.type.toLowerCase() : '';\n    if (type && type.trim()) {\n      queries.push(type);\n    }\n\n    const name = el.getAttribute('name') || '';\n    if (name && name.trim()) {\n      queries.push(name.toLowerCase());\n    }\n\n    const elementId = el.id || '';\n    if (elementId && elementId.trim()) {\n      queries.push(elementId.toLowerCase());\n    }\n\n    const placeholder =\n      el instanceof HTMLInputElement ? el.placeholder || '' : '';\n    if (placeholder && placeholder.trim()) {\n      queries.push(placeholder.toLowerCase());\n    }\n\n    const autocomplete =\n      el instanceof HTMLInputElement ? el.autocomplete || '' : '';\n    if (autocomplete && autocomplete.trim()) {\n      queries.push(autocomplete.toLowerCase());\n    }\n\n    const ariaLabel = el.getAttribute('aria-label') || '';\n    if (ariaLabel && ariaLabel.trim()) {\n      queries.push(ariaLabel.toLowerCase());\n    }\n\n    // Filter out empty queries and return\n    return queries.filter(query => query && query.trim());\n  }\n\n  // ============================================================================\n  // Step 2: Determine functions for elements that need search\n  // ============================================================================\n\n  public async setElementFunctions(\n    functionOverride?: string,\n    params?: Record<string, any>\n  ): Promise<void> {\n    this.debug(\n      'info',\n      `Determining functions for ${this.state.elements.length} elements`\n    );\n\n    // If function override is provided, apply it to all elements\n    if (functionOverride) {\n      this.debug('info', `Using function override: ${functionOverride}`);\n      for (const el of this.state.elements) {\n        el.function = functionOverride;\n        if (params) {\n          el.params = params;\n        }\n      }\n      return;\n    }\n\n    // Step 1: Loop through elements and set functions for types that don't need search\n    const elementsNeedingSearch: AutofillElement[] = [];\n\n    for (const el of this.state.elements) {\n      const functionName = this.getElementFunction(el.element);\n\n      if (functionName !== null) {\n        // Function determined - use it directly\n        el.function = functionName;\n      } else {\n        // Function needs search - add to search array\n        elementsNeedingSearch.push(el);\n      }\n    }\n\n    // Step 2: Handle elements that need search\n    if (elementsNeedingSearch.length > 0) {\n      this.debug(\n        'info',\n        `${elementsNeedingSearch.length} elements need function search`\n      );\n\n      // Create search requests using separate query parts\n      const searchRequests: FetchFuncSearchRequest[] =\n        elementsNeedingSearch.map((el, index) => {\n          return {\n            id:\n              el.element.id ||\n              el.element.getAttribute('name') ||\n              `input_${index}`,\n            queries: el.search,\n          };\n        });\n\n      const response = await fetchFuncSearch(searchRequests);\n\n      if (response.results && !response.error) {\n        // Handle both single object and array responses\n        const searchResults = Array.isArray(response.results)\n          ? response.results\n          : [response.results];\n\n        // Map results back to elements - use first result regardless of score\n        for (\n          let i = 0;\n          i < searchResults.length && i < elementsNeedingSearch.length;\n          i++\n        ) {\n          const searchResult = searchResults[i];\n          const el = elementsNeedingSearch[i];\n\n          if (searchResult.results && searchResult.results.length > 0) {\n            // Use the first result, not based on score\n            el.function = searchResult.results[0].name;\n          } else {\n            // Fallback to type-specific function if no search results\n            el.function = this.getElementFunctionFallback(el.element);\n          }\n        }\n\n        // If we have more elements than search results, use fallback for remaining elements\n        for (\n          let i = searchResults.length;\n          i < elementsNeedingSearch.length;\n          i++\n        ) {\n          elementsNeedingSearch[i].function = this.getElementFunctionFallback(\n            elementsNeedingSearch[i].element\n          );\n        }\n      } else {\n        // Fallback to type-specific functions if search fails\n        for (const el of elementsNeedingSearch) {\n          el.function = this.getElementFunctionFallback(el.element);\n        }\n      }\n    }\n\n    this.debug('info', 'Function determination complete');\n  }\n\n  public getElementFunction(element: Element): string | null {\n    const gofakeitFunc = element.getAttribute('data-gofakeit');\n    const elementType = this.getElementType(element);\n\n    if (gofakeitFunc && gofakeitFunc !== 'true') {\n      // Specific function provided - use it directly\n      return gofakeitFunc;\n    } else if (gofakeitFunc === 'true') {\n      // Function is 'true' - check if element type needs search\n      const needsSearch = this.elementTypeNeedsSearch(elementType);\n\n      if (needsSearch) {\n        // Element type needs search - return null\n        return null;\n      } else {\n        // Element type doesn't need search - use fallback function even with data-gofakeit=\"true\"\n        return this.getElementFunctionFallback(element);\n      }\n    } else {\n      // No function specified - check if element type needs search\n      const needsSearch = this.elementTypeNeedsSearch(elementType);\n\n      if (needsSearch) {\n        // Element type needs search - return null\n        return null;\n      } else {\n        // Element type doesn't need search - use fallback function\n        return this.getElementFunctionFallback(element);\n      }\n    }\n  }\n\n  private elementTypeNeedsSearch(elementType: string): boolean {\n    const skipSearchTypes = [\n      'checkbox',\n      'radio',\n      'select',\n      'range',\n      'file',\n      'button',\n      'submit',\n      'reset',\n      'image',\n      'week',\n      'date',\n      'time',\n      'datetime-local',\n      'month',\n      'color',\n    ];\n    return !skipSearchTypes.includes(elementType);\n  }\n\n  // If the element doesnt have a function and search doesnt return a function,\n  // we will use a fallback function\n  private getElementFunctionFallback(element: Element): string {\n    if (element instanceof HTMLInputElement) {\n      const elementType = element.type.toLowerCase();\n\n      switch (elementType) {\n        case 'date':\n        case 'datetime-local':\n        case 'month':\n        case 'week': {\n          // Check if input has min/max attributes to determine if it should use daterange\n          const min = element.getAttribute('min');\n          const max = element.getAttribute('max');\n          return min || max ? 'daterange' : 'date';\n        }\n        case 'time':\n          return 'time';\n        case 'text':\n          return 'word';\n        case 'email':\n          return 'email';\n        case 'tel':\n          return 'phone';\n        case 'url':\n          return 'url';\n        case 'password':\n          return 'password';\n        case 'search':\n          return 'word';\n        case 'number':\n        case 'range': {\n          // Check if input has min/max attributes to determine if it should use number with parameters\n          const min = element.getAttribute('min');\n          const max = element.getAttribute('max');\n          return min || max ? 'number' : 'number'; // Both use 'number' function, but with different parameters\n        }\n        case 'color':\n          return 'hexcolor';\n        case 'checkbox':\n          return 'bool';\n        case 'radio':\n          return 'randomstring';\n        default:\n          return 'word';\n      }\n    } else if (element instanceof HTMLTextAreaElement) {\n      return 'sentence';\n    } else if (element instanceof HTMLSelectElement) {\n      return 'randomstring';\n    }\n\n    return 'word';\n  }\n\n  // ============================================================================\n  // Step 3: Get values for all elements via multi-function API\n  // ============================================================================\n\n  // Get values for all elements via multi-function API\n  public async getElementValues(): Promise<void> {\n    this.debug('info', 'Starting value generation...');\n    const elementsNeedingValues = this.state.elements.filter(\n      el => el.function && !el.error\n    );\n\n    if (elementsNeedingValues.length === 0) {\n      this.debug('info', 'No elements need value generation');\n      return;\n    }\n\n    this.debug(\n      'info',\n      `Getting values for ${elementsNeedingValues.length} elements from API`\n    );\n\n    const requests: FetchFuncMultiRequest[] = [];\n    const processedNames: string[] = []; // Track processed radio group names\n    const requestToElementMap: AutofillElement[] = []; // Map requests to elements\n\n    // Process each element, adding parameters based on function type\n    for (const el of elementsNeedingValues) {\n      // Skip radio elements that are part of a group we've already processed\n      if (el.type === 'radio' && el.name && processedNames.includes(el.name)) {\n        continue;\n      }\n\n      const request: FetchFuncMultiRequest = {\n        id: el.id,\n        func: el.function,\n      };\n\n      // Use custom params if provided, otherwise use default parameter logic\n      if (el.params) {\n        request.params = el.params;\n      } else {\n        // Add parameters based on element type\n        switch (el.type) {\n          case 'select':\n            request.params = this.paramsSelect(el.element as HTMLSelectElement);\n            break;\n          case 'radio': {\n            // For radio groups, get all radio elements with the same name\n            const radioGroup = elementsNeedingValues.filter(\n              otherEl => otherEl.type === 'radio' && otherEl.name === el.name\n            );\n            request.params = this.paramsRadio(radioGroup);\n            // Mark this radio group as processed\n            if (el.name) {\n              processedNames.push(el.name);\n            }\n            break;\n          }\n          case 'date':\n          case 'datetime-local':\n          case 'month': {\n            const params = this.paramsDate(el);\n            if (params && (params.startdate || params.enddate)) {\n              request.func = 'daterange';\n              request.params = params;\n            } else {\n              request.params = params;\n            }\n            break;\n          }\n          case 'time': {\n            // For time inputs, use 'time' function with format\n            request.params = { format: 'HH:mm' };\n            break;\n          }\n          case 'week': {\n            const params = this.paramsWeek(el);\n            if (params && (params.startdate || params.enddate)) {\n              request.func = 'daterange';\n              request.params = params;\n            } else {\n              request.func = 'date';\n              request.params = params;\n            }\n            break;\n          }\n          case 'number':\n          case 'range': {\n            const params = this.paramsNumber(el);\n            request.params = params;\n            break;\n          }\n          // Add other element type cases here as needed\n          default:\n            // No special parameters needed\n            break;\n        }\n      }\n\n      requests.push(request);\n      requestToElementMap.push(el);\n    }\n\n    const response = await fetchFuncMulti(requests);\n\n    if (response.results && !response.error) {\n      // Map results back to elements using the correct mapping\n      for (let i = 0; i < response.results.length; i++) {\n        const result = response.results[i];\n        const el = requestToElementMap[i];\n\n        if (result.value !== null && result.value !== undefined) {\n          el.value = String(result.value);\n        } else if (result.error) {\n          el.error = result.error;\n        } else {\n          el.error = 'Unknown API error';\n        }\n      }\n    } else {\n      // Set error for all elements if the request failed\n      for (const el of elementsNeedingValues) {\n        el.error = response.error || 'API request failed';\n      }\n    }\n\n    this.debug('info', 'Value generation complete');\n  }\n\n  // ============================================================================\n  // Step 4: Set values to the actual form elements\n  // ============================================================================\n\n  // Set values to the actual form elements\n  public async setElementValues(): Promise<void> {\n    this.debug('info', 'Starting value application...');\n    if (this.state.elements.length === 0) {\n      this.debug('info', 'No elements to apply values to');\n      return;\n    }\n\n    this.debug('info', `Processing ${this.state.elements.length} elements`);\n\n    // Track processed radio group names to avoid duplicate badges\n    const processedRadioNames: string[] = [];\n\n    // Process all elements with optional staggering and show badges for each\n    for (let i = 0; i < this.state.elements.length; i++) {\n      const el = this.state.elements[i];\n      let elementToShowBadge: AutofillElement | null = null;\n\n      // Handle different element types\n      switch (el.type) {\n        case 'radio':\n          // Only process if we haven't already processed this radio group\n          if (el.name && !processedRadioNames.includes(el.name)) {\n            processedRadioNames.push(el.name);\n            elementToShowBadge = this.setRadioGroup(el);\n          }\n          break;\n        default:\n          // Only set value if el has a valid value and no error\n          if (el.value !== undefined && el.value !== null && !el.error) {\n            this.setElementValue(el);\n          }\n          elementToShowBadge = el;\n          break;\n      }\n\n      // Show badge for the appropriate element\n      if (\n        this.settings.badges &&\n        this.settings.badges > 0 &&\n        elementToShowBadge\n      ) {\n        this.showBadge(elementToShowBadge);\n      }\n\n      // Add delay between applications (except for the last one) if stagger is enabled\n      if (\n        this.settings.stagger &&\n        this.settings.stagger > 0 &&\n        i < this.state.elements.length - 1\n      ) {\n        await new Promise(resolve =>\n          setTimeout(resolve, this.settings.stagger)\n        );\n      }\n    }\n\n    this.debug('info', 'Value application complete');\n  }\n\n  private setRadioGroup(el: AutofillElement): AutofillElement | null {\n    // Find all radio elements in the same group\n    const radioGroup = this.state.elements.filter(\n      otherEl => otherEl.type === 'radio' && otherEl.name === el.name\n    );\n\n    // Find the radio element that matches the returned value\n    const selectedRadio = radioGroup.find(radioEl => {\n      const input = radioEl.element as HTMLInputElement;\n\n      // Check if the value attribute is explicitly set\n      const hasExplicitValue = input.hasAttribute('value');\n\n      // First try to match by value attribute if it's explicitly set or not the default \"on\"\n      if (\n        (hasExplicitValue || input.value !== 'on') &&\n        input.value === el.value\n      ) {\n        return true;\n      }\n\n      // If value is \"on\" (default) or no match, try to match by label text\n      const label = document.querySelector(`label[for=\"${input.id}\"]`);\n      if (label && label.textContent && label.textContent.trim() === el.value) {\n        return true;\n      }\n\n      // Final fallback: match by id\n      if (input.id === el.value) {\n        return true;\n      }\n\n      return false;\n    });\n\n    if (selectedRadio && !selectedRadio.error) {\n      // Uncheck all radios in the same group first\n      const radioName = (selectedRadio.element as HTMLInputElement).name;\n      if (radioName) {\n        const otherRadios = document.querySelectorAll(\n          `input[type=\"radio\"][name=\"${radioName}\"]`\n        );\n        otherRadios.forEach(radio => {\n          (radio as HTMLInputElement).checked = false;\n        });\n      }\n\n      // Check the selected radio button\n      (selectedRadio.element as HTMLInputElement).checked = true;\n      (selectedRadio.element as HTMLInputElement).dispatchEvent(\n        new Event('change', { bubbles: true })\n      );\n\n      // Return the selected radio element for badge display\n      return selectedRadio;\n    } else if (el.error) {\n      // Return the original element if there's an error\n      return el;\n    }\n\n    return null;\n  }\n\n  private setElementValue(el: AutofillElement): void {\n    const element = el.element;\n\n    if (element instanceof HTMLInputElement) {\n      const elementType = element.type.toLowerCase();\n\n      switch (elementType) {\n        case 'checkbox':\n          this.setCheckboxValue(element, el.value);\n          break;\n        case 'radio':\n          this.setRadioValue(element, el.value);\n          break;\n        case 'number':\n        case 'range':\n        case 'date':\n        case 'time':\n        case 'datetime-local':\n        case 'month':\n        case 'color':\n          this.setGeneralValue(element, el.value);\n          break;\n        case 'week':\n          // Convert date value to week format\n          this.setGeneralValue(element, this.convertDateToWeek(el.value));\n          break;\n        default:\n          this.setGeneralValue(element, el.value);\n      }\n    } else if (element instanceof HTMLTextAreaElement) {\n      this.setGeneralValue(element, el.value);\n    } else if (element instanceof HTMLSelectElement) {\n      this.setSelectValue(element, el.value);\n    }\n  }\n\n  // ============================================================================\n  // ELEMENT TYPE SPECIFIC FUNCTIONS\n  // ============================================================================\n\n  private setGeneralValue(\n    element: HTMLInputElement | HTMLTextAreaElement,\n    value: string\n  ): void {\n    element.value = value;\n    element.dispatchEvent(new Event('input', { bubbles: true }));\n    element.dispatchEvent(new Event('change', { bubbles: true }));\n  }\n\n  private setCheckboxValue(\n    element: HTMLInputElement,\n    value: string | boolean\n  ): void {\n    const boolValue = value === 'true' || value === true;\n    element.checked = boolValue;\n    element.dispatchEvent(new Event('change', { bubbles: true }));\n  }\n\n  private setRadioValue(\n    element: HTMLInputElement,\n    value: string | boolean\n  ): void {\n    const boolValue = value === 'true' || value === true;\n\n    if (boolValue) {\n      // Uncheck other radios in the same group\n      const radioName = element.name;\n      if (radioName) {\n        const otherRadios = document.querySelectorAll(\n          `input[type=\"radio\"][name=\"${radioName}\"]`\n        );\n        otherRadios.forEach(radio => {\n          if (radio !== element) {\n            (radio as HTMLInputElement).checked = false;\n          }\n        });\n      }\n\n      element.checked = true;\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n    } else {\n      element.checked = false;\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n    }\n  }\n\n  private setSelectValue(element: HTMLSelectElement, value: string): void {\n    // Try to find an option with the exact value\n    const exactMatch = Array.from(element.options).find(\n      option => option.value === value\n    );\n    if (exactMatch) {\n      element.value = value;\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n      return;\n    }\n\n    // Try to find an option with matching text content\n    const textMatch = Array.from(element.options).find(option =>\n      option.textContent?.toLowerCase().includes(value.toLowerCase())\n    );\n    if (textMatch) {\n      element.value = textMatch.value;\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n      return;\n    }\n\n    // Fallback: select a random non-empty option\n    const nonEmptyOptions = Array.from(element.options).filter(\n      option => option.value && option.value.trim() !== ''\n    );\n    if (nonEmptyOptions.length > 0) {\n      const randomOption =\n        nonEmptyOptions[Math.floor(Math.random() * nonEmptyOptions.length)];\n      element.value = randomOption.value;\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n    }\n  }\n\n  private showBadge(el: AutofillElement): void {\n    // Remove any existing badge for this element\n    this.removeBadge(el.id);\n\n    // Create badge element with optimized styling\n    const badge = document.createElement('div');\n    badge.id = `gofakeit-badge-${el.id}`;\n    const isError = Boolean(el.error && el.error.trim() !== '');\n    badge.textContent = isError ? el.error : el.function;\n\n    // Batch all style changes to minimize reflows\n    const badgeStyles = {\n      position: 'fixed',\n      zIndex: '999999',\n      padding: `${GOFAKEIT_SPACING.quarter}px ${GOFAKEIT_SPACING.half}px`,\n      borderRadius: `${GOFAKEIT_BORDER.radius}px`,\n      fontSize: `${GOFAKEIT_FONT.size}px`,\n      fontWeight: 'bold',\n      fontFamily: GOFAKEIT_FONT.family,\n      boxShadow: '0 2px 4px rgba(0,0,0,0.2)',\n      pointerEvents: 'none',\n      userSelect: 'none',\n      transition: 'opacity 0.3s ease-in-out',\n      opacity: '0',\n      whiteSpace: 'nowrap',\n      backgroundColor: isError\n        ? GOFAKEIT_COLORS.error\n        : GOFAKEIT_COLORS.primary,\n      color: isError ? GOFAKEIT_COLORS.white : GOFAKEIT_COLORS.text,\n    };\n\n    // Apply all styles at once\n    Object.assign(badge.style, badgeStyles);\n\n    // Append badge to body\n    document.body.appendChild(badge);\n\n    // Performance optimizations\n    let lastRect: DOMRect | null = null;\n    let animationId: number | null = null;\n    let isVisible = true;\n    let lastVisibilityCheck = 0;\n    const VISIBILITY_CHECK_INTERVAL = 100; // Check visibility every 100ms instead of every frame\n\n    // Cache scrollable parents to avoid repeated DOM traversal\n    const scrollableParents = this.getScrollableParents(el.element);\n    const parentRects = new Map<Element, DOMRect>();\n\n    // Function to check if element is visible (optimized)\n    const checkElementVisibility = (element: Element): boolean => {\n      const rect = element.getBoundingClientRect();\n\n      // Quick window viewport check first\n      if (\n        rect.top < 0 ||\n        rect.left < 0 ||\n        rect.bottom > window.innerHeight ||\n        rect.right > window.innerWidth\n      ) {\n        return false;\n      }\n\n      // Check cached scrollable parents\n      for (const parent of scrollableParents) {\n        let parentRect = parentRects.get(parent);\n        if (!parentRect) {\n          parentRect = parent.getBoundingClientRect();\n          parentRects.set(parent, parentRect);\n        }\n\n        // Check if element is within parent bounds\n        if (\n          rect.top < parentRect.top ||\n          rect.left < parentRect.left ||\n          rect.bottom > parentRect.bottom ||\n          rect.right > parentRect.right\n        ) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    // Optimized position update function\n    const updateBadgePosition = () => {\n      const rect = el.element.getBoundingClientRect();\n\n      // Check if element has moved (position or size changed)\n      const hasMoved =\n        !lastRect ||\n        rect.top !== lastRect.top ||\n        rect.left !== lastRect.left ||\n        rect.width !== lastRect.width ||\n        rect.height !== lastRect.height;\n\n      if (hasMoved) {\n        lastRect = rect;\n\n        // Only check visibility periodically to reduce DOM queries\n        const now = performance.now();\n        if (now - lastVisibilityCheck > VISIBILITY_CHECK_INTERVAL) {\n          isVisible = checkElementVisibility(el.element);\n          lastVisibilityCheck = now;\n          // Clear parent rects cache periodically\n          parentRects.clear();\n        }\n\n        if (isVisible) {\n          // Position badge above the element\n          const top = rect.top - 30; // Offset based upon badge size\n          const left = rect.left;\n\n          // Batch style updates to minimize reflows\n          badge.style.cssText += `top:${top}px;left:${left}px;display:block;`;\n        } else {\n          // Hide badge if element is not visible\n          badge.style.display = 'none';\n        }\n      }\n\n      // Continue the animation loop\n      animationId = requestAnimationFrame(updateBadgePosition);\n    };\n\n    // Start the position tracking loop\n    updateBadgePosition();\n\n    // Store animation ID for cleanup\n    (badge as any)._animationId = animationId;\n\n    // Trigger fade-in animation\n    requestAnimationFrame(() => {\n      badge.style.opacity = '1';\n    });\n\n    // Auto-remove after duration with fade-out animation\n    setTimeout(() => {\n      this.removeBadge(el.id);\n    }, this.settings.badges);\n  }\n\n  // Helper method to cache scrollable parents\n  private getScrollableParents(element: Element): Element[] {\n    const scrollableParents: Element[] = [];\n    let parent = element.parentElement;\n\n    while (parent && parent !== document.body) {\n      const style = getComputedStyle(parent);\n      const overflow = style.overflow + style.overflowY + style.overflowX;\n\n      if (overflow.includes('scroll') || overflow.includes('auto')) {\n        scrollableParents.push(parent);\n      }\n\n      parent = parent.parentElement;\n    }\n\n    return scrollableParents;\n  }\n\n  private removeBadge(autofillElementId: string): void {\n    const existingBadge = document.getElementById(\n      `gofakeit-badge-${autofillElementId}`\n    );\n\n    // If badge doesn't exist, return\n    if (!existingBadge) {\n      return;\n    }\n\n    // Clean up animation frame immediately\n    const animationId = (existingBadge as any)._animationId;\n    if (animationId) {\n      cancelAnimationFrame(animationId);\n      (existingBadge as any)._animationId = null; // Clear reference\n    }\n\n    // Trigger fade-out animation\n    existingBadge.style.opacity = '0';\n\n    // Remove element after animation completes\n    setTimeout(() => {\n      // Double-check badge still exists before removing\n      if (existingBadge.parentNode) {\n        existingBadge.remove();\n      }\n    }, 300); // Match the transition duration\n  }\n\n  // ============================================================================\n  // PARAMETER GENERATION FUNCTIONS\n  // ============================================================================\n\n  private paramsSelect(\n    element: HTMLSelectElement\n  ): FetchFuncParams | undefined {\n    const options = Array.from(element.options)\n      .map(option => option.value)\n      .filter(value => value !== ''); // Filter out empty values\n\n    if (options.length > 0) {\n      return {\n        strs: options,\n      };\n    }\n    return undefined;\n  }\n\n  private paramsRadio(\n    radioGroup: AutofillElement[]\n  ): FetchFuncParams | undefined {\n    const values = radioGroup\n      .map(el => {\n        const input = el.element as HTMLInputElement;\n\n        // Check if the value attribute is explicitly set\n        const hasExplicitValue = input.hasAttribute('value');\n\n        // Use value attribute if it's explicitly set or if it's not the default \"on\"\n        if (\n          hasExplicitValue ||\n          (input.value && input.value.trim() !== '' && input.value !== 'on')\n        ) {\n          return input.value;\n        }\n\n        // Fallback to label text\n        const label = document.querySelector(`label[for=\"${input.id}\"]`);\n        if (label && label.textContent) {\n          return label.textContent.trim();\n        }\n\n        // Final fallback to id\n        return input.id;\n      })\n      .filter(value => value !== ''); // Filter out empty values\n\n    if (values.length > 0) {\n      return {\n        strs: values,\n      };\n    }\n    return undefined;\n  }\n\n  private convertDateToWeek(dateValue: string): string {\n    // Convert date string (yyyy-MM-dd) to week format (yyyy-Www)\n    try {\n      const date = new Date(dateValue + 'T00:00:00');\n      const year = date.getFullYear();\n\n      // Get the week number using ISO week calculation\n      const startOfYear = new Date(year, 0, 1);\n      const days = Math.floor(\n        (date.getTime() - startOfYear.getTime()) / (24 * 60 * 60 * 1000)\n      );\n      const weekNumber = Math.ceil((days + startOfYear.getDay() + 1) / 7);\n\n      // Format as yyyy-Www (with leading zero for week number)\n      return `${year}-W${weekNumber.toString().padStart(2, '0')}`;\n    } catch (error) {\n      // If conversion fails, return a default week value\n      const currentYear = new Date().getFullYear();\n      return `${currentYear}-W01`;\n    }\n  }\n\n  private convertWeekToDate(weekValue: string): string {\n    // Convert week format (yyyy-Www) to date format (yyyy-MM-dd)\n    try {\n      const match = weekValue.match(/^(\\d{4})-W(\\d{2})$/);\n      if (!match) {\n        throw new Error('Invalid week format');\n      }\n\n      const year = parseInt(match[1]);\n      const week = parseInt(match[2]);\n\n      // Calculate the date for the first day of the week\n      const jan1 = new Date(year, 0, 1);\n      const daysToAdd = (week - 1) * 7;\n      const targetDate = new Date(\n        jan1.getTime() + daysToAdd * 24 * 60 * 60 * 1000\n      );\n\n      // Format as yyyy-MM-dd\n      const month = (targetDate.getMonth() + 1).toString().padStart(2, '0');\n      const day = targetDate.getDate().toString().padStart(2, '0');\n      return `${year}-${month}-${day}`;\n    } catch (error) {\n      // If conversion fails, return a default date\n      const currentYear = new Date().getFullYear();\n      return `${currentYear}-01-01`;\n    }\n  }\n\n  private paramsDate(el: AutofillElement): FetchFuncParams | undefined {\n    const input = el.element as HTMLInputElement;\n    const min = input.getAttribute('min');\n    const max = input.getAttribute('max');\n\n    // Determine format based on input type\n    let format: string;\n    switch (el.type) {\n      case 'datetime-local':\n        format = 'yyyy-MM-ddTHH:mm';\n        break;\n      case 'month':\n        format = 'yyyy-MM';\n        break;\n      case 'date':\n      default:\n        format = 'yyyy-MM-dd';\n        break;\n    }\n\n    const params: any = {\n      format: format,\n    };\n\n    // If no min/max attributes, return just format\n    if (!min && !max) {\n      return params;\n    }\n\n    // Set startdate (min) or allow api to use default\n    if (min) {\n      params.startdate = min;\n    }\n\n    // Set enddate (max) or allow api to use default\n    if (max) {\n      params.enddate = max;\n    }\n\n    return params;\n  }\n\n  private paramsWeek(el: AutofillElement): FetchFuncParams {\n    const input = el.element as HTMLInputElement;\n    const min = input.getAttribute('min');\n    const max = input.getAttribute('max');\n\n    const params: any = {\n      format: 'yyyy-MM-dd', // Week inputs use date format for API calls\n    };\n\n    // Convert week format min/max attributes to date format for API\n    if (min) {\n      params.startdate = this.convertWeekToDate(min);\n    }\n\n    if (max) {\n      params.enddate = this.convertWeekToDate(max);\n    }\n\n    return params;\n  }\n\n  private paramsNumber(el: AutofillElement): FetchFuncParams {\n    const input = el.element as HTMLInputElement;\n    const min = input.getAttribute('min');\n    const max = input.getAttribute('max');\n\n    const params: any = {};\n\n    if (min) {\n      params.min = parseInt(min, 10);\n    }\n    if (max) {\n      params.max = parseInt(max, 10);\n    }\n    return params;\n  }\n\n  // ============================================================================\n  // MISC UTILITY FUNCTIONS\n  // ============================================================================\n\n  // Debug logging function controlled by settings.debug\n  private debug(type: 'warning' | 'error' | 'info', message: string): void {\n    if (this.settings.debug) {\n      const prefix = `[Gofakeit] ${type.toUpperCase()}:`;\n\n      switch (type) {\n        case 'error':\n          console.error(prefix, message);\n          break;\n        case 'warning':\n          console.warn(prefix, message);\n          break;\n        case 'info':\n        default:\n          console.log(prefix, message);\n          break;\n      }\n    }\n  }\n\n  // Reset state to initial values - useful for testing\n  public resetState(): void {\n    this.state = {\n      elements: [],\n    };\n  }\n\n  // Update status and trigger callback\n  private updateStatus(status: AutofillStatus): void {\n    this.state.status = status;\n    if (this.settings.onStatusChange) {\n      // Create a copy of elements to prevent reference issues\n      const elementsCopy = [...this.state.elements];\n      this.settings.onStatusChange(status, elementsCopy);\n    }\n  }\n\n  private results(): AutofillResults {\n    const successfulElements = this.state.elements.filter(\n      element => element.value && !element.error\n    );\n    const failedElements = this.state.elements.filter(element => element.error);\n\n    // Prepare results data for callback\n    const resultsData: AutofillResults = {\n      success: successfulElements.length,\n      failed: failedElements.length,\n      elements: this.state.elements,\n    };\n\n    this.debug('info', `\\n Autofill Results Summary:`);\n    this.debug('info', `   Total elements: ${this.state.elements.length}`);\n    this.debug('info', `   Successful: ${successfulElements.length}`);\n    this.debug('info', `   Failed: ${failedElements.length}`);\n\n    // Show notification\n    if (successfulElements.length > 0 && failedElements.length === 0) {\n      this.debug(\n        'warning',\n        `Successfully generated data for ${successfulElements.length} fields!`\n      );\n    } else if (successfulElements.length > 0 && failedElements.length > 0) {\n      this.debug(\n        'warning',\n        `Generated data for ${successfulElements.length} fields, ${failedElements.length} failed`\n      );\n    } else if (failedElements.length > 0) {\n      this.debug(\n        'error',\n        `Failed to generate data for ${failedElements.length} fields`\n      );\n    } else {\n      this.debug('warning', 'No fields were processed');\n    }\n\n    return resultsData;\n  }\n}\n","\n      import { Autofill, AutofillStatus } from './src/index.ts';\n\n      // Mobile Sidebar Functionality\n      function initMobileSidebar() {\n        const sidebar = document.getElementById('sidebar');\n        const sidebarToggle = document.getElementById('sidebarToggle');\n        const sidebarOverlay = document.getElementById('sidebarOverlay');\n\n        function openSidebar() {\n          sidebar.classList.add('open');\n          sidebarOverlay.classList.add('active');\n          sidebarToggle.classList.add('active');\n          document.body.style.overflow = 'hidden';\n        }\n\n        function closeSidebar() {\n          sidebar.classList.remove('open');\n          sidebarOverlay.classList.remove('active');\n          sidebarToggle.classList.remove('active');\n          document.body.style.overflow = '';\n        }\n\n        // Toggle sidebar\n        if (sidebarToggle) {\n          sidebarToggle.addEventListener('click', () => {\n            if (sidebar.classList.contains('open')) {\n              closeSidebar();\n            } else {\n              openSidebar();\n            }\n          });\n        }\n\n        // Close sidebar when clicking overlay\n        if (sidebarOverlay) {\n          sidebarOverlay.addEventListener('click', closeSidebar);\n        }\n\n        // Close sidebar on escape key\n        document.addEventListener('keydown', e => {\n          if (e.key === 'Escape' && sidebar.classList.contains('open')) {\n            closeSidebar();\n          }\n        });\n\n        // Auto-open sidebar when autofill buttons are clicked on mobile\n        function handleAutofillClick() {\n          if (window.innerWidth <= 768) {\n            openSidebar();\n          }\n        }\n\n        // Add event listeners to autofill buttons\n        const autofillButtons = document.querySelectorAll(\n          'button[onclick*=\"autofill\"]'\n        );\n        autofillButtons.forEach(button => {\n          button.addEventListener('click', handleAutofillClick);\n        });\n      }\n\n      // Initialize mobile sidebar when DOM is loaded\n      document.addEventListener('DOMContentLoaded', initMobileSidebar);\n\n      // Helper function for mobile-aware scrolling\n      function scrollToElement(element, offset = 0) {\n        if (!element) {\n          return;\n        }\n\n        const isMobile = window.innerWidth <= 768;\n\n        if (isMobile) {\n          // Calculate dynamic header offset based on actual header height + spacing\n          const mobileHeader = document.querySelector('.mobile-header');\n          const headerHeight = mobileHeader ? mobileHeader.offsetHeight : 60; // fallback to 60px\n          const spacing = 16; // CSS var(--spacing-md) = 14px, using 16px for a bit more breathing room\n          const headerOffset = headerHeight + spacing;\n\n          // For mobile, temporarily add scroll-margin-top to create offset\n          const originalScrollMargin = element.style.scrollMarginTop;\n          element.style.scrollMarginTop = headerOffset + 'px';\n\n          element.scrollIntoView({\n            behavior: 'smooth',\n            block: 'start',\n          });\n\n          // Remove the scroll-margin-top after scrolling completes\n          setTimeout(() => {\n            element.style.scrollMarginTop = originalScrollMargin;\n          }, 500);\n        } else {\n          // For desktop, use normal scrollIntoView\n          element.scrollIntoView({\n            behavior: 'smooth',\n            block: 'start',\n          });\n        }\n      }\n\n      // Make functions available globally\n      window.autofill = async target => {\n        try {\n          // Get current settings\n          const settings = getCurrentSettings();\n\n          if (target) {\n            // If target is a string, treat it as a CSS selector (ID, class, or other)\n            if (typeof target === 'string') {\n              // Scroll to the section first\n              const element = document.querySelector(target);\n              if (element) {\n                scrollToElement(element);\n\n                // Wait a moment for the scroll to complete, then fill\n                setTimeout(async () => {\n                  const manager = new Autofill(settings);\n                  await manager.fill(target);\n                  showStatus(\n                    ` ${target} section filled successfully!`,\n                    'success'\n                  );\n                }, 500);\n              } else {\n                showStatus(' Element not found: ' + target, 'error');\n              }\n            } else {\n              const manager = new Autofill(settings);\n              await manager.fill(target);\n              showStatus(' Element filled successfully!', 'success');\n            }\n          } else {\n            // No target - fill all\n            const manager = new Autofill(settings);\n            await manager.fill(undefined);\n            showStatus(' All fields filled successfully!', 'success');\n          }\n        } catch (error) {\n          showStatus(' Error filling fields: ' + error.message, 'error');\n        }\n      };\n\n      // Function to handle category selection from dropdown\n      window.handleCategorySelection = async () => {\n        const selector = document.getElementById('categorySelector');\n        const selectedCategory = selector.value;\n\n        if (!selectedCategory) {\n          return;\n        }\n\n        try {\n          // Map category values to their heading text\n          const categoryHeadingMap = {\n            'person-category': ' Person Category',\n            'address-category': ' Address Category',\n            'company-category': ' Company Category',\n            'payment-category': ' Payment Category',\n            'internet-category': ' Internet Category',\n            'time-category': ' Time Category',\n            'language-category': ' Language Category',\n            'word-category': ' Word Category',\n            'color-category': ' Color Category',\n            'animal-category': ' Animal Category',\n            'food-category': ' Food Category',\n            'car-category': ' Car Category',\n            'product-category': ' Product Category',\n            'game-category': ' Game Category',\n            'misc-category': ' Misc Category',\n          };\n\n          // Find the specific category heading by text content\n          const headingText = categoryHeadingMap[selectedCategory];\n          let categoryHeading = null;\n          if (headingText) {\n            const allHeadings = document.querySelectorAll('h4');\n            for (const heading of allHeadings) {\n              if (heading.textContent?.includes(headingText)) {\n                categoryHeading = heading;\n                break;\n              }\n            }\n          }\n\n          if (categoryHeading) {\n            scrollToElement(categoryHeading);\n          } else {\n            // Fallback: scroll to the categories section\n            const section = document.getElementById('categories');\n            if (section) {\n              scrollToElement(section);\n            }\n          }\n\n          // Wait a moment for the scroll to complete, then autofill the specific fields\n          setTimeout(async () => {\n            // Find the category container\n            const categoryContainer = document.getElementById(selectedCategory);\n            if (!categoryContainer) {\n              showStatus(' Category container not found!', 'error');\n              return;\n            }\n\n            try {\n              // Get current settings\n              const settings = getCurrentSettings();\n\n              // Use the main fill function with the category container\n              const manager = new Autofill(settings);\n              await manager.fill(categoryContainer);\n\n              // Count filled elements\n              let filledCount = 0;\n              const inputs = categoryContainer.querySelectorAll(\n                'input, textarea, select'\n              );\n              inputs.forEach(element => {\n                if (element instanceof HTMLInputElement) {\n                  if (element.type === 'checkbox' || element.type === 'radio') {\n                    if (element.checked) filledCount++;\n                  } else if (element.value) {\n                    filledCount++;\n                  }\n                } else if (\n                  element instanceof HTMLTextAreaElement ||\n                  element instanceof HTMLSelectElement\n                ) {\n                  if (element.value) filledCount++;\n                }\n              });\n\n              const categoryName =\n                selector.options[selector.selectedIndex].text;\n              showStatus(\n                ` ${categoryName} filled successfully! (${filledCount} fields)`,\n                'success'\n              );\n            } catch (error) {\n              console.warn('Failed to fill category:', error);\n              showStatus(\n                ' Error filling category: ' + error.message,\n                'error'\n              );\n            }\n\n            // Reset the dropdown\n            selector.value = '';\n          }, 500);\n        } catch (error) {\n          showStatus(' Error filling category: ' + error.message, 'error');\n          // Reset the dropdown even on error\n          selector.value = '';\n        }\n      };\n\n      // Function to get current settings from the UI controls\n      function getCurrentSettings() {\n        const mode = document.querySelector('input[name=\"mode\"]:checked').value;\n        const stagger = parseInt(document.getElementById('stagger').value);\n        const badges = parseInt(document.getElementById('badges').value);\n        const debug = document.getElementById('debugMode').checked;\n\n        return {\n          mode: mode,\n          stagger: stagger,\n          badges: badges,\n          debug: debug,\n          onStatusChange: (status, elements) => {\n            if (debug) {\n              const timestamp = new Date().toLocaleTimeString();\n              const emoji = status === 'error' ? '' : '';\n              const style =\n                'color: #9c27b0; font-weight: bold; background: #f3e5f5; padding: 2px 4px; border-radius: 3px;';\n              console.log(\n                `%c[Status ${timestamp}] ${emoji} ${status.toUpperCase()}:`,\n                style,\n                elements\n              );\n            }\n\n            // Close sidebar on mobile when autofill starts\n            if (status === AutofillStatus.STARTING) {\n              const sidebar = document.getElementById('sidebar');\n              const sidebarOverlay = document.getElementById('sidebarOverlay');\n              const sidebarToggle = document.getElementById('sidebarToggle');\n\n              if (sidebar && sidebar.classList.contains('open')) {\n                sidebar.classList.remove('open');\n                if (sidebarOverlay) sidebarOverlay.classList.remove('active');\n                if (sidebarToggle) sidebarToggle.classList.remove('active');\n                document.body.style.overflow = '';\n              }\n            }\n\n            // Update status display in UI\n            const statusElement = document.getElementById('status');\n            if (statusElement) {\n              const statusText =\n                {\n                  starting: 'Starting...',\n                  found: 'Found...',\n                  determined: 'Determined...',\n                  generated: 'Generated...',\n                  set: 'Set...',\n                  completed: 'Completed!',\n                  error: 'Error occurred',\n                }[status] || status;\n\n              statusElement.textContent = statusText;\n              statusElement.className = `status ${status}`;\n            }\n\n            // Show progress for certain statuses\n            if (status === 'generated' || status === 'set') {\n              const processedCount = elements.filter(\n                element => element.value || element.error\n              ).length;\n              const totalCount = elements.length;\n              if (totalCount > 0) {\n                showStatus(\n                  `Processing ${processedCount}/${totalCount} fields...`,\n                  'info'\n                );\n              }\n            }\n          },\n        };\n      }\n\n      // Function to fill with current settings\n      window.autofillWithCurrentSettings = async () => {\n        try {\n          const settings = getCurrentSettings();\n          const manager = new Autofill(settings);\n          await manager.fill(undefined);\n\n          const modeText =\n            settings.mode === 'auto' ? 'Auto Mode' : 'Manual Mode';\n          const staggerText =\n            settings.stagger > 0\n              ? ` (${settings.stagger}ms stagger)`\n              : ' (no stagger)';\n          showStatus(\n            ` All fields filled with ${modeText}${staggerText}!`,\n            'success'\n          );\n        } catch (error) {\n          showStatus(' Error filling fields: ' + error.message, 'error');\n        }\n      };\n\n      // Update stagger delay value display and handle theme toggle\n      document.addEventListener('DOMContentLoaded', function () {\n        const stagger = document.getElementById('stagger');\n        const staggerValue = document.getElementById('staggerValue');\n        const badges = document.getElementById('badges');\n        const badgesValue = document.getElementById('badgesValue');\n        const themeToggle = document.getElementById('themeToggle');\n        const themeIcon = themeToggle.querySelector('.theme-icon');\n\n        if (stagger && staggerValue) {\n          stagger.addEventListener('input', function () {\n            staggerValue.textContent = this.value + 'ms';\n          });\n        }\n\n        if (badges && badgesValue) {\n          badges.addEventListener('input', function () {\n            badgesValue.textContent = this.value + 'ms';\n          });\n        }\n\n        // Handle theme toggle\n        if (themeToggle) {\n          // Get user's saved preference or system preference\n          const savedTheme = localStorage.getItem('theme');\n          const systemPrefersDark = window.matchMedia(\n            '(prefers-color-scheme: dark)'\n          ).matches;\n\n          // Use saved preference if available, otherwise use system preference\n          // Since dark is now default, we need to check if user wants light mode\n          const shouldUseLight =\n            savedTheme === 'light' ||\n            (savedTheme === null && !systemPrefersDark);\n\n          if (shouldUseLight) {\n            document.documentElement.setAttribute('data-theme', 'light');\n            themeIcon.textContent = '';\n          } else {\n            // Dark is default, no data-theme attribute needed\n            themeIcon.textContent = '';\n          }\n\n          themeToggle.addEventListener('click', function () {\n            const isLight =\n              document.documentElement.hasAttribute('data-theme') &&\n              document.documentElement.getAttribute('data-theme') === 'light';\n\n            if (isLight) {\n              // Switch to dark mode (default)\n              document.documentElement.removeAttribute('data-theme');\n              localStorage.setItem('theme', 'dark');\n              themeIcon.textContent = '';\n            } else {\n              // Switch to light mode\n              document.documentElement.setAttribute('data-theme', 'light');\n              localStorage.setItem('theme', 'light');\n              themeIcon.textContent = '';\n            }\n          });\n\n          // Listen for system preference changes\n          window\n            .matchMedia('(prefers-color-scheme: dark)')\n            .addEventListener('change', function (e) {\n              // Only update if user hasn't set a preference\n              if (localStorage.getItem('theme') === null) {\n                if (e.matches) {\n                  // System prefers dark, use default (dark)\n                  document.documentElement.removeAttribute('data-theme');\n                  themeIcon.textContent = '';\n                } else {\n                  // System prefers light, switch to light\n                  document.documentElement.setAttribute('data-theme', 'light');\n                  themeIcon.textContent = '';\n                }\n              }\n            });\n        }\n      });\n\n      window.clearAll = () => {\n        // only search in main content container, not sidebar\n        const mainContent = document.querySelector('.main-content');\n        if (!mainContent) return;\n\n        const inputs = mainContent.querySelectorAll('input, textarea, select');\n        inputs.forEach(input => {\n          if (input.type === 'checkbox' || input.type === 'radio') {\n            input.checked = false;\n          } else {\n            input.value = '';\n          }\n        });\n        showStatus(' All fields cleared!', 'success');\n      };\n\n      window.clearBadges = () => {\n        const badges = document.querySelectorAll(\n          '[data-gofakeit-badge=\"true\"]'\n        );\n        badges.forEach(badge => badge.remove());\n        showStatus(' All badges cleared!', 'success');\n      };\n\n      function showStatus(message, type) {\n        const status = document.getElementById('status');\n        status.textContent = message;\n        status.className = `status ${type}`;\n      }\n\n      // Initialize the page\n      console.log(' Gofakeit Fill Comprehensive Testing loaded!');\n      console.log(\n        'This page tests the search API with various input contexts and categories.'\n      );\n      console.log(\n        'Check the browser network tab to see search API calls in action!'\n      );\n      console.log(\n        'New features: Badge system, debug mode, and improved error handling!'\n      );\n    "],"names":["GOFAKEIT_API_BASE","fetchFuncMulti","requests","processedRequests","req","index","func","id","params","funcName","extractedParams","parseFunctionString","finalParams","makeRequest","error","fetchFuncSearch","requestArray","response","method","url","body","options","questionMarkIndex","functionName","queryString","searchParams","key","value","numValue","GOFAKEIT_COLORS","GOFAKEIT_SPACING","GOFAKEIT_BORDER","GOFAKEIT_FONT","AutofillStatus","Autofill","settings","target","allFormElements","elements","el","formEl","mode","filteredElements","element","gofakeitFunc","autofillElements","queries","labelTexts","labelledBy","ref","labelEl","lbl","closestLabel","prev","labelText","type","name","elementId","placeholder","autocomplete","ariaLabel","query","functionOverride","elementsNeedingSearch","searchRequests","searchResults","i","searchResult","elementType","min","max","elementsNeedingValues","processedNames","requestToElementMap","request","radioGroup","otherEl","result","processedRadioNames","elementToShowBadge","resolve","selectedRadio","radioEl","input","label","radioName","radio","boolValue","option","textMatch","nonEmptyOptions","randomOption","badge","isError","badgeStyles","lastRect","animationId","isVisible","lastVisibilityCheck","VISIBILITY_CHECK_INTERVAL","scrollableParents","parentRects","checkElementVisibility","rect","parent","parentRect","updateBadgePosition","now","top","left","style","overflow","autofillElementId","existingBadge","values","dateValue","date","year","startOfYear","days","weekNumber","weekValue","match","week","jan1","daysToAdd","targetDate","month","day","format","message","prefix","status","elementsCopy","successfulElements","failedElements","resultsData","initMobileSidebar","sidebar","sidebarToggle","sidebarOverlay","openSidebar","closeSidebar","e","handleAutofillClick","button","scrollToElement","offset","mobileHeader","headerOffset","originalScrollMargin","getCurrentSettings","showStatus","selector","selectedCategory","headingText","categoryHeading","allHeadings","heading","section","categoryContainer","filledCount","categoryName","stagger","badges","debug","timestamp","statusElement","statusText","processedCount","totalCount","modeText","staggerText","staggerValue","badgesValue","themeToggle","themeIcon","savedTheme","systemPrefersDark","mainContent"],"mappings":"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"}