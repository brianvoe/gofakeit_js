{"version":3,"file":"gofakeit.es.js","sources":["../src/api.ts","../src/styles.ts","../src/autofill.ts","../index.html?html-proxy&index=1.js"],"sourcesContent":["// Base URL for the Gofakeit API\nconst GOFAKEIT_API_BASE = 'https://api.gofakeit.com/funcs';\n\n// Interface for function parameters\nexport interface FetchFuncParams {\n  [key: string]: string | number | boolean | string[];\n}\n\nexport interface FetchFuncResponse {\n  success: boolean;\n  data?: string;\n  error?: string;\n  status?: number;\n}\n\n// Multi-function request interface\nexport interface FetchFuncMultiRequest {\n  id?: string;\n  func: string;\n  params?: FetchFuncParams;\n}\n\n// Multi-function response item interface\nexport interface FetchFuncMultiResponseItem {\n  id?: string;\n  value: string | number | boolean | null;\n  error?: string;\n}\n\n// Multi-function response interface\nexport interface FetchFuncMultiResponse {\n  success: boolean;\n  data?: FetchFuncMultiResponseItem[];\n  error?: string;\n  status?: number;\n}\n\n// Function search request interface\nexport interface FetchFuncSearchRequest {\n  id: string;\n  query: string;\n}\n\n// Function search result interface\nexport interface FetchFuncSearchResult {\n  name: string; // function name for API usage\n  score: number; // relevance score (0-100)\n  reasons: string[]; // why it matched\n}\n\n// Function search response item interface\nexport interface FetchFuncSearchResponseItem {\n  id: string;\n  query: string;\n  results: FetchFuncSearchResult[];\n}\n\n// Multi-function search response interface\nexport interface FetchFuncSearchResponse {\n  success: boolean;\n  data?: FetchFuncSearchResponseItem[];\n  error?: string;\n  status?: number;\n}\n\n// Fetch data from gofakeit API\nexport async function fetchFunc(\n  func: string,\n  params?: FetchFuncParams\n): Promise<FetchFuncResponse> {\n  const { func: funcName, params: extractedParams } = parseFunctionString(func);\n\n  // Merge extracted params with provided params (provided params take precedence)\n  const finalParams = { ...extractedParams, ...(params || {}) };\n\n  // Always use POST request\n  return makeRequest('POST', `${GOFAKEIT_API_BASE}/${funcName}`, finalParams);\n}\n\n// Call multiple functions in a single request\nexport async function fetchFuncMulti(\n  requests: FetchFuncMultiRequest[]\n): Promise<FetchFuncMultiResponse> {\n  if (requests.length === 0) {\n    return {\n      success: false,\n      error: 'No functions provided',\n    };\n  }\n\n  // Process each request to extract function name and parameters\n  const processedRequests: FetchFuncMultiRequest[] = requests.map(\n    (req, index) => {\n      const { func, id, params } = req;\n      const { func: funcName, params: extractedParams } =\n        parseFunctionString(func);\n\n      // Merge extracted params with provided params (provided params take precedence)\n      const finalParams = { ...extractedParams, ...(params || {}) };\n\n      return {\n        id: id || `req_${index}`,\n        func: funcName,\n        params: finalParams,\n      };\n    }\n  );\n\n  return makeRequest<FetchFuncMultiResponse>(\n    'POST',\n    `${GOFAKEIT_API_BASE}/multi`,\n    processedRequests\n  );\n}\n\n// Search for multiple functions in a single request\nexport async function fetchFuncSearch(\n  requests: FetchFuncSearchRequest[]\n): Promise<FetchFuncSearchResponse> {\n  if (requests.length === 0) {\n    return {\n      success: false,\n      error: 'No search queries provided',\n    };\n  }\n\n  return makeRequest<FetchFuncSearchResponse>(\n    'POST',\n    `${GOFAKEIT_API_BASE}/search`,\n    requests\n  );\n}\n\n// Base HTTP request function\n// Unified HTTP request function for all API calls\nasync function makeRequest<T>(\n  method: 'GET' | 'POST',\n  url: string,\n  body?: FetchFuncParams | FetchFuncMultiRequest[] | FetchFuncSearchRequest[]\n): Promise<T> {\n  try {\n    const options: {\n      method: string;\n      headers: Record<string, string>;\n      body?: string;\n    } = {\n      method: method,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    };\n\n    if (method === 'POST' && body) {\n      options.body = JSON.stringify(body);\n    }\n\n    const response = await fetch(url, options);\n\n    if (!response.ok) {\n      return {\n        success: false,\n        error: `HTTP error! status: ${response.status}`,\n        status: response.status,\n      } as T;\n    }\n\n    // Determine response parsing based on URL\n    let data;\n    if (url.includes('/multi') || url.includes('/search')) {\n      data = await response.json();\n    } else {\n      data = await response.text();\n    }\n\n    return {\n      success: true,\n      data: data,\n    } as T;\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    } as T;\n  }\n}\n\n// Parse function string to extract function name and parameters\nexport function parseFunctionString(func: string): {\n  func: string;\n  params: FetchFuncParams;\n} {\n  const questionMarkIndex = func.indexOf('?');\n\n  if (questionMarkIndex !== -1) {\n    // Function has query parameters - extract them\n    const functionName = func.substring(0, questionMarkIndex);\n    const queryString = func.substring(questionMarkIndex + 1);\n\n    // Parse query parameters into an object\n    const params: FetchFuncParams = {};\n    const searchParams = new URLSearchParams(queryString);\n\n    for (const [key, value] of searchParams.entries()) {\n      // Try to parse as number if possible\n      const numValue = parseFloat(value);\n      params[key] = isNaN(numValue) ? value : numValue;\n    }\n\n    return { func: functionName, params };\n  } else {\n    // Simple function with no parameters\n    return { func: func, params: {} };\n  }\n}\n","// Centralized style tokens for injected UI (avoid dependency on site CSS)\n\nexport const GOFAKEIT_COLORS = {\n  primary: '#ffa000',\n  white: '#ffffff',\n  success: '#48c774',\n  error: '#ff3860',\n  info: '#209cee',\n  text: '#333333',\n  border: '#686868',\n  background: '#22272e',\n};\n\nexport const GOFAKEIT_SPACING = {\n  base: 16, // px\n  half: 8, // px\n  quarter: 4, // px\n};\n\nexport const GOFAKEIT_BORDER = {\n  radius: 4, // px\n  width: 2, // px\n};\n\nexport const GOFAKEIT_FONT = {\n  size: 12, // px\n  family: 'Helvetica, Arial, sans-serif',\n};\n","import {\n  fetchFuncMulti,\n  FetchFuncMultiRequest,\n  fetchFuncSearch,\n  FetchFuncSearchRequest,\n  FetchFuncParams,\n} from './api';\nimport {\n  GOFAKEIT_COLORS,\n  GOFAKEIT_SPACING,\n  GOFAKEIT_BORDER,\n  GOFAKEIT_FONT,\n} from './styles';\n\nexport enum AutofillStatus {\n  IDLE = 'idle',\n  STARTING = 'starting',\n  INITIALIZING = 'initializing',\n  DETERMINING_FUNCTIONS = 'determining_functions',\n  GETTING_VALUES = 'getting_values',\n  SETTING_VALUES = 'setting_values',\n  COMPLETED = 'completed',\n  ERROR = 'error',\n}\n\nexport interface AutofillSettings {\n  mode?: 'auto' | 'manual';\n  stagger?: number;\n  badges?: number;\n  debug?: boolean;\n\n  // Callbacks\n  onStatusChange?: (status: AutofillStatus, state: AutofillState) => void;\n}\n\nexport interface AutofillState {\n  status: AutofillStatus;\n  elements: AutofillElement[];\n}\n\nexport interface AutofillElement {\n  id: string; // id of the element\n  name: string; // name of the element\n  element: Element; // element to autofill\n  type: string; // element type\n  function: string; // function that will be used to autofill the element\n  search: string; // search query that will be used to autofill the element\n  value: string; // value of the autofill result\n  error: string; // error message\n}\n\nexport interface AutofillResult {\n  elements: AutofillElement[];\n  error?: string;\n}\n\nexport interface Results {\n  success: number;\n  failed: number;\n  elements: AutofillElement[];\n}\n\nexport class Autofill {\n  public settings: AutofillSettings;\n  public state: AutofillState;\n\n  constructor(settings: AutofillSettings = {}) {\n    this.settings = {\n      mode: 'auto',\n      stagger: 50,\n      badges: 3000,\n      debug: false,\n      ...settings,\n    };\n\n    this.state = {\n      status: AutofillStatus.IDLE,\n      elements: [],\n    };\n  }\n\n  // ============================================================================\n  // MAIN FILL FUNCTION\n  // ============================================================================\n\n  async fill(target?: HTMLElement | Element | string): Promise<Results> {\n    this.updateStatus(AutofillStatus.STARTING);\n    this.state.elements = []; // Clear previous elements\n\n    // Step 1: Set all target elements based on the target parameter\n    this.setElements(target);\n\n    if (this.state.elements.length === 0) {\n      this.debug('info', 'No form fields found to fill');\n      // Only set to idle if we're not already in error state\n      if (this.state.status !== AutofillStatus.ERROR) {\n        this.updateStatus(AutofillStatus.IDLE);\n      }\n      return this.results();\n    }\n\n    // Step 2: Determine functions for elements that need search\n    await this.setElementFunctions();\n    this.updateStatus(AutofillStatus.DETERMINING_FUNCTIONS);\n\n    // Step 3: Get values for all elements via multi-function API\n    await this.getElementValues();\n    this.updateStatus(AutofillStatus.GETTING_VALUES);\n\n    // Step 4: set values to the actual form elements\n    await this.setElementValues();\n    this.updateStatus(AutofillStatus.SETTING_VALUES);\n\n    // Return the results\n    this.updateStatus(AutofillStatus.COMPLETED);\n    return this.results();\n  }\n\n  // ============================================================================\n  // Step 1: Set all target elements based on the target parameter\n  // ============================================================================\n\n  // Public method to set form elements based on target parameter\n  public setElements(target?: HTMLElement | Element | string): void {\n    const allFormElements: Element[] = [];\n\n    if (target) {\n      if (typeof target === 'string') {\n        // For string selectors, get the matching elements and search within them\n        const elements = document.querySelectorAll(target);\n        if (elements.length === 0) {\n          this.debug('error', `No element found with selector: \"${target}\"`);\n          this.updateStatus(AutofillStatus.ERROR);\n          this.state.elements = [];\n          return;\n        }\n        // Search within each matching element for form elements\n        elements.forEach(el => {\n          if (\n            el instanceof HTMLInputElement ||\n            el instanceof HTMLTextAreaElement ||\n            el instanceof HTMLSelectElement\n          ) {\n            // If the element itself is a form element, add it\n            if (this.shouldSkipElement(el)) return;\n            allFormElements.push(el);\n          } else {\n            // If it's not a form element, search within it for form elements\n            const selector = 'input, textarea, select';\n            const nodeList = el.querySelectorAll(selector);\n\n            nodeList.forEach(formEl => {\n              // Skip hidden, disabled, or readonly elements\n              if (this.shouldSkipElement(formEl)) return;\n              allFormElements.push(formEl);\n            });\n          }\n        });\n      } else if (target instanceof HTMLElement || target instanceof Element) {\n        // For element targets, check if the element itself is a form element\n        if (\n          target instanceof HTMLInputElement ||\n          target instanceof HTMLTextAreaElement ||\n          target instanceof HTMLSelectElement\n        ) {\n          // Skip hidden, disabled, or readonly elements\n          if (this.shouldSkipElement(target)) {\n            this.state.elements = [];\n            return;\n          }\n          allFormElements.push(target);\n        } else {\n          // If it's not a form element, search within it\n          const selector = 'input, textarea, select';\n          const nodeList = target.querySelectorAll(selector);\n\n          nodeList.forEach(el => {\n            // Skip hidden, disabled, or readonly elements\n            if (this.shouldSkipElement(el)) return;\n            allFormElements.push(el);\n          });\n        }\n      }\n    } else {\n      // No target specified, search the entire document\n      const selector = 'input, textarea, select';\n      const nodeList = document.querySelectorAll(selector);\n\n      nodeList.forEach(el => {\n        // Skip hidden, disabled, or readonly elements\n        if (this.shouldSkipElement(el)) return;\n        allFormElements.push(el);\n      });\n    }\n\n    // Step 3: Filter elements based on mode and data-gofakeit attributes\n    const mode = this.settings.mode ?? 'auto';\n    const filteredElements: Element[] = [];\n\n    for (const element of allFormElements) {\n      const gofakeitFunc = element.getAttribute('data-gofakeit');\n\n      // Skip if explicitly disabled\n      if (\n        typeof gofakeitFunc === 'string' &&\n        gofakeitFunc.trim().toLowerCase() === 'false'\n      ) {\n        continue;\n      }\n\n      // In manual mode, only include elements with data-gofakeit attribute\n      if (mode === 'manual' && !gofakeitFunc) {\n        continue;\n      }\n\n      // In auto mode, include all elements (with or without data-gofakeit)\n      filteredElements.push(element);\n    }\n\n    // Loop through filteredElements and create AutofillElement objects\n    const autofillElements: AutofillElement[] = [];\n    for (const element of filteredElements) {\n      // random 8 digit alphanumeric string\n      const id =\n        Math.random().toString(36).substring(2, 15) +\n        Math.random().toString(36).substring(2, 15);\n\n      // add new element to the autofillElements array\n      autofillElements.push({\n        id: id,\n        name: element.getAttribute('name') || '',\n        element,\n        type: this.getElementType(element),\n        function: '',\n        search: this.getElementSearch(element as HTMLInputElement),\n        value: '',\n        error: '',\n      });\n    }\n\n    this.state.elements = autofillElements;\n\n    // Debug output for element selection\n    if (autofillElements.length > 0) {\n      this.debug(\n        'info',\n        `Found ${autofillElements.length} elements to generate data for`\n      );\n    }\n  }\n\n  // Check if an element should be skipped (hidden, disabled, or readonly)\n  public shouldSkipElement(element: Element): boolean {\n    if (element instanceof HTMLInputElement) {\n      return element.type === 'hidden' || element.disabled || element.readOnly;\n    } else if (element instanceof HTMLTextAreaElement) {\n      return element.disabled || element.readOnly;\n    } else if (element instanceof HTMLSelectElement) {\n      return element.disabled;\n    }\n    return false;\n  }\n\n  // Get the element type\n  private getElementType(element: Element): string {\n    if (element instanceof HTMLInputElement) {\n      return element.type.toLowerCase();\n    } else if (element instanceof HTMLTextAreaElement) {\n      return 'textarea';\n    } else if (element instanceof HTMLSelectElement) {\n      return 'select';\n    }\n    return 'unknown';\n  }\n\n  // Get the comprehensive search string for an element\n  public getElementSearch(el: Element): string {\n    // Get label text from various sources\n    const labelTexts: string[] = [];\n    const id = el.id;\n\n    // aria-labelledby\n    const labelledBy = el.getAttribute('aria-labelledby');\n    if (labelledBy) {\n      labelledBy.split(/\\s+/).forEach(ref => {\n        const labelEl = document.getElementById(ref);\n        if (labelEl && labelEl.textContent)\n          labelTexts.push(labelEl.textContent);\n      });\n    }\n\n    // explicit label[for]\n    if (id) {\n      const lbl = document.querySelector(\n        'label[for=\"' + id.replace(/\"/g, '\\\\\"') + '\"]'\n      ) as HTMLLabelElement | null;\n      if (lbl && lbl.textContent) labelTexts.push(lbl.textContent);\n    }\n\n    // implicit parent label\n    const closestLabel = el.closest('label');\n    if (closestLabel && closestLabel.textContent)\n      labelTexts.push(closestLabel.textContent);\n\n    // previous sibling label (common in some UIs)\n    const prev = el.previousElementSibling as HTMLElement | null;\n    if (prev && prev.tagName === 'LABEL' && prev.textContent)\n      labelTexts.push(prev.textContent);\n\n    const labelText = labelTexts.join(' ').toLowerCase();\n\n    // Get additional element attributes for comprehensive search\n    const type = el instanceof HTMLInputElement ? el.type.toLowerCase() : '';\n    const name = (el.getAttribute('name') || '').toLowerCase();\n    const elementId = (el.id || '').toLowerCase();\n    const placeholder =\n      el instanceof HTMLInputElement\n        ? (el.placeholder || '').toLowerCase()\n        : '';\n    const autocomplete =\n      el instanceof HTMLInputElement\n        ? (el.autocomplete || '').toLowerCase()\n        : '';\n    const ariaLabel = (el.getAttribute('aria-label') || '').toLowerCase();\n\n    // Build a comprehensive search query with all available information\n    const queryParts = [\n      type,\n      name,\n      elementId,\n      placeholder,\n      autocomplete,\n      ariaLabel,\n      labelText,\n    ].filter(part => part && part.trim());\n\n    // Join all parts with spaces to create a comprehensive search query\n    const searchQuery = queryParts\n      .join(' ')\n      .toLowerCase()\n      .replace(/[^\\w\\s]/g, ' ') // Remove special characters\n      .replace(/\\s+/g, ' ') // Normalize whitespace\n      .trim();\n\n    return searchQuery;\n  }\n\n  // ============================================================================\n  // Step 2: Determine functions for elements that need search\n  // ============================================================================\n\n  public async setElementFunctions(): Promise<void> {\n    this.debug(\n      'info',\n      `Determining functions for ${this.state.elements.length} elements`\n    );\n\n    // Step 1: Loop through elements and set functions for types that don't need search\n    const elementsNeedingSearch: AutofillElement[] = [];\n\n    for (const el of this.state.elements) {\n      const functionName = this.getElementFunction(el.element);\n\n      if (functionName !== null) {\n        // Function determined - use it directly\n        el.function = functionName;\n      } else {\n        // Function needs search - add to search array\n        elementsNeedingSearch.push(el);\n      }\n    }\n\n    // Step 2: Handle elements that need search\n    if (elementsNeedingSearch.length > 0) {\n      this.debug(\n        'info',\n        `${elementsNeedingSearch.length} elements need function search`\n      );\n\n      // Create search requests using existing search values from state\n      const searchRequests: FetchFuncSearchRequest[] =\n        elementsNeedingSearch.map((el, index) => {\n          return {\n            id:\n              el.element.id ||\n              el.element.getAttribute('name') ||\n              `input_${index}`,\n            query: el.search,\n          };\n        });\n\n      const response = await fetchFuncSearch(searchRequests);\n\n      if (response.success && response.data) {\n        // Map results back to elements - use first result regardless of score\n        for (let i = 0; i < response.data.length; i++) {\n          const searchResult = response.data[i];\n          const el = elementsNeedingSearch[i];\n\n          if (searchResult.results && searchResult.results.length > 0) {\n            // Use the first result, not based on score\n            el.function = searchResult.results[0].name;\n          } else {\n            // Fallback to type-specific function if no search results\n            el.function = this.getElementFunctionFallback(el.element);\n          }\n        }\n      } else {\n        // Fallback to type-specific functions if search fails\n        for (const el of elementsNeedingSearch) {\n          el.function = this.getElementFunctionFallback(el.element);\n        }\n      }\n    }\n\n    this.debug('info', 'Function determination complete');\n  }\n\n  public getElementFunction(element: Element): string | null {\n    const gofakeitFunc = element.getAttribute('data-gofakeit');\n    const elementType = this.getElementType(element);\n\n    if (gofakeitFunc && gofakeitFunc !== 'true') {\n      // Specific function provided - use it directly\n      return gofakeitFunc;\n    } else if (gofakeitFunc === 'true') {\n      // Function is 'true' - check if element type needs search\n      const needsSearch = this.elementTypeNeedsSearch(elementType);\n\n      if (needsSearch) {\n        // Element type needs search - return null\n        return null;\n      } else {\n        // Element type doesn't need search - use fallback function even with data-gofakeit=\"true\"\n        return this.getElementFunctionFallback(element);\n      }\n    } else {\n      // No function specified - check if element type needs search\n      const needsSearch = this.elementTypeNeedsSearch(elementType);\n\n      if (needsSearch) {\n        // Element type needs search - return null\n        return null;\n      } else {\n        // Element type doesn't need search - use fallback function\n        return this.getElementFunctionFallback(element);\n      }\n    }\n  }\n\n  private elementTypeNeedsSearch(elementType: string): boolean {\n    const skipSearchTypes = [\n      'checkbox',\n      'radio',\n      'select',\n      'number',\n      'range',\n      'file',\n      'button',\n      'submit',\n      'reset',\n      'image',\n      'week',\n      'date',\n      'time',\n      'datetime-local',\n      'month',\n      'color',\n    ];\n    return !skipSearchTypes.includes(elementType);\n  }\n\n  // If the element doesnt have a function and search doesnt return a function,\n  // we will use a fallback function\n  private getElementFunctionFallback(element: Element): string {\n    if (element instanceof HTMLInputElement) {\n      const elementType = element.type.toLowerCase();\n\n      switch (elementType) {\n        case 'date':\n        case 'datetime-local':\n        case 'month':\n        case 'week': {\n          // Check if input has min/max attributes to determine if it should use daterange\n          const min = element.getAttribute('min');\n          const max = element.getAttribute('max');\n          return min || max ? 'daterange' : 'date';\n        }\n        case 'time':\n          return 'time';\n        case 'text':\n          return 'word';\n        case 'email':\n          return 'email';\n        case 'tel':\n          return 'phone';\n        case 'url':\n          return 'url';\n        case 'password':\n          return 'password';\n        case 'search':\n          return 'word';\n        case 'number':\n        case 'range': {\n          // Check if input has min/max attributes to determine if it should use number with parameters\n          const min = element.getAttribute('min');\n          const max = element.getAttribute('max');\n          return min || max ? 'number' : 'number'; // Both use 'number' function, but with different parameters\n        }\n        case 'color':\n          return 'hexcolor';\n        case 'checkbox':\n          return 'bool';\n        case 'radio':\n          return 'randomstring';\n        default:\n          return 'word';\n      }\n    } else if (element instanceof HTMLTextAreaElement) {\n      return 'sentence';\n    } else if (element instanceof HTMLSelectElement) {\n      return 'randomstring';\n    }\n\n    return 'word';\n  }\n\n  // ============================================================================\n  // Step 3: Get values for all elements via multi-function API\n  // ============================================================================\n\n  // Get values for all elements via multi-function API\n  public async getElementValues(): Promise<void> {\n    this.debug('info', 'Starting value generation...');\n    const elementsNeedingValues = this.state.elements.filter(\n      el => el.function && !el.error\n    );\n\n    if (elementsNeedingValues.length === 0) {\n      this.debug('info', 'No elements need value generation');\n      return;\n    }\n\n    this.debug(\n      'info',\n      `Getting values for ${elementsNeedingValues.length} elements from API`\n    );\n\n    const requests: FetchFuncMultiRequest[] = [];\n    const processedNames: string[] = []; // Track processed radio group names\n    const requestToElementMap: AutofillElement[] = []; // Map requests to elements\n\n    // Process each element, adding parameters based on function type\n    for (const el of elementsNeedingValues) {\n      // Skip radio elements that are part of a group we've already processed\n      if (el.type === 'radio' && el.name && processedNames.includes(el.name)) {\n        continue;\n      }\n\n      const request: FetchFuncMultiRequest = {\n        id: el.id,\n        func: el.function,\n      };\n\n      // Add parameters based on element type\n      switch (el.type) {\n        case 'select':\n          request.params = this.paramsSelect(el.element as HTMLSelectElement);\n          break;\n        case 'radio': {\n          // For radio groups, get all radio elements with the same name\n          const radioGroup = elementsNeedingValues.filter(\n            otherEl => otherEl.type === 'radio' && otherEl.name === el.name\n          );\n          request.params = this.paramsRadio(radioGroup);\n          // Mark this radio group as processed\n          if (el.name) {\n            processedNames.push(el.name);\n          }\n          break;\n        }\n        case 'date':\n        case 'datetime-local':\n        case 'month': {\n          const params = this.paramsDate(el);\n          if (params && (params.startdate || params.enddate)) {\n            request.func = 'daterange';\n            request.params = params;\n          } else {\n            request.params = params;\n          }\n          break;\n        }\n        case 'time': {\n          // For time inputs, use 'time' function with format\n          request.params = { format: 'HH:mm' };\n          break;\n        }\n        case 'week': {\n          const params = this.paramsWeek(el);\n          if (params && (params.startdate || params.enddate)) {\n            request.func = 'daterange';\n            request.params = params;\n          } else {\n            request.func = 'date';\n            request.params = params;\n          }\n          break;\n        }\n        case 'number':\n        case 'range': {\n          const params = this.paramsNumber(el);\n          request.params = params;\n          break;\n        }\n        // Add other element type cases here as needed\n        default:\n          // No special parameters needed\n          break;\n      }\n\n      requests.push(request);\n      requestToElementMap.push(el);\n    }\n\n    const response = await fetchFuncMulti(requests);\n\n    if (response.success && response.data) {\n      // Map results back to elements using the correct mapping\n      for (let i = 0; i < response.data.length; i++) {\n        const result = response.data[i];\n        const el = requestToElementMap[i];\n\n        if (result.value !== null && result.value !== undefined) {\n          el.value = String(result.value);\n        } else if (result.error) {\n          el.error = result.error;\n        } else {\n          el.error = 'Unknown API error';\n        }\n      }\n    } else {\n      // Set error for all elements if the request failed\n      for (const el of elementsNeedingValues) {\n        el.error = response.error || 'API request failed';\n      }\n    }\n\n    this.debug('info', 'Value generation complete');\n  }\n\n  // ============================================================================\n  // Step 4: Set values to the actual form elements\n  // ============================================================================\n\n  // Set values to the actual form elements\n  public async setElementValues(): Promise<void> {\n    this.debug('info', 'Starting value application...');\n    if (this.state.elements.length === 0) {\n      this.debug('info', 'No elements to apply values to');\n      return;\n    }\n\n    this.debug('info', `Processing ${this.state.elements.length} elements`);\n\n    // Track processed radio group names to avoid duplicate badges\n    const processedRadioNames: string[] = [];\n\n    // Process all elements with optional staggering and show badges for each\n    for (let i = 0; i < this.state.elements.length; i++) {\n      const el = this.state.elements[i];\n      let elementToShowBadge: AutofillElement | null = null;\n\n      // Handle different element types\n      switch (el.type) {\n        case 'radio':\n          // Only process if we haven't already processed this radio group\n          if (el.name && !processedRadioNames.includes(el.name)) {\n            processedRadioNames.push(el.name);\n            elementToShowBadge = this.setRadioGroup(el);\n          }\n          break;\n        default:\n          // Only set value if el has a valid value and no error\n          if (el.value !== undefined && el.value !== null && !el.error) {\n            this.setElementValue(el);\n          }\n          elementToShowBadge = el;\n          break;\n      }\n\n      // Show badge for the appropriate element\n      if (\n        this.settings.badges &&\n        this.settings.badges > 0 &&\n        elementToShowBadge\n      ) {\n        this.showBadge(elementToShowBadge);\n      }\n\n      // Add delay between applications (except for the last one) if stagger is enabled\n      if (\n        this.settings.stagger &&\n        this.settings.stagger > 0 &&\n        i < this.state.elements.length - 1\n      ) {\n        await new Promise(resolve =>\n          setTimeout(resolve, this.settings.stagger)\n        );\n      }\n    }\n\n    this.debug('info', 'Value application complete');\n  }\n\n  private setRadioGroup(el: AutofillElement): AutofillElement | null {\n    // Find all radio elements in the same group\n    const radioGroup = this.state.elements.filter(\n      otherEl => otherEl.type === 'radio' && otherEl.name === el.name\n    );\n\n    // Find the radio element that matches the returned value\n    const selectedRadio = radioGroup.find(radioEl => {\n      const input = radioEl.element as HTMLInputElement;\n\n      // Check if the value attribute is explicitly set\n      const hasExplicitValue = input.hasAttribute('value');\n\n      // First try to match by value attribute if it's explicitly set or not the default \"on\"\n      if (\n        (hasExplicitValue || input.value !== 'on') &&\n        input.value === el.value\n      ) {\n        return true;\n      }\n\n      // If value is \"on\" (default) or no match, try to match by label text\n      const label = document.querySelector(`label[for=\"${input.id}\"]`);\n      if (label && label.textContent && label.textContent.trim() === el.value) {\n        return true;\n      }\n\n      // Final fallback: match by id\n      if (input.id === el.value) {\n        return true;\n      }\n\n      return false;\n    });\n\n    if (selectedRadio && !selectedRadio.error) {\n      // Uncheck all radios in the same group first\n      const radioName = (selectedRadio.element as HTMLInputElement).name;\n      if (radioName) {\n        const otherRadios = document.querySelectorAll(\n          `input[type=\"radio\"][name=\"${radioName}\"]`\n        );\n        otherRadios.forEach(radio => {\n          (radio as HTMLInputElement).checked = false;\n        });\n      }\n\n      // Check the selected radio button\n      (selectedRadio.element as HTMLInputElement).checked = true;\n      (selectedRadio.element as HTMLInputElement).dispatchEvent(\n        new Event('change', { bubbles: true })\n      );\n\n      // Return the selected radio element for badge display\n      return selectedRadio;\n    } else if (el.error) {\n      // Return the original element if there's an error\n      return el;\n    }\n\n    return null;\n  }\n\n  private setElementValue(el: AutofillElement): void {\n    const element = el.element;\n\n    if (element instanceof HTMLInputElement) {\n      const elementType = element.type.toLowerCase();\n\n      switch (elementType) {\n        case 'checkbox':\n          this.setCheckboxValue(element, el.value);\n          break;\n        case 'radio':\n          this.setRadioValue(element, el.value);\n          break;\n        case 'number':\n        case 'range':\n        case 'date':\n        case 'time':\n        case 'datetime-local':\n        case 'month':\n        case 'color':\n          this.setGeneralValue(element, el.value);\n          break;\n        case 'week':\n          // Convert date value to week format\n          this.setGeneralValue(element, this.convertDateToWeek(el.value));\n          break;\n        default:\n          this.setGeneralValue(element, el.value);\n      }\n    } else if (element instanceof HTMLTextAreaElement) {\n      this.setGeneralValue(element, el.value);\n    } else if (element instanceof HTMLSelectElement) {\n      this.setSelectValue(element, el.value);\n    }\n  }\n\n  // ============================================================================\n  // ELEMENT TYPE SPECIFIC FUNCTIONS\n  // ============================================================================\n\n  private setGeneralValue(\n    element: HTMLInputElement | HTMLTextAreaElement,\n    value: string\n  ): void {\n    element.value = value;\n    element.dispatchEvent(new Event('input', { bubbles: true }));\n    element.dispatchEvent(new Event('change', { bubbles: true }));\n  }\n\n  private setCheckboxValue(\n    element: HTMLInputElement,\n    value: string | boolean\n  ): void {\n    const boolValue = value === 'true' || value === true;\n    element.checked = boolValue;\n    element.dispatchEvent(new Event('change', { bubbles: true }));\n  }\n\n  private setRadioValue(\n    element: HTMLInputElement,\n    value: string | boolean\n  ): void {\n    const boolValue = value === 'true' || value === true;\n\n    if (boolValue) {\n      // Uncheck other radios in the same group\n      const radioName = element.name;\n      if (radioName) {\n        const otherRadios = document.querySelectorAll(\n          `input[type=\"radio\"][name=\"${radioName}\"]`\n        );\n        otherRadios.forEach(radio => {\n          if (radio !== element) {\n            (radio as HTMLInputElement).checked = false;\n          }\n        });\n      }\n\n      element.checked = true;\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n    } else {\n      element.checked = false;\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n    }\n  }\n\n  private setSelectValue(element: HTMLSelectElement, value: string): void {\n    // Try to find an option with the exact value\n    const exactMatch = Array.from(element.options).find(\n      option => option.value === value\n    );\n    if (exactMatch) {\n      element.value = value;\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n      return;\n    }\n\n    // Try to find an option with matching text content\n    const textMatch = Array.from(element.options).find(option =>\n      option.textContent?.toLowerCase().includes(value.toLowerCase())\n    );\n    if (textMatch) {\n      element.value = textMatch.value;\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n      return;\n    }\n\n    // Fallback: select a random non-empty option\n    const nonEmptyOptions = Array.from(element.options).filter(\n      option => option.value && option.value.trim() !== ''\n    );\n    if (nonEmptyOptions.length > 0) {\n      const randomOption =\n        nonEmptyOptions[Math.floor(Math.random() * nonEmptyOptions.length)];\n      element.value = randomOption.value;\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n    }\n  }\n\n  private showBadge(el: AutofillElement): void {\n    // Remove any existing badge for this element\n    this.removeBadge(el.id);\n\n    // Create badge element with optimized styling\n    const badge = document.createElement('div');\n    badge.id = `gofakeit-badge-${el.id}`;\n    const isError = Boolean(el.error && el.error.trim() !== '');\n    badge.textContent = isError ? el.error : el.function;\n\n    // Batch all style changes to minimize reflows\n    const badgeStyles = {\n      position: 'fixed',\n      zIndex: '999999',\n      padding: `${GOFAKEIT_SPACING.quarter}px ${GOFAKEIT_SPACING.half}px`,\n      borderRadius: `${GOFAKEIT_BORDER.radius}px`,\n      fontSize: `${GOFAKEIT_FONT.size}px`,\n      fontWeight: 'bold',\n      fontFamily: GOFAKEIT_FONT.family,\n      boxShadow: '0 2px 4px rgba(0,0,0,0.2)',\n      pointerEvents: 'none',\n      userSelect: 'none',\n      transition: 'opacity 0.3s ease-in-out',\n      opacity: '0',\n      whiteSpace: 'nowrap',\n      backgroundColor: isError\n        ? GOFAKEIT_COLORS.error\n        : GOFAKEIT_COLORS.primary,\n      color: isError ? GOFAKEIT_COLORS.white : GOFAKEIT_COLORS.text,\n    };\n\n    // Apply all styles at once\n    Object.assign(badge.style, badgeStyles);\n\n    // Append badge to body\n    document.body.appendChild(badge);\n\n    // Performance optimizations\n    let lastRect: DOMRect | null = null;\n    let animationId: number | null = null;\n    let isVisible = true;\n    let lastVisibilityCheck = 0;\n    const VISIBILITY_CHECK_INTERVAL = 100; // Check visibility every 100ms instead of every frame\n\n    // Cache scrollable parents to avoid repeated DOM traversal\n    const scrollableParents = this.getScrollableParents(el.element);\n    const parentRects = new Map<Element, DOMRect>();\n\n    // Function to check if element is visible (optimized)\n    const checkElementVisibility = (element: Element): boolean => {\n      const rect = element.getBoundingClientRect();\n\n      // Quick window viewport check first\n      if (\n        rect.top < 0 ||\n        rect.left < 0 ||\n        rect.bottom > window.innerHeight ||\n        rect.right > window.innerWidth\n      ) {\n        return false;\n      }\n\n      // Check cached scrollable parents\n      for (const parent of scrollableParents) {\n        let parentRect = parentRects.get(parent);\n        if (!parentRect) {\n          parentRect = parent.getBoundingClientRect();\n          parentRects.set(parent, parentRect);\n        }\n\n        // Check if element is within parent bounds\n        if (\n          rect.top < parentRect.top ||\n          rect.left < parentRect.left ||\n          rect.bottom > parentRect.bottom ||\n          rect.right > parentRect.right\n        ) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    // Optimized position update function\n    const updateBadgePosition = () => {\n      const rect = el.element.getBoundingClientRect();\n\n      // Check if element has moved (position or size changed)\n      const hasMoved =\n        !lastRect ||\n        rect.top !== lastRect.top ||\n        rect.left !== lastRect.left ||\n        rect.width !== lastRect.width ||\n        rect.height !== lastRect.height;\n\n      if (hasMoved) {\n        lastRect = rect;\n\n        // Only check visibility periodically to reduce DOM queries\n        const now = performance.now();\n        if (now - lastVisibilityCheck > VISIBILITY_CHECK_INTERVAL) {\n          isVisible = checkElementVisibility(el.element);\n          lastVisibilityCheck = now;\n          // Clear parent rects cache periodically\n          parentRects.clear();\n        }\n\n        if (isVisible) {\n          // Position badge above the element\n          const top = rect.top - 30; // Offset based upon badge size\n          const left = rect.left;\n\n          // Batch style updates to minimize reflows\n          badge.style.cssText += `top:${top}px;left:${left}px;display:block;`;\n        } else {\n          // Hide badge if element is not visible\n          badge.style.display = 'none';\n        }\n      }\n\n      // Continue the animation loop\n      animationId = requestAnimationFrame(updateBadgePosition);\n    };\n\n    // Start the position tracking loop\n    updateBadgePosition();\n\n    // Store animation ID for cleanup\n    (badge as any)._animationId = animationId;\n\n    // Trigger fade-in animation\n    requestAnimationFrame(() => {\n      badge.style.opacity = '1';\n    });\n\n    // Auto-remove after duration with fade-out animation\n    setTimeout(() => {\n      this.removeBadge(el.id);\n    }, this.settings.badges);\n  }\n\n  // Helper method to cache scrollable parents\n  private getScrollableParents(element: Element): Element[] {\n    const scrollableParents: Element[] = [];\n    let parent = element.parentElement;\n\n    while (parent && parent !== document.body) {\n      const style = getComputedStyle(parent);\n      const overflow = style.overflow + style.overflowY + style.overflowX;\n\n      if (overflow.includes('scroll') || overflow.includes('auto')) {\n        scrollableParents.push(parent);\n      }\n\n      parent = parent.parentElement;\n    }\n\n    return scrollableParents;\n  }\n\n  private removeBadge(autofillElementId: string): void {\n    const existingBadge = document.getElementById(\n      `gofakeit-badge-${autofillElementId}`\n    );\n\n    // If badge doesn't exist, return\n    if (!existingBadge) {\n      return;\n    }\n\n    // Clean up animation frame immediately\n    const animationId = (existingBadge as any)._animationId;\n    if (animationId) {\n      cancelAnimationFrame(animationId);\n      (existingBadge as any)._animationId = null; // Clear reference\n    }\n\n    // Trigger fade-out animation\n    existingBadge.style.opacity = '0';\n\n    // Remove element after animation completes\n    setTimeout(() => {\n      // Double-check badge still exists before removing\n      if (existingBadge.parentNode) {\n        existingBadge.remove();\n      }\n    }, 300); // Match the transition duration\n  }\n\n  // ============================================================================\n  // PARAMETER GENERATION FUNCTIONS\n  // ============================================================================\n\n  private paramsSelect(\n    element: HTMLSelectElement\n  ): FetchFuncParams | undefined {\n    const options = Array.from(element.options)\n      .map(option => option.value)\n      .filter(value => value !== ''); // Filter out empty values\n\n    if (options.length > 0) {\n      return {\n        strs: options,\n      };\n    }\n    return undefined;\n  }\n\n  private paramsRadio(\n    radioGroup: AutofillElement[]\n  ): FetchFuncParams | undefined {\n    const values = radioGroup\n      .map(el => {\n        const input = el.element as HTMLInputElement;\n\n        // Check if the value attribute is explicitly set\n        const hasExplicitValue = input.hasAttribute('value');\n\n        // Use value attribute if it's explicitly set or if it's not the default \"on\"\n        if (\n          hasExplicitValue ||\n          (input.value && input.value.trim() !== '' && input.value !== 'on')\n        ) {\n          return input.value;\n        }\n\n        // Fallback to label text\n        const label = document.querySelector(`label[for=\"${input.id}\"]`);\n        if (label && label.textContent) {\n          return label.textContent.trim();\n        }\n\n        // Final fallback to id\n        return input.id;\n      })\n      .filter(value => value !== ''); // Filter out empty values\n\n    if (values.length > 0) {\n      return {\n        strs: values,\n      };\n    }\n    return undefined;\n  }\n\n  private convertDateToWeek(dateValue: string): string {\n    // Convert date string (yyyy-MM-dd) to week format (yyyy-Www)\n    try {\n      const date = new Date(dateValue + 'T00:00:00');\n      const year = date.getFullYear();\n\n      // Get the week number using ISO week calculation\n      const startOfYear = new Date(year, 0, 1);\n      const days = Math.floor(\n        (date.getTime() - startOfYear.getTime()) / (24 * 60 * 60 * 1000)\n      );\n      const weekNumber = Math.ceil((days + startOfYear.getDay() + 1) / 7);\n\n      // Format as yyyy-Www (with leading zero for week number)\n      return `${year}-W${weekNumber.toString().padStart(2, '0')}`;\n    } catch (error) {\n      // If conversion fails, return a default week value\n      const currentYear = new Date().getFullYear();\n      return `${currentYear}-W01`;\n    }\n  }\n\n  private convertWeekToDate(weekValue: string): string {\n    // Convert week format (yyyy-Www) to date format (yyyy-MM-dd)\n    try {\n      const match = weekValue.match(/^(\\d{4})-W(\\d{2})$/);\n      if (!match) {\n        throw new Error('Invalid week format');\n      }\n\n      const year = parseInt(match[1]);\n      const week = parseInt(match[2]);\n\n      // Calculate the date for the first day of the week\n      const jan1 = new Date(year, 0, 1);\n      const daysToAdd = (week - 1) * 7;\n      const targetDate = new Date(\n        jan1.getTime() + daysToAdd * 24 * 60 * 60 * 1000\n      );\n\n      // Format as yyyy-MM-dd\n      const month = (targetDate.getMonth() + 1).toString().padStart(2, '0');\n      const day = targetDate.getDate().toString().padStart(2, '0');\n      return `${year}-${month}-${day}`;\n    } catch (error) {\n      // If conversion fails, return a default date\n      const currentYear = new Date().getFullYear();\n      return `${currentYear}-01-01`;\n    }\n  }\n\n  private paramsDate(el: AutofillElement): FetchFuncParams | undefined {\n    const input = el.element as HTMLInputElement;\n    const min = input.getAttribute('min');\n    const max = input.getAttribute('max');\n\n    // Determine format based on input type\n    let format: string;\n    switch (el.type) {\n      case 'datetime-local':\n        format = 'yyyy-MM-ddTHH:mm';\n        break;\n      case 'month':\n        format = 'yyyy-MM';\n        break;\n      case 'date':\n      default:\n        format = 'yyyy-MM-dd';\n        break;\n    }\n\n    const params: any = {\n      format: format,\n    };\n\n    // If no min/max attributes, return just format\n    if (!min && !max) {\n      return params;\n    }\n\n    // Set startdate (min) or allow api to use default\n    if (min) {\n      params.startdate = min;\n    }\n\n    // Set enddate (max) or allow api to use default\n    if (max) {\n      params.enddate = max;\n    }\n\n    return params;\n  }\n\n  private paramsWeek(el: AutofillElement): FetchFuncParams {\n    const input = el.element as HTMLInputElement;\n    const min = input.getAttribute('min');\n    const max = input.getAttribute('max');\n\n    const params: any = {\n      format: 'yyyy-MM-dd', // Week inputs use date format for API calls\n    };\n\n    // Convert week format min/max attributes to date format for API\n    if (min) {\n      params.startdate = this.convertWeekToDate(min);\n    }\n\n    if (max) {\n      params.enddate = this.convertWeekToDate(max);\n    }\n\n    return params;\n  }\n\n  private paramsNumber(el: AutofillElement): FetchFuncParams {\n    const input = el.element as HTMLInputElement;\n    const min = input.getAttribute('min');\n    const max = input.getAttribute('max');\n\n    const params: any = {};\n\n    if (min) {\n      params.min = parseInt(min, 10);\n    }\n    if (max) {\n      params.max = parseInt(max, 10);\n    }\n    return params;\n  }\n\n  // ============================================================================\n  // MISC UTILITY FUNCTIONS\n  // ============================================================================\n\n  // Debug logging function controlled by settings.debug\n  private debug(type: 'warning' | 'error' | 'info', message: string): void {\n    if (this.settings.debug) {\n      const prefix = `[Gofakeit] ${type.toUpperCase()}:`;\n\n      switch (type) {\n        case 'error':\n          console.error(prefix, message);\n          break;\n        case 'warning':\n          console.warn(prefix, message);\n          break;\n        case 'info':\n        default:\n          console.log(prefix, message);\n          break;\n      }\n    }\n  }\n\n  // Reset state to initial values - useful for testing\n  public resetState(): void {\n    this.state = {\n      status: AutofillStatus.IDLE,\n      elements: [],\n    };\n  }\n\n  // Update status and trigger callback\n  private updateStatus(status: AutofillStatus): void {\n    this.state.status = status;\n    if (this.settings.onStatusChange) {\n      // Create a copy of state to prevent reference issues\n      const stateCopy = { ...this.state, elements: [...this.state.elements] };\n      this.settings.onStatusChange(status, stateCopy);\n    }\n  }\n\n  private results(): Results {\n    const successfulElements = this.state.elements.filter(\n      element => element.value && !element.error\n    );\n    const failedElements = this.state.elements.filter(element => element.error);\n\n    // Prepare results data for callback\n    const resultsData: Results = {\n      success: successfulElements.length,\n      failed: failedElements.length,\n      elements: this.state.elements,\n    };\n\n    this.debug('info', `\\n🎯 Autofill Results Summary:`);\n    this.debug('info', `   Total elements: ${this.state.elements.length}`);\n    this.debug('info', `   Successful: ${successfulElements.length}`);\n    this.debug('info', `   Failed: ${failedElements.length}`);\n\n    // Show notification\n    if (successfulElements.length > 0 && failedElements.length === 0) {\n      this.debug(\n        'warning',\n        `Successfully generated data for ${successfulElements.length} fields!`\n      );\n    } else if (successfulElements.length > 0 && failedElements.length > 0) {\n      this.debug(\n        'warning',\n        `Generated data for ${successfulElements.length} fields, ${failedElements.length} failed`\n      );\n    } else if (failedElements.length > 0) {\n      this.debug(\n        'error',\n        `Failed to generate data for ${failedElements.length} fields`\n      );\n    } else {\n      this.debug('warning', 'No fields were processed');\n    }\n\n    return resultsData;\n  }\n}\n","\n      import { Autofill, AutofillStatus } from './src/index.ts';\n\n      // Mobile Sidebar Functionality\n      function initMobileSidebar() {\n        const sidebar = document.getElementById('sidebar');\n        const sidebarToggle = document.getElementById('sidebarToggle');\n        const sidebarOverlay = document.getElementById('sidebarOverlay');\n\n        function openSidebar() {\n          sidebar.classList.add('open');\n          sidebarOverlay.classList.add('active');\n          sidebarToggle.classList.add('active');\n          document.body.style.overflow = 'hidden';\n        }\n\n        function closeSidebar() {\n          sidebar.classList.remove('open');\n          sidebarOverlay.classList.remove('active');\n          sidebarToggle.classList.remove('active');\n          document.body.style.overflow = '';\n        }\n\n        // Toggle sidebar\n        if (sidebarToggle) {\n          sidebarToggle.addEventListener('click', () => {\n            if (sidebar.classList.contains('open')) {\n              closeSidebar();\n            } else {\n              openSidebar();\n            }\n          });\n        }\n\n        // Close sidebar when clicking overlay\n        if (sidebarOverlay) {\n          sidebarOverlay.addEventListener('click', closeSidebar);\n        }\n\n        // Close sidebar on escape key\n        document.addEventListener('keydown', e => {\n          if (e.key === 'Escape' && sidebar.classList.contains('open')) {\n            closeSidebar();\n          }\n        });\n\n        // Auto-open sidebar when autofill buttons are clicked on mobile\n        function handleAutofillClick() {\n          if (window.innerWidth <= 768) {\n            openSidebar();\n          }\n        }\n\n        // Add event listeners to autofill buttons\n        const autofillButtons = document.querySelectorAll(\n          'button[onclick*=\"autofill\"]'\n        );\n        autofillButtons.forEach(button => {\n          button.addEventListener('click', handleAutofillClick);\n        });\n      }\n\n      // Initialize mobile sidebar when DOM is loaded\n      document.addEventListener('DOMContentLoaded', initMobileSidebar);\n\n      // Helper function for mobile-aware scrolling\n      function scrollToElement(element, offset = 0) {\n        if (!element) {\n          return;\n        }\n\n        const isMobile = window.innerWidth <= 768;\n\n        if (isMobile) {\n          // Calculate dynamic header offset based on actual header height + spacing\n          const mobileHeader = document.querySelector('.mobile-header');\n          const headerHeight = mobileHeader ? mobileHeader.offsetHeight : 60; // fallback to 60px\n          const spacing = 16; // CSS var(--spacing-md) = 14px, using 16px for a bit more breathing room\n          const headerOffset = headerHeight + spacing;\n\n          // For mobile, temporarily add scroll-margin-top to create offset\n          const originalScrollMargin = element.style.scrollMarginTop;\n          element.style.scrollMarginTop = headerOffset + 'px';\n\n          element.scrollIntoView({\n            behavior: 'smooth',\n            block: 'start',\n          });\n\n          // Remove the scroll-margin-top after scrolling completes\n          setTimeout(() => {\n            element.style.scrollMarginTop = originalScrollMargin;\n          }, 500);\n        } else {\n          // For desktop, use normal scrollIntoView\n          element.scrollIntoView({\n            behavior: 'smooth',\n            block: 'start',\n          });\n        }\n      }\n\n      // Make functions available globally\n      window.autofill = async target => {\n        try {\n          // Get current settings\n          const settings = getCurrentSettings();\n\n          if (target) {\n            // If target is a string, treat it as a CSS selector (ID, class, or other)\n            if (typeof target === 'string') {\n              // Scroll to the section first\n              const element = document.querySelector(target);\n              if (element) {\n                scrollToElement(element);\n\n                // Wait a moment for the scroll to complete, then fill\n                setTimeout(async () => {\n                  const manager = new Autofill(settings);\n                  await manager.fill(target);\n                  showStatus(\n                    `✅ ${target} section filled successfully!`,\n                    'success'\n                  );\n                }, 500);\n              } else {\n                showStatus('❌ Element not found: ' + target, 'error');\n              }\n            } else {\n              const manager = new Autofill(settings);\n              await manager.fill(target);\n              showStatus('✅ Element filled successfully!', 'success');\n            }\n          } else {\n            // No target - fill all\n            const manager = new Autofill(settings);\n            await manager.fill(undefined);\n            showStatus('✅ All fields filled successfully!', 'success');\n          }\n        } catch (error) {\n          showStatus('❌ Error filling fields: ' + error.message, 'error');\n        }\n      };\n\n      // Function to handle category selection from dropdown\n      window.handleCategorySelection = async () => {\n        const selector = document.getElementById('categorySelector');\n        const selectedCategory = selector.value;\n\n        if (!selectedCategory) {\n          return;\n        }\n\n        try {\n          // Map category values to their heading text\n          const categoryHeadingMap = {\n            'person-category': '👤 Person Category',\n            'address-category': '🏠 Address Category',\n            'company-category': '🏢 Company Category',\n            'payment-category': '💳 Payment Category',\n            'internet-category': '🌐 Internet Category',\n            'time-category': '⏰ Time Category',\n            'language-category': '🗣️ Language Category',\n            'word-category': '📝 Word Category',\n            'color-category': '🎨 Color Category',\n            'animal-category': '🐾 Animal Category',\n            'food-category': '🍕 Food Category',\n            'car-category': '🚗 Car Category',\n            'game-category': '🎮 Game Category',\n            'misc-category': '🎲 Misc Category',\n          };\n\n          // Find the specific category heading by text content\n          const headingText = categoryHeadingMap[selectedCategory];\n          let categoryHeading = null;\n          if (headingText) {\n            const allHeadings = document.querySelectorAll('h4');\n            for (const heading of allHeadings) {\n              if (heading.textContent?.includes(headingText)) {\n                categoryHeading = heading;\n                break;\n              }\n            }\n          }\n\n          if (categoryHeading) {\n            scrollToElement(categoryHeading);\n          } else {\n            // Fallback: scroll to the categories section\n            const section = document.getElementById('categories');\n            if (section) {\n              scrollToElement(section);\n            }\n          }\n\n          // Wait a moment for the scroll to complete, then autofill the specific fields\n          setTimeout(async () => {\n            // Find the category container\n            const categoryContainer = document.getElementById(selectedCategory);\n            if (!categoryContainer) {\n              showStatus('❌ Category container not found!', 'error');\n              return;\n            }\n\n            try {\n              // Get current settings\n              const settings = getCurrentSettings();\n\n              // Use the main fill function with the category container\n              const manager = new Autofill(settings);\n              await manager.fill(categoryContainer);\n\n              // Count filled elements\n              let filledCount = 0;\n              const inputs = categoryContainer.querySelectorAll(\n                'input, textarea, select'\n              );\n              inputs.forEach(element => {\n                if (element instanceof HTMLInputElement) {\n                  if (element.type === 'checkbox' || element.type === 'radio') {\n                    if (element.checked) filledCount++;\n                  } else if (element.value) {\n                    filledCount++;\n                  }\n                } else if (\n                  element instanceof HTMLTextAreaElement ||\n                  element instanceof HTMLSelectElement\n                ) {\n                  if (element.value) filledCount++;\n                }\n              });\n\n              const categoryName =\n                selector.options[selector.selectedIndex].text;\n              showStatus(\n                `✅ ${categoryName} filled successfully! (${filledCount} fields)`,\n                'success'\n              );\n            } catch (error) {\n              console.warn('Failed to fill category:', error);\n              showStatus(\n                '❌ Error filling category: ' + error.message,\n                'error'\n              );\n            }\n\n            // Reset the dropdown\n            selector.value = '';\n          }, 500);\n        } catch (error) {\n          showStatus('❌ Error filling category: ' + error.message, 'error');\n          // Reset the dropdown even on error\n          selector.value = '';\n        }\n      };\n\n      // Function to get current settings from the UI controls\n      function getCurrentSettings() {\n        const mode = document.querySelector('input[name=\"mode\"]:checked').value;\n        const stagger = parseInt(document.getElementById('stagger').value);\n        const badges = parseInt(document.getElementById('badges').value);\n        const debug = document.getElementById('debugMode').checked;\n\n        return {\n          mode: mode,\n          stagger: stagger,\n          badges: badges,\n          debug: debug,\n          onStatusChange: (status, state) => {\n            if (debug) {\n              const timestamp = new Date().toLocaleTimeString();\n              const emoji =\n                status === 'error' ? '❌' : status === 'idle' ? '⏸️' : '🔄';\n              const style =\n                'color: #9c27b0; font-weight: bold; background: #f3e5f5; padding: 2px 4px; border-radius: 3px;';\n              console.log(\n                `%c[Status ${timestamp}] ${emoji} ${status.toUpperCase()}:`,\n                style,\n                state\n              );\n            }\n\n            // Close sidebar on mobile when autofill starts\n            if (status === AutofillStatus.STARTING) {\n              const sidebar = document.getElementById('sidebar');\n              const sidebarOverlay = document.getElementById('sidebarOverlay');\n              const sidebarToggle = document.getElementById('sidebarToggle');\n\n              if (sidebar && sidebar.classList.contains('open')) {\n                sidebar.classList.remove('open');\n                if (sidebarOverlay) sidebarOverlay.classList.remove('active');\n                if (sidebarToggle) sidebarToggle.classList.remove('active');\n                document.body.style.overflow = '';\n              }\n            }\n\n            // Update status display in UI\n            const statusElement = document.getElementById('status');\n            if (statusElement) {\n              const statusText =\n                {\n                  idle: 'Ready',\n                  starting: 'Starting...',\n                  initializing: 'Initializing inputs...',\n                  determining_functions: 'Determining functions...',\n                  getting_values: 'Getting values...',\n                  setting_values: 'Setting values...',\n                  completed: 'Completed!',\n                  error: 'Error occurred',\n                }[status] || status;\n\n              statusElement.textContent = statusText;\n              statusElement.className = `status ${status}`;\n            }\n\n            // Show progress for certain statuses\n            if (status === 'getting_values' || status === 'setting_values') {\n              const processedCount = state.elements.filter(\n                element => element.value || element.error\n              ).length;\n              const totalCount = state.elements.length;\n              if (totalCount > 0) {\n                showStatus(\n                  `Processing ${processedCount}/${totalCount} fields...`,\n                  'info'\n                );\n              }\n            }\n          },\n        };\n      }\n\n      // Function to fill with current settings\n      window.autofillWithCurrentSettings = async () => {\n        try {\n          const settings = getCurrentSettings();\n          const manager = new Autofill(settings);\n          await manager.fill(undefined);\n\n          const modeText =\n            settings.mode === 'auto' ? 'Auto Mode' : 'Manual Mode';\n          const staggerText =\n            settings.stagger > 0\n              ? ` (${settings.stagger}ms stagger)`\n              : ' (no stagger)';\n          showStatus(\n            `✅ All fields filled with ${modeText}${staggerText}!`,\n            'success'\n          );\n        } catch (error) {\n          showStatus('❌ Error filling fields: ' + error.message, 'error');\n        }\n      };\n\n      // Update stagger delay value display and handle theme toggle\n      document.addEventListener('DOMContentLoaded', function () {\n        const stagger = document.getElementById('stagger');\n        const staggerValue = document.getElementById('staggerValue');\n        const badges = document.getElementById('badges');\n        const badgesValue = document.getElementById('badgesValue');\n        const themeToggle = document.getElementById('themeToggle');\n        const themeIcon = themeToggle.querySelector('.theme-icon');\n\n        if (stagger && staggerValue) {\n          stagger.addEventListener('input', function () {\n            staggerValue.textContent = this.value + 'ms';\n          });\n        }\n\n        if (badges && badgesValue) {\n          badges.addEventListener('input', function () {\n            badgesValue.textContent = this.value + 'ms';\n          });\n        }\n\n        // Handle theme toggle\n        if (themeToggle) {\n          // Get user's saved preference or system preference\n          const savedTheme = localStorage.getItem('theme');\n          const systemPrefersDark = window.matchMedia(\n            '(prefers-color-scheme: dark)'\n          ).matches;\n\n          // Use saved preference if available, otherwise use system preference\n          // Since dark is now default, we need to check if user wants light mode\n          const shouldUseLight =\n            savedTheme === 'light' ||\n            (savedTheme === null && !systemPrefersDark);\n\n          if (shouldUseLight) {\n            document.documentElement.setAttribute('data-theme', 'light');\n            themeIcon.textContent = '🌙';\n          } else {\n            // Dark is default, no data-theme attribute needed\n            themeIcon.textContent = '☀️';\n          }\n\n          themeToggle.addEventListener('click', function () {\n            const isLight =\n              document.documentElement.hasAttribute('data-theme') &&\n              document.documentElement.getAttribute('data-theme') === 'light';\n\n            if (isLight) {\n              // Switch to dark mode (default)\n              document.documentElement.removeAttribute('data-theme');\n              localStorage.setItem('theme', 'dark');\n              themeIcon.textContent = '☀️';\n            } else {\n              // Switch to light mode\n              document.documentElement.setAttribute('data-theme', 'light');\n              localStorage.setItem('theme', 'light');\n              themeIcon.textContent = '🌙';\n            }\n          });\n\n          // Listen for system preference changes\n          window\n            .matchMedia('(prefers-color-scheme: dark)')\n            .addEventListener('change', function (e) {\n              // Only update if user hasn't set a preference\n              if (localStorage.getItem('theme') === null) {\n                if (e.matches) {\n                  // System prefers dark, use default (dark)\n                  document.documentElement.removeAttribute('data-theme');\n                  themeIcon.textContent = '☀️';\n                } else {\n                  // System prefers light, switch to light\n                  document.documentElement.setAttribute('data-theme', 'light');\n                  themeIcon.textContent = '🌙';\n                }\n              }\n            });\n        }\n      });\n\n      window.clearAll = () => {\n        // only search in main content container, not sidebar\n        const mainContent = document.querySelector('.main-content');\n        if (!mainContent) return;\n\n        const inputs = mainContent.querySelectorAll('input, textarea, select');\n        inputs.forEach(input => {\n          if (input.type === 'checkbox' || input.type === 'radio') {\n            input.checked = false;\n          } else {\n            input.value = '';\n          }\n        });\n        showStatus('🧹 All fields cleared!', 'success');\n      };\n\n      window.clearBadges = () => {\n        const badges = document.querySelectorAll(\n          '[data-gofakeit-badge=\"true\"]'\n        );\n        badges.forEach(badge => badge.remove());\n        showStatus('🎯 All badges cleared!', 'success');\n      };\n\n      function showStatus(message, type) {\n        const status = document.getElementById('status');\n        status.textContent = message;\n        status.className = `status ${type}`;\n      }\n\n      // Initialize the page\n      console.log('🎯 Gofakeit Fill Comprehensive Testing loaded!');\n      console.log(\n        'This page tests the search API with various input contexts and categories.'\n      );\n      console.log(\n        'Check the browser network tab to see search API calls in action!'\n      );\n      console.log(\n        'New features: Badge system, debug mode, and improved error handling!'\n      );\n    "],"names":["GOFAKEIT_API_BASE","fetchFuncMulti","requests","processedRequests","req","index","func","id","params","funcName","extractedParams","parseFunctionString","finalParams","makeRequest","fetchFuncSearch","method","url","body","options","response","data","error","questionMarkIndex","functionName","queryString","searchParams","key","value","numValue","GOFAKEIT_COLORS","GOFAKEIT_SPACING","GOFAKEIT_BORDER","GOFAKEIT_FONT","AutofillStatus","Autofill","settings","target","allFormElements","elements","el","formEl","mode","filteredElements","element","gofakeitFunc","autofillElements","labelTexts","labelledBy","ref","labelEl","lbl","closestLabel","prev","labelText","type","name","elementId","placeholder","autocomplete","ariaLabel","part","elementsNeedingSearch","searchRequests","i","searchResult","elementType","min","max","elementsNeedingValues","processedNames","requestToElementMap","request","radioGroup","otherEl","result","processedRadioNames","elementToShowBadge","resolve","selectedRadio","radioEl","input","label","radioName","radio","boolValue","option","textMatch","nonEmptyOptions","randomOption","badge","isError","badgeStyles","lastRect","animationId","isVisible","lastVisibilityCheck","VISIBILITY_CHECK_INTERVAL","scrollableParents","parentRects","checkElementVisibility","rect","parent","parentRect","updateBadgePosition","now","top","left","style","overflow","autofillElementId","existingBadge","values","dateValue","date","year","startOfYear","days","weekNumber","weekValue","match","week","jan1","daysToAdd","targetDate","month","day","format","message","prefix","status","stateCopy","successfulElements","failedElements","resultsData","initMobileSidebar","sidebar","sidebarToggle","sidebarOverlay","openSidebar","closeSidebar","e","handleAutofillClick","button","scrollToElement","offset","mobileHeader","headerOffset","originalScrollMargin","getCurrentSettings","showStatus","selector","selectedCategory","headingText","categoryHeading","allHeadings","heading","section","categoryContainer","filledCount","categoryName","stagger","badges","debug","state","timestamp","statusElement","statusText","processedCount","totalCount","modeText","staggerText","staggerValue","badgesValue","themeToggle","themeIcon","savedTheme","systemPrefersDark","mainContent"],"mappings":"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"}