{"version":3,"file":"index.js","sources":["../src/styles.ts","../src/field-error.ts","../src/api.ts","../src/input-datetime.ts","../src/input-text.ts","../src/input-misc.ts","../src/input-number.ts","../src/autofill.ts","../index.html?html-proxy&index=1.js"],"sourcesContent":["// Centralized style tokens for injected UI (avoid dependency on site CSS)\n\nexport const GOFAKEIT_COLORS = {\n\tprimary: '#ffa000',\n\twhite: '#ffffff',\n\tsuccess: '#48c774',\n\terror: '#ff3860',\n\tinfo: '#209cee',\n\ttext: '#ffffff',\n\tborder: '#686868',\n\tbackground: '#ffffff',\n};\n\nexport const GOFAKEIT_SPACING = {\n\tbase: 24, // px\n\thalf: 12, // px\n\tquarter: 8, // px\n};\n\nexport const GOFAKEIT_BORDER = {\n\tradius: 6, // px\n\twidth: 2, // px\n};\n\nexport const GOFAKEIT_FONT = {\n\tsize: 14, // px\n\tfamily: 'Helvetica, Arial, sans-serif',\n};\n","import { GOFAKEIT_COLORS, GOFAKEIT_SPACING, GOFAKEIT_BORDER, GOFAKEIT_FONT } from './styles';\n\n// Show error message as a floating tooltip over a form field\nexport function showFieldError(element: Element, message: string): void {\n  // Remove any existing error message\n  const existingError = document.querySelector('.gofakeit-error-tooltip');\n  if (existingError) {\n    existingError.remove();\n  }\n\n  // Create error tooltip element\n  const tooltip = document.createElement('div');\n  tooltip.className = 'gofakeit-error-tooltip';\n  tooltip.style.cssText = `\n    position: absolute;\n    z-index: 10001;\n    color: ${GOFAKEIT_COLORS.error};\n    font-size: ${GOFAKEIT_FONT.size}px;\n    font-family: ${GOFAKEIT_FONT.family};\n    background-color: ${GOFAKEIT_COLORS.background};\n    padding: ${GOFAKEIT_SPACING.quarter}px ${GOFAKEIT_SPACING.half}px;\n    border-radius: ${GOFAKEIT_BORDER.radius}px;\n    border: 1px solid ${GOFAKEIT_COLORS.error};\n    box-shadow: 0 4px 12px rgba(0,0,0,0.15);\n    max-width: 300px;\n    word-wrap: break-word;\n    opacity: 0;\n    transform: translateY(-10px);\n    transition: opacity 0.3s ease, transform 0.3s ease;\n    pointer-events: none;\n  `;\n  tooltip.textContent = message;\n\n  // Add to body\n  document.body.appendChild(tooltip);\n\n  // Function to update tooltip position\n  function updateTooltipPosition() {\n    const rect = element.getBoundingClientRect();\n    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;\n    const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;\n    \n    const left = rect.left + scrollLeft;\n    const top = rect.top + scrollTop - tooltip.offsetHeight - 8;\n    \n    tooltip.style.left = `${left}px`;\n    tooltip.style.top = `${top}px`;\n  }\n\n  // Initial positioning\n  updateTooltipPosition();\n\n  // Add scroll and resize listeners\n  const scrollHandler = () => updateTooltipPosition();\n  const resizeHandler = () => updateTooltipPosition();\n  \n  // Listen to scroll events on window and all scrollable elements\n  window.addEventListener('scroll', scrollHandler, { passive: true });\n  window.addEventListener('resize', resizeHandler, { passive: true });\n  \n  // Also listen to scroll events on all elements with overflow scroll\n  const scrollableElements = document.querySelectorAll('*');\n  const scrollableListeners: Array<{ element: Element, handler: () => void }> = [];\n  \n  scrollableElements.forEach(el => {\n    const style = window.getComputedStyle(el);\n    if (style.overflow === 'scroll' || style.overflowY === 'scroll' || style.overflow === 'auto' || style.overflowY === 'auto') {\n      const listener = () => updateTooltipPosition();\n      el.addEventListener('scroll', listener, { passive: true });\n      scrollableListeners.push({ element: el, handler: listener });\n    }\n  });\n\n  // Fade in\n  requestAnimationFrame(() => {\n    tooltip.style.opacity = '1';\n    tooltip.style.transform = 'translateY(0)';\n  });\n\n  // Remove tooltip after 5 seconds with fade out\n  setTimeout(() => {\n    tooltip.style.opacity = '0';\n    tooltip.style.transform = 'translateY(-10px)';\n    \n    // Remove event listeners\n    window.removeEventListener('scroll', scrollHandler);\n    window.removeEventListener('resize', resizeHandler);\n    \n    // Remove scrollable element listeners\n    scrollableListeners.forEach(({ element, handler }) => {\n      element.removeEventListener('scroll', handler);\n    });\n    \n    setTimeout(() => {\n      if (tooltip.parentElement) {\n        tooltip.parentElement.removeChild(tooltip);\n      }\n    }, 300);\n  }, 5000);\n}\n","// Base URL for the Gofakeit API\nconst GOFAKEIT_API_BASE = 'https://api.gofakeit.com/funcs'\n\nexport interface ApiResponse {\n  success: boolean;\n  data?: string;\n  error?: string;\n  status?: number;\n}\n\n// Multi-function request interface\nexport interface MultiFuncRequest {\n  id?: string;\n  func: string;\n  params?: Record<string, unknown>;\n}\n\n// Multi-function response interface\nexport interface MultiFuncResponse {\n  id?: string;\n  value: string | null;\n  error: string;\n}\n\n// Multi-function API response interface\nexport interface MultiFuncApiResponse {\n  success: boolean;\n  data?: MultiFuncResponse[];\n  error?: string;\n  status?: number;\n}\n\n// Function search request interface\nexport interface FuncSearchRequest {\n  id: string;\n  query: string;\n}\n\n// Function search result interface\nexport interface FuncSearchResult {\n  name: string;     // function name for API usage\n  score: number;    // relevance score (0-100)\n  reasons: string[]; // why it matched\n}\n\n// Function search response interface\nexport interface FuncSearchResponse {\n  id: string;\n  query: string;\n  results: FuncSearchResult[];\n}\n\n// Multi-function search API response interface\nexport interface MultiFuncSearchApiResponse {\n  success: boolean;\n  data?: FuncSearchResponse[];\n  error?: string;\n  status?: number;\n}\n\n// Fetch data from gofakeit API\nexport async function callFunc(func: string): Promise<ApiResponse> {\n  // Check if the function contains query parameters\n  const questionMarkIndex = func.indexOf('?');\n  \n  if (questionMarkIndex !== -1) {\n    // Function has query parameters - use POST with JSON body\n    const functionName = func.substring(0, questionMarkIndex);\n    const queryString = func.substring(questionMarkIndex + 1);\n    \n    // Parse query parameters into an object\n    const params: Record<string, unknown> = {};\n    const searchParams = new URLSearchParams(queryString);\n    \n    for (const [key, value] of searchParams.entries()) {\n      // Try to parse as number if possible\n      const numValue = parseFloat(value);\n      params[key] = isNaN(numValue) ? value : numValue;\n    }\n    \n    return makeRequest('POST', `${GOFAKEIT_API_BASE}/${functionName}`, params);\n  } else {\n    // Simple function - use GET request\n    return makeRequest('GET', `${GOFAKEIT_API_BASE}/${func}`);\n  }\n}\n\n\n\n// Call multiple functions in a single request\nexport async function callMultiFunc(requests: MultiFuncRequest[]): Promise<MultiFuncApiResponse> {\n  if (requests.length === 0) {\n    return {\n      success: false,\n      error: 'No functions provided'\n    };\n  }\n\n  // Process each request to extract function name and parameters\n  const processedRequests: MultiFuncRequest[] = requests.map((req, index) => {\n    const { func, id } = req;\n    const questionMarkIndex = func.indexOf('?');\n    \n    if (questionMarkIndex !== -1) {\n      // Function has query parameters\n      const functionName = func.substring(0, questionMarkIndex);\n      const queryString = func.substring(questionMarkIndex + 1);\n      \n      // Parse query parameters into an object\n      const params: Record<string, unknown> = {};\n      const searchParams = new URLSearchParams(queryString);\n      \n      for (const [key, value] of searchParams.entries()) {\n        // Try to parse as number if possible\n        const numValue = parseFloat(value);\n        params[key] = isNaN(numValue) ? value : numValue;\n      }\n      \n      return {\n        id: id || `req_${index}`,\n        func: functionName,\n        params\n      };\n    } else {\n      // Simple function\n      return {\n        id: id || `req_${index}`,\n        func,\n        params: req.params\n      };\n    }\n  });\n\n  return makeMultiRequest('POST', `${GOFAKEIT_API_BASE}/multi`, processedRequests);\n}\n\n// Search for multiple functions in a single request\nexport async function searchMultiFunc(requests: FuncSearchRequest[]): Promise<MultiFuncSearchApiResponse> {\n  if (requests.length === 0) {\n    return {\n      success: false,\n      error: 'No search queries provided'\n    };\n  }\n\n  return makeSearchRequest('POST', `${GOFAKEIT_API_BASE}/search`, requests);\n}\n\n// Base HTTP request function\nasync function makeRequest(method: 'GET' | 'POST', url: string, body?: Record<string, unknown>): Promise<ApiResponse> {\n  try {\n    const options: {\n      method: string;\n      headers: Record<string, string>;\n      body?: string;\n    } = {\n      method: method,\n      headers: {\n        'Content-Type': 'application/json',\n      }\n    };\n\n    if (method === 'POST' && body) {\n      options.body = JSON.stringify(body);\n    }\n\n    const response = await fetch(url, options);\n    \n    if (!response.ok) {\n      return {\n        success: false,\n        error: `HTTP error! status: ${response.status}`,\n        status: response.status\n      };\n    }\n    \n    const data = await response.text();\n    return {\n      success: true,\n      data: data\n    };\n  } catch (error) {\n    console.error(`[Gofakeit Autofill] Error in ${method} request to ${url}:`, error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error'\n    };\n  }\n}\n\n// Multi-function HTTP request function\nasync function makeMultiRequest(method: 'GET' | 'POST', url: string, body: MultiFuncRequest[]): Promise<MultiFuncApiResponse> {\n  try {\n    const options: {\n      method: string;\n      headers: Record<string, string>;\n      body: string;\n    } = {\n      method: method,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(body)\n    };\n\n    const response = await fetch(url, options);\n    \n    if (!response.ok) {\n      return {\n        success: false,\n        error: `HTTP error! status: ${response.status}`,\n        status: response.status\n      };\n    }\n    \n    const data = await response.json();\n    return {\n      success: true,\n      data: data\n    };\n  } catch (error) {\n    console.error(`[Gofakeit Autofill] Error in ${method} request to ${url}:`, error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error'\n    };\n  }\n}\n\n// Multi-function search HTTP request function\nasync function makeSearchRequest(method: 'GET' | 'POST', url: string, body: FuncSearchRequest[]): Promise<MultiFuncSearchApiResponse> {\n  try {\n    const options: {\n      method: string;\n      headers: Record<string, string>;\n      body: string;\n    } = {\n      method: method,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(body)\n    };\n\n    const response = await fetch(url, options);\n    \n    if (!response.ok) {\n      return {\n        success: false,\n        error: `HTTP error! status: ${response.status}`,\n        status: response.status\n      };\n    }\n    \n    const data = await response.json();\n    return {\n      success: true,\n      data: data\n    };\n  } catch (error) {\n    console.error(`[Gofakeit Autofill] Error in ${method} request to ${url}:`, error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error'\n    };\n  }\n}\n","import { callFunc } from './api';\nimport { handleError, getDefaultFunctionForInputType } from './autofill';\n\n// Get function name for date/time input (for batch processing)\nexport function getDateTimeInput(element: HTMLInputElement, gofakeitFunc: string): string {\n  const inputType = element.type.toLowerCase();\n  \n  // For all date/time inputs, use local generate functions when gofakeitFunc is 'true'\n  if (inputType === 'date') {\n    return gofakeitFunc === 'true' ? 'generateDate' : gofakeitFunc;\n  }\n  \n  if (inputType === 'datetime-local') {\n    return gofakeitFunc === 'true' ? 'generateDateTime' : gofakeitFunc;\n  }\n  \n  if (inputType === 'time') {\n    return gofakeitFunc === 'true' ? 'generateTime' : gofakeitFunc;\n  }\n  \n  if (inputType === 'month') {\n    return gofakeitFunc === 'true' ? 'generateMonth' : gofakeitFunc;\n  }\n  \n  if (inputType === 'week') {\n    return gofakeitFunc === 'true' ? 'generateWeek' : gofakeitFunc;\n  }\n  \n  return gofakeitFunc;\n}\n\n// Set date/time input value (for batch processing)\nexport function setDateTimeInput(element: HTMLInputElement, value: string): void {\n  element.value = value;\n  element.dispatchEvent(new Event('input', { bubbles: true }));\n  element.dispatchEvent(new Event('change', { bubbles: true }));\n}\n\n// Generate time string (HH:MM format)\nexport async function generateTime(): Promise<string> {\n  // Generate random hour and minute locally\n  const hour = Math.floor(Math.random() * 24).toString().padStart(2, '0');\n  const minute = Math.floor(Math.random() * 60).toString().padStart(2, '0');\n  return `${hour}:${minute}`;\n}\n\n// Generate month string (YYYY-MM format)\nexport async function generateMonth(): Promise<string> {\n  // Generate random year and month locally\n  const year = Math.floor(Math.random() * 30) + 1990; // Random year between 1990-2020\n  const month = (Math.floor(Math.random() * 12) + 1).toString().padStart(2, '0');\n  return `${year}-${month}`;\n}\n\n// Generate date string (YYYY-MM-DD format)\nexport async function generateDate(): Promise<string> {\n  // Generate random year, month, and day locally\n  const year = Math.floor(Math.random() * 30) + 1990; // Random year between 1990-2020\n  const month = (Math.floor(Math.random() * 12) + 1).toString().padStart(2, '0');\n  const day = (Math.floor(Math.random() * 28) + 1).toString().padStart(2, '0'); // Use 28 to avoid invalid dates\n  return `${year}-${month}-${day}`;\n}\n\n// Generate datetime string (YYYY-MM-DDTHH:MM format)\nexport async function generateDateTime(): Promise<string> {\n  // Generate random date and time locally\n  const year = Math.floor(Math.random() * 30) + 1990; // Random year between 1990-2020\n  const month = (Math.floor(Math.random() * 12) + 1).toString().padStart(2, '0');\n  const day = (Math.floor(Math.random() * 28) + 1).toString().padStart(2, '0'); // Use 28 to avoid invalid dates\n  const hour = Math.floor(Math.random() * 24).toString().padStart(2, '0');\n  const minute = Math.floor(Math.random() * 60).toString().padStart(2, '0');\n  return `${year}-${month}-${day}T${hour}:${minute}`;\n}\n\n// Generate week string (YYYY-W## format)\nexport async function generateWeek(): Promise<string> {\n  const weekYearResponse = await callFunc('year');\n  const weekResponse = await callFunc('number?min=1&max=53');\n  \n  if (!weekYearResponse.success || !weekResponse.success) {\n    throw new Error(`Failed to generate week: ${weekYearResponse.error || weekResponse.error}`);\n  }\n  \n  const week = weekResponse.data!.padStart(2, '0');\n  return `${weekYearResponse.data!}-W${week}`;\n}\n\n// Get ISO week number for a date\nfunction getISOWeek(date: Date): number {\n  const d = new Date(date.getTime());\n  d.setUTCHours(0, 0, 0, 0);\n  // Thursday in current week decides the year\n  d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));\n  // January 4 is always in week 1\n  const week1 = new Date(d.getUTCFullYear(), 0, 4);\n  // Adjust to Thursday in week 1 and count number of weeks from date to week1\n  const week = Math.ceil((((d.getTime() - week1.getTime()) / 86400000) - 3 + (week1.getUTCDay() || 7)) / 7);\n  return week;\n}\n\n// Handle date/time input elements\nexport async function handleDateTimeInput(element: HTMLInputElement, gofakeitFunc: string, value?: string): Promise<{ success: boolean, usedFunc: string }> {\n  const inputType = element.type.toLowerCase();\n  const functionToCall = getDateTimeInput(element, gofakeitFunc);\n  \n  try {\n    let finalValue: string;\n    \n    // If value is provided (batch processing), use it directly\n    if (value !== undefined) {\n      finalValue = value;\n    } else {\n      // Handle generate functions (multi-function cases)\n      if (functionToCall === 'generateTime') {\n        finalValue = await generateTime();\n      } else if (functionToCall === 'generateMonth') {\n        finalValue = await generateMonth();\n      } else if (functionToCall === 'generateWeek') {\n        finalValue = await generateWeek();\n      } else if (functionToCall === 'generateDate') {\n        finalValue = await generateDate();\n      } else if (functionToCall === 'generateDateTime') {\n        finalValue = await generateDateTime();\n      } else {\n        // Handle single function cases\n        const response = await callFunc(functionToCall);\n        \n        if (!response.success) {\n          console.warn(`[Gofakeit Autofill] Error for ${inputType} input:`, response.error);\n          if (response.status === 400) {\n            handleError(element, `Failed to get random ${inputType}`);\n          }\n          \n          // Fallback to default function for this input type\n          const fallbackFunc = getDefaultFunctionForInputType(inputType);\n          if (fallbackFunc !== functionToCall) {\n            console.warn(`[Gofakeit Autofill] Falling back to default function: ${fallbackFunc}`);\n            \n            // Handle generate functions directly\n            if (fallbackFunc === 'generateWeek') {\n              finalValue = await generateWeek();\n            } else if (fallbackFunc === 'generateTime') {\n              finalValue = await generateTime();\n            } else if (fallbackFunc === 'generateMonth') {\n              finalValue = await generateMonth();\n            } else if (fallbackFunc === 'generateDate') {\n              finalValue = await generateDate();\n            } else if (fallbackFunc === 'generateDateTime') {\n              finalValue = await generateDateTime();\n            } else {\n              // For other functions, try calling the API\n              const fallbackResponse = await callFunc(fallbackFunc);\n              if (fallbackResponse.success) {\n                finalValue = fallbackResponse.data!;\n              } else {\n                return { success: false, usedFunc: functionToCall };\n              }\n            }\n          } else {\n            return { success: false, usedFunc: functionToCall };\n          }\n        } else {\n          finalValue = response.data!;\n        }\n      }\n    }\n    \n    // Parse and format the value based on input type\n    if (inputType === 'date') {\n      // Extract YYYY-MM-DD part from ISO date string\n      const dateMatch = finalValue.match(/^(\\d{4}-\\d{2}-\\d{2})/);\n      if (dateMatch) {\n        finalValue = dateMatch[1];\n      } else {\n        console.warn('[Gofakeit Autofill] Could not parse date from response:', finalValue);\n        return { success: false, usedFunc: functionToCall };\n      }\n    } else if (inputType === 'datetime-local') {\n      // Extract YYYY-MM-DDTHH:MM part from ISO datetime string\n      const datetimeMatch = finalValue.match(/^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2})(:\\d{2})?/);\n      if (datetimeMatch) {\n        finalValue = datetimeMatch[1];\n      } else {\n        console.warn('[Gofakeit Autofill] Could not parse datetime from response:', finalValue);\n        return { success: false, usedFunc: functionToCall };\n      }\n    } else if (inputType === 'week' && functionToCall !== 'generateWeek') {\n      // Handle custom week functions (like date/daterange)\n      if (functionToCall === 'date' || functionToCall.startsWith('daterange')) {\n        const dateMatch = finalValue.match(/^(\\d{4}-\\d{2}-\\d{2})/);\n        if (dateMatch) {\n          const date = new Date(dateMatch[1]);\n          const year = date.getFullYear();\n          const week = getISOWeek(date);\n          finalValue = `${year}-W${week.toString().padStart(2, '0')}`;\n        } else {\n          console.warn('[Gofakeit Autofill] Could not parse date for week from response:', finalValue);\n          return { success: false, usedFunc: functionToCall };\n        }\n      }\n    }\n    \n    setDateTimeInput(element, finalValue);\n    return { success: true, usedFunc: functionToCall };\n    \n  } catch (error) {\n    console.warn(`[Gofakeit Autofill] Unexpected error handling ${inputType} input:`, error);\n    return { success: false, usedFunc: functionToCall };\n  }\n}\n","import { callFunc } from './api';\nimport { handleError, getDefaultFunctionForInputType } from './autofill';\n\n// Get function name for text input (for batch processing)\nexport function getTextInput(element: HTMLInputElement, gofakeitFunc: string): string {\n  const inputType = element.type.toLowerCase();\n  \n  // Map input types to appropriate gofakeit functions if 'true' is passed\n  if (gofakeitFunc === 'true') {\n    switch (inputType) {\n      case 'email':\n        return 'email';\n      case 'tel':\n        return 'phone';\n      case 'password':\n        return 'password';\n      case 'search':\n        return 'word';\n      case 'url':\n        return 'url';\n      case 'color':\n        return 'hexcolor';\n      default:\n        return 'word'; // Default for text inputs\n    }\n  }\n  \n  return gofakeitFunc;\n}\n\n// Set text input value (for batch processing)\nexport function setTextInput(element: HTMLInputElement, value: string): void {\n  element.value = value;\n  element.dispatchEvent(new Event('input', { bubbles: true }));\n  element.dispatchEvent(new Event('change', { bubbles: true }));\n}\n\n// Handle text input elements (text, email, tel, password, search, url, color)\nexport async function handleTextInput(element: HTMLInputElement, gofakeitFunc: string): Promise<{ success: boolean, usedFunc: string }> {\n  const functionToCall = getTextInput(element, gofakeitFunc);\n  \n  const response = await callFunc(functionToCall);\n  \n  if (!response.success) {\n    console.warn(`[Gofakeit Autofill] Error for function ${functionToCall}:`, response.error);\n    \n    if (response.status === 400) {\n      handleError(element, '', functionToCall);\n    }\n    \n    // Fallback to default function for this input type\n    const inputType = element.type.toLowerCase();\n    const fallbackFunc = getDefaultFunctionForInputType(inputType);\n    if (fallbackFunc !== functionToCall) {\n      console.warn(`[Gofakeit Autofill] Falling back to default function: ${fallbackFunc}`);\n      const fallbackResponse = await callFunc(fallbackFunc);\n      if (fallbackResponse.success) {\n        setTextInput(element, fallbackResponse.data!);\n        return { success: true, usedFunc: fallbackFunc };\n      }\n    }\n    \n    return { success: false, usedFunc: functionToCall };\n  }\n  \n  setTextInput(element, response.data!);\n  return { success: true, usedFunc: functionToCall };\n}\n\n// Get function name for textarea (for batch processing)\nexport function getTextarea(gofakeitFunc: string): string {\n  return gofakeitFunc === 'true' ? 'sentence' : gofakeitFunc;\n}\n\n// Set textarea value (for batch processing)\nexport function setTextarea(element: HTMLTextAreaElement, value: string): void {\n  element.value = value;\n  element.dispatchEvent(new Event('input', { bubbles: true }));\n  element.dispatchEvent(new Event('change', { bubbles: true }));\n}\n\n// Handle textarea elements\nexport async function handleTextarea(element: HTMLTextAreaElement, gofakeitFunc: string): Promise<{ success: boolean, usedFunc: string }> {\n  // Use sentence function if 'true' is passed, otherwise use the provided function\n  const functionToCall = getTextarea(gofakeitFunc);\n  \n  const response = await callFunc(functionToCall);\n  \n  if (!response.success) {\n    console.warn(`[Gofakeit Autofill] Error for function ${functionToCall}:`, response.error);\n    \n    if (response.status === 400) {\n      handleError(element, '', functionToCall);\n    }\n    \n    // Fallback to default function (sentence)\n    const fallbackFunc = 'sentence';\n    if (fallbackFunc !== functionToCall) {\n      console.warn(`[Gofakeit Autofill] Falling back to default function: ${fallbackFunc}`);\n      const fallbackResponse = await callFunc(fallbackFunc);\n      if (fallbackResponse.success) {\n        setTextarea(element, fallbackResponse.data!);\n        return { success: true, usedFunc: fallbackFunc };\n      }\n    }\n    \n    return { success: false, usedFunc: functionToCall };\n  }\n  \n  setTextarea(element, response.data!);\n  return { success: true, usedFunc: functionToCall };\n}\n\n","import { callFunc } from './api';\nimport { handleError } from './autofill';\n\n// Handle checkbox input elements\nexport async function handleCheckbox(element: HTMLInputElement, gofakeitFunc: string, value?: string): Promise<{ success: boolean, usedFunc: string }> {\n  // Find the checkbox group by name\n  const checkboxGroup = findCheckboxGroup(element);\n  \n  if (checkboxGroup.length === 0) {\n    console.warn('[Gofakeit Autofill] No checkbox group found for element:', element);\n    return { success: false, usedFunc: 'bool' };\n  }\n  \n  // Use boolean function if 'true' is passed, otherwise use the provided function\n  const functionToCall = gofakeitFunc === 'true' ? 'bool' : gofakeitFunc;\n  \n  // If value is provided (from batch), use it directly\n  if (value !== undefined) {\n    // Clear all checkboxes first\n    checkboxGroup.forEach(cb => {\n      cb.checked = false;\n      cb.dispatchEvent(new Event('change', { bubbles: true }));\n    });\n    \n    // For boolean values, check if it's true\n    const boolValue = String(value).toLowerCase() === 'true' || value === '1' || String(value).toLowerCase() === 'yes';\n    if (boolValue && checkboxGroup.length > 0) {\n      // Select the first checkbox if value is true\n      checkboxGroup[0].checked = true;\n      checkboxGroup[0].dispatchEvent(new Event('change', { bubbles: true }));\n    }\n    \n    return { success: true, usedFunc: functionToCall };\n  }\n  \n  // For checkbox groups, we want to select multiple checkboxes\n  if (gofakeitFunc === 'true') {\n    // Select roughly half of the checkboxes in the group\n    const numToSelect = Math.max(1, Math.ceil(checkboxGroup.length / 2));\n    \n    // Clear all checkboxes first\n    checkboxGroup.forEach(cb => {\n      cb.checked = false;\n      cb.dispatchEvent(new Event('change', { bubbles: true }));\n    });\n    \n    // Select random checkboxes using API\n    const selectedIndices = new Set<number>();\n    for (let i = 0; i < numToSelect; i++) {\n      const boolResponse = await callFunc('bool');\n      if (boolResponse.success) {\n        const shouldSelect = boolResponse.data!.toLowerCase() === 'true' || boolResponse.data!.toLowerCase() === '1';\n        if (shouldSelect) {\n          // Find an unselected checkbox\n          const availableIndices = Array.from({ length: checkboxGroup.length }, (_, i) => i)\n            .filter(i => !selectedIndices.has(i));\n          \n          if (availableIndices.length > 0) {\n            const randomIndex = availableIndices[Math.floor(Math.random() * availableIndices.length)];\n            selectedIndices.add(randomIndex);\n            checkboxGroup[randomIndex].checked = true;\n            checkboxGroup[randomIndex].dispatchEvent(new Event('change', { bubbles: true }));\n          }\n        }\n      }\n    }\n  } else {\n    // For custom functions, use the response to determine which checkboxes to select\n    const response = await callFunc(functionToCall);\n    \n    if (!response.success) {\n      console.warn(`[Gofakeit Autofill] Error for function ${functionToCall}:`, response.error);\n      \n      if (response.status === 400) {\n        handleError(element, '', functionToCall);\n      }\n      return { success: false, usedFunc: functionToCall };\n    }\n    \n    // Clear all checkboxes first\n    checkboxGroup.forEach(cb => {\n      cb.checked = false;\n      cb.dispatchEvent(new Event('change', { bubbles: true }));\n    });\n    \n    // Parse the response to determine which checkboxes to select\n    const values = response.data!.split(',').map(v => v.trim());\n    \n    checkboxGroup.forEach((cb, index) => {\n      const shouldCheck = values.includes(cb.value) || values.includes(index.toString());\n      cb.checked = shouldCheck;\n      cb.dispatchEvent(new Event('change', { bubbles: true }));\n    });\n  }\n  \n  return { success: true, usedFunc: functionToCall };\n}\n\n// Handle radio inputs\nexport async function handleRadio(element: HTMLInputElement, gofakeitFunc: string, value?: string): Promise<{ success: boolean, usedFunc: string, selectedElement?: HTMLInputElement }> {\n  const radioGroup = findRadioGroup(element);\n  // For radio buttons, when 'true' is passed, we actually use 'bool' function\n  const functionToCall = gofakeitFunc === 'true' ? 'bool' : gofakeitFunc;\n  \n  // If a specific value is provided, try to select that radio button\n  if (value !== undefined) {\n    // Clear all radio buttons first\n    radioGroup.forEach((rb: HTMLInputElement) => {\n      rb.checked = false;\n      rb.dispatchEvent(new Event('change', { bubbles: true }));\n    });\n    \n    // Try to find by value first, then by index\n    let selectedRadio = radioGroup.find((rb: HTMLInputElement) => rb.value === value);\n    if (!selectedRadio && !isNaN(Number(value))) {\n      const index = parseInt(value);\n      if (index >= 0 && index < radioGroup.length) {\n        selectedRadio = radioGroup[index];\n      }\n    }\n    \n    // If no match found, select the first one\n    if (selectedRadio) {\n      selectedRadio.checked = true;\n      selectedRadio.dispatchEvent(new Event('change', { bubbles: true }));\n    }\n    \n    return { success: true, usedFunc: functionToCall, selectedElement: selectedRadio };\n  }\n  \n  // For radio groups, we want to select exactly one radio button\n  if (gofakeitFunc === 'true') {\n    // Clear all radio buttons first\n    radioGroup.forEach((rb: HTMLInputElement) => {\n      rb.checked = false;\n      rb.dispatchEvent(new Event('change', { bubbles: true }));\n    });\n    \n    // Always select exactly one random radio button\n    const randomIndex = Math.floor(Math.random() * radioGroup.length);\n    radioGroup[randomIndex].checked = true;\n    radioGroup[randomIndex].dispatchEvent(new Event('change', { bubbles: true }));\n    \n    return { success: true, usedFunc: functionToCall, selectedElement: radioGroup[randomIndex] };\n  } else {\n    // For custom functions, use the response to determine which radio button to select\n    const response = await callFunc(functionToCall);\n    \n    if (!response.success) {\n      console.warn(`[Gofakeit Autofill] Error for function ${functionToCall}:`, response.error);\n      \n      if (response.status === 400) {\n        handleError(element, '', functionToCall);\n      }\n      return { success: false, usedFunc: functionToCall };\n    }\n    \n    // Clear all radio buttons first\n    radioGroup.forEach((rb: HTMLInputElement) => {\n      rb.checked = false;\n      rb.dispatchEvent(new Event('change', { bubbles: true }));\n    });\n    \n    // Parse the response to determine which radio button to select\n    const value = response.data!.trim();\n    \n    // Try to find by value first, then by index\n    let selectedRadio = radioGroup.find((rb: HTMLInputElement) => rb.value === value);\n    if (!selectedRadio && !isNaN(Number(value))) {\n      const index = parseInt(value);\n      if (index >= 0 && index < radioGroup.length) {\n        selectedRadio = radioGroup[index];\n      }\n    }\n    \n    // If no match found, select a random one to ensure exactly one is selected\n    if (selectedRadio) {\n      selectedRadio.checked = true;\n      selectedRadio.dispatchEvent(new Event('change', { bubbles: true }));\n      \n      return { success: true, usedFunc: functionToCall, selectedElement: selectedRadio };\n    } else {\n      // Fallback: select a random radio button\n      const randomIndex = Math.floor(Math.random() * radioGroup.length);\n      radioGroup[randomIndex].checked = true;\n      radioGroup[randomIndex].dispatchEvent(new Event('change', { bubbles: true }));\n      \n      return { success: true, usedFunc: functionToCall, selectedElement: radioGroup[randomIndex] };\n    }\n  }\n}\n\n// Helper function to find checkbox group\nfunction findCheckboxGroup(element: HTMLInputElement): HTMLInputElement[] {\n  if (element.type !== 'checkbox') return [element];\n  \n  // Look for checkboxes with the same name or in the same container\n  const name = element.name;\n  const container = element.closest('form, div, fieldset') || document;\n  \n  if (name) {\n    // Find checkboxes with the same name\n    return Array.from(container.querySelectorAll(`input[type=\"checkbox\"][name=\"${name}\"]`));\n  } else {\n    // Find checkboxes in the same container\n    return Array.from(container.querySelectorAll('input[type=\"checkbox\"]'));\n  }\n}\n\n// Helper function to find radio group\nfunction findRadioGroup(element: HTMLInputElement): HTMLInputElement[] {\n  if (element.type !== 'radio') return [element];\n  \n  // Look for radio buttons with the same name\n  const name = element.name;\n  \n  if (name) {\n    // Search the entire document for radio buttons with the same name\n    const radioButtons = Array.from(document.querySelectorAll(`input[type=\"radio\"][name=\"${name}\"]`)) as HTMLInputElement[];\n    return radioButtons;\n  } else {\n    // Find radio buttons in the same container\n    const container = element.closest('form, div, fieldset') || document;\n    const radioButtons = Array.from(container.querySelectorAll('input[type=\"radio\"]')) as HTMLInputElement[];\n    return radioButtons;\n  }\n}\n\n// Handle select dropdown\nexport async function handleSelectWithFunction(element: HTMLSelectElement, gofakeitFunc: string, value?: string): Promise<{ success: boolean, usedFunc: string }> {\n  const options = Array.from(element.options).map(option => option.value).filter(value => value !== '');\n  \n  if (options.length === 0) {\n    console.warn('[Gofakeit Autofill] Select element has no valid options:', element);\n    return { success: false, usedFunc: gofakeitFunc };\n  }\n  \n  // If value is provided (from batch), use it directly\n  if (value !== undefined) {\n    if (element.multiple) {\n      // Handle multiselect\n      Array.from(element.options).forEach(option => option.selected = false);\n      \n      // Parse comma-separated values\n      const selectedValues = value.split(',').map(val => val.trim()).filter(val => val !== '');\n      selectedValues.forEach(value => {\n        const option = element.options.namedItem(value) || Array.from(element.options).find(opt => opt.value === value);\n        if (option) option.selected = true;\n      });\n    } else {\n      // Try to set the value directly\n      const option = element.options.namedItem(value) || Array.from(element.options).find(opt => opt.value === value);\n      if (option) {\n        element.value = value;\n      } else {\n        // If the value doesn't match any option, select a random option\n        const validOptions = options.filter(opt => opt !== '');\n        if (validOptions.length > 0) {\n          const randomOption = validOptions[Math.floor(Math.random() * validOptions.length)];\n          element.value = randomOption;\n        } else {\n          // If no valid options, don't set any value\n          return { success: false, usedFunc: gofakeitFunc };\n        }\n      }\n    }\n    \n    element.dispatchEvent(new Event('change', { bubbles: true }));\n    return { success: true, usedFunc: gofakeitFunc === 'true' ? 'random' : gofakeitFunc };\n  }\n  \n  let response;\n  if (gofakeitFunc === 'true') {\n    // Use random selection for 'true' - randomly select from options\n    const randomIndex = Math.floor(Math.random() * options.length);\n    const selectedOption = options[randomIndex];\n    response = { success: true, data: selectedOption };\n  } else {\n    // Use custom function\n    response = await callFunc(gofakeitFunc);\n  }\n  \n  if (!response.success) {\n    console.warn(`[Gofakeit Autofill] Error for select:`, response.error);\n    if (response.status === 400) {\n      handleError(element, 'Failed to get selection');\n    }\n    return { success: false, usedFunc: gofakeitFunc };\n  }\n  \n  if (element.multiple) {\n    // Handle multiselect\n    Array.from(element.options).forEach(option => option.selected = false);\n    \n    if (gofakeitFunc === 'true') {\n      // For random selection, select multiple options (roughly half)\n      const numToSelect = Math.min(Math.ceil(options.length / 2), options.length);\n      const selectedValues = [response.data!];\n      \n      // Add more random selections\n      const remainingOptions = options.filter(opt => opt !== response.data!);\n      for (let i = 1; i < numToSelect && remainingOptions.length > 0; i++) {\n        const randomIndex = Math.floor(Math.random() * remainingOptions.length);\n        selectedValues.push(remainingOptions.splice(randomIndex, 1)[0]);\n      }\n      \n      selectedValues.forEach(value => {\n        const option = element.options.namedItem(value) || Array.from(element.options).find(opt => opt.value === value);\n        if (option) option.selected = true;\n      });\n    } else {\n      // Parse comma-separated values for custom function\n      const selectedValues = response.data!.split(',').map(val => val.trim()).filter(val => val !== '');\n      selectedValues.forEach(value => {\n        const option = element.options.namedItem(value) || Array.from(element.options).find(opt => opt.value === value);\n        if (option) option.selected = true;\n      });\n    }\n  } else {\n    element.value = response.data!;\n  }\n  \n  element.dispatchEvent(new Event('change', { bubbles: true }));\n  return { success: true, usedFunc: gofakeitFunc === 'true' ? 'random' : gofakeitFunc };\n}\n","import { callFunc } from './api';\nimport { handleError } from './autofill';\n\n// Get function name for number input (for batch processing)\nexport function getNumberInput(gofakeitFunc: string): string {\n  return gofakeitFunc === 'true' ? 'number' : gofakeitFunc;\n}\n\n// Set number input value (for batch processing)\nexport function setNumberInput(element: HTMLInputElement, value: string): void {\n  element.value = value;\n  element.dispatchEvent(new Event('input', { bubbles: true }));\n  element.dispatchEvent(new Event('change', { bubbles: true }));\n}\n\n// Handle number input elements\nexport async function handleNumberInput(element: HTMLInputElement, gofakeitFunc: string): Promise<{ success: boolean, usedFunc: string }> {\n  // Use number function if 'true' is passed, otherwise use the provided function\n  const functionToCall = getNumberInput(gofakeitFunc);\n  \n  const response = await callFunc(functionToCall);\n  \n  if (!response.success) {\n    console.warn(`[Gofakeit Autofill] Error for function ${functionToCall}:`, response.error);\n    \n    if (response.status === 400) {\n      handleError(element, '', functionToCall);\n    }\n    return { success: false, usedFunc: functionToCall };\n  }\n  \n  setNumberInput(element, response.data!);\n  return { success: true, usedFunc: functionToCall };\n}\n\n// Get function name for range input (for batch processing)\nexport function getRangeInput(element: HTMLInputElement): string {\n  const min = parseFloat(element.min) || 0;\n  const max = parseFloat(element.max) || 100;\n  return `number?min=${min}&max=${max}`;\n}\n\n// Set range input value (for batch processing)\nexport function setRangeInput(element: HTMLInputElement, value: string): void {\n  const numValue = parseFloat(value);\n  if (!isNaN(numValue)) {\n    const min = parseFloat(element.min) || 0;\n    const max = parseFloat(element.max) || 100;\n    const clampedValue = Math.max(min, Math.min(max, numValue));\n    element.value = clampedValue.toString();\n    element.dispatchEvent(new Event('input', { bubbles: true }));\n    element.dispatchEvent(new Event('change', { bubbles: true }));\n  }\n}\n\n// Handle range input elements\nexport async function handleRangeInput(element: HTMLInputElement): Promise<{ success: boolean, usedFunc: string }> {\n  // For range inputs, always use gofakeit API with min/max from the element\n  const functionToCall = getRangeInput(element);\n  \n  const response = await callFunc(functionToCall);\n  \n  if (!response.success) {\n    console.warn(`[Gofakeit Autofill] Error for range input:`, response.error);\n    \n    if (response.status === 400) {\n      handleError(element, 'Failed to get random number for range');\n    }\n    return { success: false, usedFunc: functionToCall };\n  }\n  \n  setRangeInput(element, response.data!);\n  return { success: true, usedFunc: functionToCall };\n}\n","import { GOFAKEIT_COLORS } from './styles';\nimport { showFieldError } from './field-error';\nimport { handleDateTimeInput } from './input-datetime';\nimport { handleTextInput, handleTextarea, getTextarea, setTextInput, setTextarea } from './input-text';\nimport { handleCheckbox, handleRadio, handleSelectWithFunction } from './input-misc';\nimport { handleNumberInput, handleRangeInput, getRangeInput, setNumberInput, setRangeInput } from './input-number';\nimport { callMultiFunc, MultiFuncRequest, searchMultiFunc, FuncSearchRequest } from './api';\n\n// Settings interface for autofill configuration\nexport interface AutofillSettings {\n  smart?: boolean;\n  staggered?: boolean;\n  staggerDelay?: number;\n}\n\n// ============================================================================\n// MAIN PUBLIC FUNCTIONS (Entry Points)\n// ============================================================================\n\n// Unified autofill function that handles all cases\nexport async function autofill(target?: HTMLElement | Element, settings?: AutofillSettings): Promise<boolean | void> {\n  const defaultSettings: AutofillSettings = { smart: true }; // Default to true for backward compatibility\n  const finalSettings = { ...defaultSettings, ...settings };\n  \n  // No parameters - autofill all form fields on the page\n  if (!target) {\n    return autofillAll(finalSettings);\n  }\n  \n  // If target is a container (has form fields), autofill the container\n  if (target instanceof HTMLElement && hasFormFields(target)) {\n    return autofillContainer(target, finalSettings);\n  }\n  \n  // If target is a form element, autofill just that element\n  if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement || target instanceof HTMLSelectElement) {\n    const success = await autofillElement(target, finalSettings);\n    if (!success) {\n      showNotification('Failed to autofill the specified element', 'error');\n    }\n    return success;\n  }\n  \n  // If target is a container but doesn't have form fields, try to find a container\n  if (target instanceof HTMLElement) {\n    const container = findFormContainer(target);\n    if (container) {\n      return autofillContainer(container, finalSettings);\n    }\n  }\n  \n  // For non-form elements, return false instead of falling back to autofill all\n  return false;\n}\n\n// Autofill all form fields on the page\nasync function autofillAll(settings: AutofillSettings): Promise<void> {\n  const elements = queryFormElements();\n  const smartMode = settings.smart ?? true;\n\n  // Smart mode: Fill ALL form fields (except those explicitly excluded)\n  // Manual mode: Only fill fields with data-gofakeit attributes\n  const targetsBase = smartMode\n    ? elements\n    : elements.filter((el) => (el as Element).hasAttribute('data-gofakeit'));\n  const targets = targetsBase.filter((el) => !isDataGofakeitFalse(el));\n\n  if (targets.length === 0) {\n    if (!smartMode) {\n      showNotification('No data-gofakeit fields exist. Turn on Smart mode to fill all form fields.', 'info');\n    } else {\n      showNotification('No form fields found to autofill', 'info');\n    }\n    return;\n  }\n\n  console.log(`[Gofakeit] Found ${targets.length} elements to generate data for`);\n  showNotification(`Starting data generation for ${targets.length} fields...`, 'info');\n\n  const results = await processElements(targets, settings);\n  showResults(results.success, results.failed, 'Autofill');\n}\n\n// Autofill all fields within a specific container\nasync function autofillContainer(container: HTMLElement, settings: AutofillSettings): Promise<void> {\n  const elements = queryFormElements(container);\n  const smartMode = settings.smart ?? true;\n\n  // Smart mode: Fill ALL form fields in container (except those explicitly excluded)\n  // Manual mode: Only fill fields with data-gofakeit attributes\n  const targetsBase = smartMode\n    ? elements\n    : elements.filter((el) => (el as Element).hasAttribute('data-gofakeit'));\n  const targets = targetsBase.filter((el) => !isDataGofakeitFalse(el));\n\n  if (targets.length === 0) {\n    if (!smartMode) {\n      showNotification('No data-gofakeit fields exist in this section. Turn on Smart mode to fill all form fields.', 'info');\n    } else {\n      showNotification('No form fields found in this container', 'info');\n    }\n    return;\n  }\n  \n  console.log(`[Gofakeit] Found ${targets.length} elements to generate data for in container`);\n  showNotification(`Starting data generation for ${targets.length} fields...`, 'info');\n  \n  const results = await processElements(targets, settings);\n  showResults(results.success, results.failed, 'Container autofill');\n}\n\n// Main autofill function that routes to specific handlers\nasync function autofillElement(element: Element, settings: AutofillSettings): Promise<boolean> {\n  const gofakeitFunc = element.getAttribute('data-gofakeit');\n  if (typeof gofakeitFunc === 'string' && gofakeitFunc.trim().toLowerCase() === 'false') {\n    return false;\n  }\n  \n  const smartMode = settings.smart ?? true;\n  // Smart mode: Fill any form field (even without data-gofakeit attribute)\n  // Manual mode: Only fill fields that have data-gofakeit attributes\n  if (!gofakeitFunc && !smartMode) {\n    return false;\n  }\n\n  try {\n    // Handle select dropdowns\n    if (element instanceof HTMLSelectElement) {\n      const funcToUse = (gofakeitFunc && gofakeitFunc !== 'true') ? gofakeitFunc : 'true';\n      const { success, usedFunc } = await handleSelectWithFunction(element, funcToUse);\n      if (success) {\n        showFuncBadge(element, usedFunc, settings);\n      }\n      return success;\n    }\n    \n    // Handle textarea elements\n    if (element instanceof HTMLTextAreaElement) {\n      const funcToUse = (gofakeitFunc && gofakeitFunc !== 'true') ? gofakeitFunc : 'sentence';\n      const { success, usedFunc } = await handleTextarea(element, funcToUse);\n      if (success) {\n        showFuncBadge(element, usedFunc, settings);\n      }\n      return success;\n    }\n    \n    // Handle input elements\n    if (element instanceof HTMLInputElement) {\n      const inputType = element.type.toLowerCase();\n      \n      // Handle checkbox inputs\n      if (inputType === 'checkbox') {\n        const passToHandler = (gofakeitFunc && gofakeitFunc !== 'true') ? gofakeitFunc : 'true';\n        const { success, usedFunc } = await handleCheckbox(element, passToHandler);\n        if (success) {\n          showFuncBadge(element, usedFunc, settings);\n        }\n        return success;\n      }\n      \n      // Handle radio inputs\n      if (inputType === 'radio') {\n        const passToHandler = (gofakeitFunc && gofakeitFunc !== 'true') ? gofakeitFunc : 'true';\n        const { success, usedFunc, selectedElement } = await handleRadio(element, passToHandler);\n        if (success) {\n          // Show function badge over the selected radio button, not the original one\n          const elementToShowBadge = selectedElement || element;\n          showFuncBadge(elementToShowBadge, usedFunc, settings);\n        }\n        return success;\n      }\n      \n      // Handle range inputs\n      if (inputType === 'range') {\n        const { success, usedFunc } = await handleRangeInput(element);\n        if (success) {\n          showFuncBadge(element, usedFunc, settings);\n        }\n        return success;\n      }\n      \n      // Handle all other input types (text, email, tel, password, search, url, color, number, date, etc.)\n      const inferred = (gofakeitFunc && gofakeitFunc !== 'true') ? gofakeitFunc : await searchFunctionForInput(element);\n      \n      // Route to appropriate handler based on input type\n      if (inputType === 'number') {\n        const { success, usedFunc } = await handleNumberInput(element, inferred);\n        if (success) {\n          showFuncBadge(element, usedFunc, settings);\n        }\n        return success;\n      }\n      \n      if (inputType === 'date' || inputType === 'time' || inputType === 'datetime-local' || \n          inputType === 'month' || inputType === 'week') {\n        const { success, usedFunc } = await handleDateTimeInput(element, inferred);\n        if (success) {\n          showFuncBadge(element, usedFunc, settings);\n        }\n        return success;\n      }\n      \n      // Handle text inputs (text, email, tel, password, search, url, color, etc.)\n      const { success, usedFunc } = await handleTextInput(element, inferred);\n      if (success) {\n        showFuncBadge(element, usedFunc, settings);\n      }\n      return success;\n    }\n    \n    console.warn('[Gofakeit] Unsupported element type:', element);\n    return false;\n    \n  } catch (error) {\n    console.error('[Gofakeit] Unexpected error generating data for element:', element, error);\n    return false;\n  }\n}\n\n// ============================================================================\n// PROCESSING FUNCTIONS (Called by main functions)\n// ============================================================================\n\n// Query all form elements that can be autofilled\nfunction queryFormElements(container?: HTMLElement): Element[] {\n  const selector = 'input, textarea, select';\n  const nodeList = container ? container.querySelectorAll(selector) : document.querySelectorAll(selector);\n  const elements: Element[] = [];\n  nodeList.forEach((el) => {\n    if (el instanceof HTMLInputElement) {\n      if (el.type === 'hidden' || el.disabled || el.readOnly) return;\n      elements.push(el);\n    } else if (el instanceof HTMLTextAreaElement) {\n      if (el.disabled || el.readOnly) return;\n      elements.push(el);\n    } else if (el instanceof HTMLSelectElement) {\n      if (el.disabled) return;\n      elements.push(el);\n    }\n  });\n  return elements;\n}\n\nfunction isDataGofakeitFalse(el: Element): boolean {\n  const val = (el as Element).getAttribute && (el as Element).getAttribute('data-gofakeit');\n  return typeof val === 'string' && val.trim().toLowerCase() === 'false';\n}\n\n// Get unique elements, handling checkbox and radio groups\nfunction getUniqueElements(elements: Element[]): Element[] {\n  const uniqueElements: Element[] = [];\n  const processedGroups = new Set<string>();\n  \n  for (const element of elements) {\n    if (element instanceof HTMLInputElement) {\n      const inputType = element.type.toLowerCase();\n      \n      if (inputType === 'checkbox' || inputType === 'radio') {\n        const name = element.name;\n        if (name && processedGroups.has(name)) {\n          // Skip if we've already processed this group\n          continue;\n        }\n        if (name) {\n          processedGroups.add(name);\n        }\n      }\n    }\n    \n    uniqueElements.push(element);\n  }\n  \n  return uniqueElements;\n}\n\n// Process multiple elements and track results using batched API calls\nasync function processElements(elements: Element[], settings: AutofillSettings): Promise<{ success: number, failed: number }> {\n  let successfulCount = 0;\n  let failedCount = 0;\n  \n  // Get unique elements to avoid processing checkbox/radio groups multiple times\n  const uniqueElements = getUniqueElements(elements);\n\n  // Separate input elements from other elements\n  const searchInputElements: HTMLInputElement[] = [];\n  const otherElements: Element[] = [];\n  \n  for (const element of uniqueElements) {\n    if (element instanceof HTMLInputElement) {\n      const inputType = element.type.toLowerCase();\n      if (needsSearchApi(inputType)) {\n        searchInputElements.push(element);\n      } else {\n        // For excluded input types, add them to otherElements to be processed by getElementFunction\n        otherElements.push(element);\n      }\n    } else {\n      otherElements.push(element);\n    }\n  }\n\n  // Use search API to get functions for all searchable input elements at once\n  let inputFunctionMap = new Map<HTMLInputElement, string>();\n  if (searchInputElements.length > 0) {\n    try {\n      inputFunctionMap = await searchFunctionsForInputs(searchInputElements);\n    } catch (error) {\n      console.warn('[Gofakeit Autofill] Search API failed, falling back to individual function detection:', error);\n      // Fallback to individual function detection\n      for (const element of searchInputElements) {\n        const func = await getElementFunction(element, settings);\n        if (func) {\n          inputFunctionMap.set(element, func);\n        }\n      }\n    }\n  }\n\n  // Process excluded elements individually (they don't use batch API)\n  const excludedElements: Element[] = [];\n  const batchElements: { element: Element, func: string }[] = [];\n  \n  // Add input elements with their search API functions to batch\n  searchInputElements.forEach(element => {\n    const func = inputFunctionMap.get(element);\n    if (func) {\n      batchElements.push({ element, func });\n    }\n  });\n  \n  // Process other elements (select, textarea, checkbox, radio, etc.)\n  for (const element of otherElements) {\n    try {\n      const func = await getElementFunction(element, settings);\n      if (func) {\n        // Check if this is an excluded type that should be processed individually\n        if (element instanceof HTMLInputElement) {\n          const inputType = element.type.toLowerCase();\n          if (['checkbox', 'radio', 'range', 'file', 'button', 'submit', 'reset', 'image', 'color', 'date', 'time', 'datetime-local', 'month', 'week'].includes(inputType)) {\n            // Process excluded types individually\n            excludedElements.push(element);\n            continue;\n          }\n        }\n        // Add to batch for other types (select, textarea, etc.)\n        batchElements.push({ element, func });\n      }\n    } catch (error) {\n      failedCount++;\n      console.warn(`[Gofakeit Autofill] Failed to get function for element:`, element, error);\n    }\n  }\n\n  // Process excluded elements with appropriate timing\n  const testMode = (globalThis as any).__GOFAKEIT_TEST_MODE__;\n  const staggered = testMode ? false : (settings.staggered ?? true);\n  \n  if (staggered) {\n    // Process excluded elements individually with staggered timing\n    for (let i = 0; i < excludedElements.length; i++) {\n      const element = excludedElements[i];\n      const staggerDelay = settings.staggerDelay ?? 50;\n      \n      if (i > 0) {\n        await new Promise(resolve => setTimeout(resolve, staggerDelay));\n      }\n      \n      try {\n        const success = await autofillElement(element, settings);\n        if (success) {\n          successfulCount++;\n        } else {\n          failedCount++;\n        }\n      } catch (error) {\n        failedCount++;\n        console.warn(`[Gofakeit Autofill] Failed to process excluded element:`, element, error);\n      }\n    }\n  } else {\n    // Process excluded elements all at once for fast mode\n    const promises = excludedElements.map(async (element) => {\n      try {\n        const success = await autofillElement(element, settings);\n        return success;\n      } catch (error) {\n        console.warn(`[Gofakeit Autofill] Failed to process excluded element:`, element, error);\n        return false;\n      }\n    });\n    \n    const results = await Promise.all(promises);\n    results.forEach(success => {\n      if (success) {\n        successfulCount++;\n      } else {\n        failedCount++;\n      }\n    });\n  }\n\n  // Process batch elements if any exist\n  if (batchElements.length === 0) {\n    return { success: successfulCount, failed: failedCount };\n  }\n\n  // Create batch requests\n  const requests: MultiFuncRequest[] = batchElements.map((item, index) => ({\n    id: `req_${index}`,\n    func: item.func\n  }));\n\n  // Make single batch API call\n  const batchResponse = await callMultiFunc(requests);\n  \n  if (!batchResponse.success || !batchResponse.data) {\n    console.error('[Gofakeit Autofill] Batch API call failed:', batchResponse.error);\n    return { success: successfulCount, failed: failedCount + batchElements.length };\n  }\n\n  // Process responses using existing handlers with staggered timing\n  for (let i = 0; i < batchElements.length; i++) {\n    const { element, func } = batchElements[i];\n    const response = batchResponse.data[i];\n    \n    // Add staggered delay for visual effect if enabled\n    const testMode = (globalThis as any).__GOFAKEIT_TEST_MODE__;\n    const staggered = testMode ? false : (settings.staggered ?? true);\n    const staggerDelay = settings.staggerDelay ?? 50;\n    if (staggered && i > 0) {\n      await new Promise(resolve => setTimeout(resolve, staggerDelay));\n    }\n    \n    if (response && response.value !== null && !response.error) {\n      try {\n        // Use the existing autofillElement function with the batch response value\n        const success = await autofillElementWithValue(element, func, response.value, settings);\n        if (success) {\n          successfulCount++;\n          \n          // Monitor if the value gets cleared after a short delay\n          setTimeout(() => {\n            if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n              if (element.value === '') {\n                console.warn('[Gofakeit Autofill] Value was cleared for element:', element);\n              }\n            } else if (element instanceof HTMLSelectElement) {\n              if (element.value === '') {\n                console.warn('[Gofakeit Autofill] Value was cleared for select:', element);\n              }\n            }\n          }, 1000);\n        } else {\n          failedCount++;\n        }\n      } catch (error) {\n        failedCount++;\n        console.warn(`[Gofakeit Autofill] Failed to apply value to element:`, element, error);\n      }\n    } else {\n      failedCount++;\n      console.warn(`[Gofakeit Autofill] API error for element:`, element, response?.error);\n    }\n  }\n\n  return { success: successfulCount, failed: failedCount };\n}\n\n// Get the function name for an element (same logic as autofillElement but returns function name)\nasync function getElementFunction(element: Element, settings: AutofillSettings): Promise<string | null> {\n  const gofakeitFunc = element.getAttribute('data-gofakeit');\n  if (typeof gofakeitFunc === 'string' && gofakeitFunc.trim().toLowerCase() === 'false') {\n    return null;\n  }\n  \n  const smartMode = settings.smart ?? true;\n  if (!gofakeitFunc && !smartMode) {\n    return null;\n  }\n\n  try {\n    // Handle select dropdowns\n    if (element instanceof HTMLSelectElement) {\n      return (gofakeitFunc && gofakeitFunc !== 'true') ? gofakeitFunc : 'word';\n    }\n    \n    // Handle textarea elements\n    if (element instanceof HTMLTextAreaElement) {\n      return getTextarea(gofakeitFunc || 'true');\n    }\n    \n    // Handle input elements\n    if (element instanceof HTMLInputElement) {\n      const inputType = element.type.toLowerCase();\n      \n      // Handle checkbox inputs\n      if (inputType === 'checkbox') {\n        return (gofakeitFunc && gofakeitFunc !== 'true') ? gofakeitFunc : 'bool';\n      }\n      \n      // Handle radio inputs\n      if (inputType === 'radio') {\n        return (gofakeitFunc && gofakeitFunc !== 'true') ? gofakeitFunc : 'true';\n      }\n      \n      // Handle range inputs\n      if (inputType === 'range') {\n        return getRangeInput(element);\n      }\n      \n      // For all other input types, use search API (this is a fallback for individual elements)\n      return await searchFunctionForInput(element);\n    }\n    \n    console.warn('[Gofakeit] Unsupported element type for batching:', element);\n    return null;\n    \n  } catch (error) {\n    console.error('[Gofakeit] Unexpected error getting function for element:', element, error);\n    return null;\n  }\n}\n\n// Show function badge with a slight delay for visual effect\nfunction showFuncBadge(element: Element, func: string, settings?: AutofillSettings): void {\n  const testMode = (globalThis as any).__GOFAKEIT_TEST_MODE__;\n  const staggered = testMode ? false : (settings?.staggered ?? true);\n  const staggerDelay = settings?.staggerDelay ?? 50;\n  \n  // Only delay the badge if staggered is enabled, using the staggerDelay from settings\n  const actualDelay = staggered ? staggerDelay : 0;\n  setTimeout(() => {\n    showFunctionBadge(element, func);\n  }, actualDelay);\n}\n\n// Autofill an element with a pre-fetched value (for batch processing)\nasync function autofillElementWithValue(element: Element, func: string, value: string, settings?: AutofillSettings): Promise<boolean> {\n  try {\n    // Handle select dropdowns\n    if (element instanceof HTMLSelectElement) {\n      const { success, usedFunc } = await handleSelectWithFunction(element, func, value);\n      if (success) {\n        showFuncBadge(element, usedFunc, settings);\n      }\n      return success;\n    }\n    \n    // Handle textarea elements\n    if (element instanceof HTMLTextAreaElement) {\n      setTextarea(element, value);\n      showFuncBadge(element, func, settings);\n      return true;\n    }\n    \n    // Handle input elements\n    if (element instanceof HTMLInputElement) {\n      const inputType = element.type.toLowerCase();\n      \n      // Handle checkbox inputs\n      if (inputType === 'checkbox') {\n        const { success, usedFunc } = await handleCheckbox(element, func, value);\n        if (success) {\n          showFuncBadge(element, usedFunc, settings);\n        }\n        return success;\n      }\n      \n      // Handle radio inputs\n      if (inputType === 'radio') {\n        const { success, usedFunc } = await handleRadio(element, func, value);\n        if (success) {\n          showFuncBadge(element, usedFunc, settings);\n        }\n        return success;\n      }\n      \n      // Handle number inputs\n      if (inputType === 'number') {\n        setNumberInput(element, value);\n        showFuncBadge(element, func, settings);\n        return true;\n      }\n      \n      // Handle range inputs\n      if (inputType === 'range') {\n        setRangeInput(element, value);\n        showFuncBadge(element, func, settings);\n        return true;\n      }\n      \n      // Handle date/time inputs\n      if (inputType === 'date' || inputType === 'time' || inputType === 'datetime-local' || \n          inputType === 'month' || inputType === 'week') {\n        const { success, usedFunc } = await handleDateTimeInput(element, func, value);\n        if (success) {\n          showFuncBadge(element, usedFunc, settings);\n        }\n        return success;\n      }\n      \n      // Handle text inputs (text, email, tel, password, search, url, color, etc.)\n      setTextInput(element, value);\n      showFuncBadge(element, func, settings);\n      return true;\n    }\n    \n    console.warn('[Gofakeit] Unsupported element type:', element);\n    return false;\n    \n  } catch (error) {\n    console.error('[Gofakeit] Unexpected error generating data for element:', element, error);\n    return false;\n  }\n}\n\n// Show results notification\nfunction showResults(successfulCount: number, failedCount: number, context: string): void {\n  // Show successful count notification\n  if (successfulCount > 0) {\n    console.log(`[Gofakeit] ${context} completed successfully for ${successfulCount} fields`);\n    showNotification(`Successfully generated data for ${successfulCount} fields!`, 'success');\n  }\n  \n  // Show failed count notification\n  if (failedCount > 0) {\n    console.error(`[Gofakeit] ${context} failed for ${failedCount} fields`);\n    showNotification(`Failed to generate data for ${failedCount} fields.`, 'error');\n  }\n  \n  // If no fields were processed at all\n  if (successfulCount === 0 && failedCount === 0) {\n    console.log(`[Gofakeit] ${context} - no fields were processed`);\n    showNotification(`No fields were processed.`, 'info');\n  }\n}\n\n// ============================================================================\n// UTILITY FUNCTIONS (Called by various functions)\n// ============================================================================\n\n// Handle error display and field highlighting\nexport function handleError(element: Element, error: string, functionName?: string): void {\n  if (element instanceof HTMLElement) {\n    element.style.border = `2px solid ${GOFAKEIT_COLORS.error}`;\n    \n    setTimeout(() => {\n      element.style.border = '';\n    }, 5000);\n  }\n  \n  const message = functionName ? `Invalid function: ${functionName}` : error;\n  showFieldError(element, message);\n}\n\n// Check if an element contains form fields with data-gofakeit attributes\nexport function hasFormFields(element: HTMLElement): boolean {\n  const formFields = element.querySelectorAll('input[data-gofakeit], textarea[data-gofakeit], select[data-gofakeit]');\n  return formFields.length > 0;\n}\n\n// Check if an element is a form field with data-gofakeit attribute\nexport function isFormField(element: HTMLElement): boolean {\n  return (\n    (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA' || element.tagName === 'SELECT') &&\n    element.hasAttribute('data-gofakeit')\n  );\n}\n\n// Global tracking of active function badges\nconst activeBadges = new Map<Element, { badge: HTMLElement; timeout: ReturnType<typeof setTimeout>; cleanup: () => void }>();\n\n// Remove existing badges for a specific element\nfunction removeExistingBadges(element: Element): void {\n  // For radio buttons, remove badges for all radio buttons in the same group\n  if (element instanceof HTMLInputElement && element.type === 'radio' && element.name) {\n    const radioGroup = document.querySelectorAll(`input[type=\"radio\"][name=\"${element.name}\"]`);\n    radioGroup.forEach(radio => {\n      const existing = activeBadges.get(radio);\n      if (existing) {\n        clearTimeout(existing.timeout);\n        existing.cleanup();\n        activeBadges.delete(radio);\n      }\n    });\n  } else {\n    // For other elements, just remove the badge for this specific element\n    const existing = activeBadges.get(element);\n    if (existing) {\n      clearTimeout(existing.timeout);\n      existing.cleanup();\n      activeBadges.delete(element);\n    }\n  }\n}\n\n// Display a small badge showing the function used for this field\nexport function showFunctionBadge(element: Element, funcName: string): void {\n  if (!(element instanceof HTMLElement)) return;\n\n  // Remove any existing badges for this element\n  removeExistingBadges(element);\n\n  const badge = document.createElement('div');\n  badge.textContent = funcName;\n  badge.style.position = 'fixed';\n  badge.style.background = GOFAKEIT_COLORS.primary;\n  badge.style.color = '#000';\n  badge.style.fontFamily = 'Arial, sans-serif';\n  badge.style.fontSize = '11px';\n  badge.style.padding = '3px 8px';\n  badge.style.borderRadius = '6px';\n  badge.style.boxShadow = '0 2px 6px rgba(0,0,0,0.25)';\n  badge.style.zIndex = '2147483647';\n  badge.style.opacity = '0';\n  badge.style.transform = 'translateY(-6px)';\n  badge.style.transition = 'opacity 200ms ease, transform 200ms ease';\n  badge.style.pointerEvents = 'none';\n\n  const updatePosition = () => {\n    const rect = element.getBoundingClientRect();\n    const vh = window.innerHeight || document.documentElement.clientHeight;\n    const vw = window.innerWidth || document.documentElement.clientWidth;\n\n    // If the element is completely out of the viewport, hide the badge entirely\n    const outOfView = rect.bottom <= 0 || rect.top >= vh || rect.right <= 0 || rect.left >= vw;\n    if (outOfView) {\n      badge.style.display = 'none';\n      return;\n    }\n\n    // Otherwise, ensure it's visible and position above-left of the field\n    if (badge.style.display === 'none') badge.style.display = 'block';\n    const top = rect.top - 8;\n    const left = rect.left;\n    badge.style.top = `${top}px`;\n    badge.style.left = `${left}px`;\n  };\n\n  document.body.appendChild(badge);\n  updatePosition();\n\n  // Animate in\n  requestAnimationFrame(() => {\n    badge.style.opacity = '1';\n    badge.style.transform = 'translateY(-12px)';\n  });\n\n  // Track movement while visible\n  const onScroll = () => updatePosition();\n  const onResize = () => updatePosition();\n  window.addEventListener('scroll', onScroll, true);\n  window.addEventListener('resize', onResize, true);\n\n  // Observe element size/position changes\n  let ro: ResizeObserver | null = null;\n  if (typeof ResizeObserver !== 'undefined') {\n    ro = new ResizeObserver(() => updatePosition());\n    try { ro.observe(element); } catch { /* ignore */ }\n  }\n\n  // Create cleanup function\n  const cleanup = () => {\n    window.removeEventListener('scroll', onScroll, true);\n    window.removeEventListener('resize', onResize, true);\n    if (ro) {\n      try { ro.disconnect(); } catch { /* ignore */ }\n      ro = null;\n    }\n    if (badge.parentNode) badge.parentNode.removeChild(badge);\n    activeBadges.delete(element);\n  };\n\n  // Animate out and remove after extended delay\n  const DISPLAY_MS = 6000;\n  const timeout = setTimeout(() => {\n    badge.style.opacity = '0';\n    badge.style.transform = 'translateY(-6px)';\n    setTimeout(cleanup, 220);\n  }, DISPLAY_MS);\n\n  // Track this badge\n  activeBadges.set(element, { badge, timeout, cleanup });\n}\n\n// Extract nearby/associated label text for context\nfunction getAssociatedLabelText(input: HTMLInputElement): string {\n  const texts: string[] = [];\n  const id = input.id;\n  // aria-labelledby\n  const labelledBy = input.getAttribute('aria-labelledby');\n  if (labelledBy) {\n    labelledBy.split(/\\s+/).forEach((ref) => {\n      const el = document.getElementById(ref);\n      if (el && el.textContent) texts.push(el.textContent);\n    });\n  }\n  // explicit label[for]\n  if (id) {\n    try {\n      const lbl = document.querySelector('label[for=\"' + id.replace(/\"/g, '\\\\\"') + '\"]') as HTMLLabelElement | null;\n      if (lbl && lbl.textContent) texts.push(lbl.textContent);\n    } catch { /* ignore */ }\n  }\n  // implicit parent label\n  const closestLabel = input.closest('label');\n  if (closestLabel && closestLabel.textContent) texts.push(closestLabel.textContent);\n  // previous sibling label (common in some UIs)\n  const prev = input.previousElementSibling as HTMLElement | null;\n  if (prev && prev.tagName === 'LABEL' && prev.textContent) texts.push(prev.textContent);\n  return texts.join(' ').toLowerCase();\n}\n\n// Determine if an input type needs search API for function detection\nfunction needsSearchApi(inputType: string): boolean {\n  // These input types have their own specific handling and don't need search API\n  const skipSearchTypes = ['checkbox', 'radio', 'select', 'range', 'file', 'button', 'submit', 'reset', 'image', 'color', 'week', 'date', 'time', 'datetime-local', 'month'];\n  return !skipSearchTypes.includes(inputType);\n}\n\n// Get a default function for input types that don't need search API\nexport function getDefaultFunctionForInputType(inputType: string): string {\n  switch (inputType) {\n    case 'checkbox':\n    case 'radio':\n    case 'select':\n      return 'true';\n    case 'range':\n      return 'number?min=0&max=100';\n    case 'file':\n      return 'word';\n    case 'button':\n    case 'submit':\n    case 'reset':\n    case 'image':\n      return 'word';\n    case 'color':\n      return 'hexcolor';\n    case 'week':\n      return 'generateWeek';\n    case 'date':\n      return 'generateDate';\n    case 'time':\n      return 'generateTime';\n    case 'datetime-local':\n      return 'generateDateTime';\n    case 'month':\n      return 'generateMonth';\n    default:\n      return 'word';\n  }\n}\n\n// Get type-specific fallback functions for when search API doesn't find good matches\nfunction getTypeSpecificFallback(inputType: string): string {\n  switch (inputType) {\n    case 'email':\n      return 'email';\n    case 'tel':\n      return 'phone';\n    case 'number':\n      return 'number';\n    case 'date':\n      return 'date';\n    case 'time':\n      return 'time';\n    case 'datetime-local':\n      return 'datetime';\n    case 'month':\n      return 'month';\n    case 'week':\n      return 'week';\n    case 'url':\n      return 'url';\n    case 'password':\n      return 'password';\n    case 'search':\n      return 'word';\n    case 'color':\n      return 'color';\n    case 'text':\n    default:\n      return 'word';\n  }\n}\n\n// Create a comprehensive search query from input field characteristics\nfunction createSearchQuery(input: HTMLInputElement): string {\n  const type = input.type.toLowerCase();\n  const name = (input.name || '').toLowerCase();\n  const id = (input.id || '').toLowerCase();\n  const placeholder = (input.placeholder || '').toLowerCase();\n  const autocomplete = (input.autocomplete || '').toLowerCase();\n  const ariaLabel = (input.getAttribute('aria-label') || '').toLowerCase();\n  const labelText = getAssociatedLabelText(input);\n\n  // Build a comprehensive search query with all available information\n  const queryParts = [\n    type,\n    name,\n    id,\n    placeholder,\n    autocomplete,\n    ariaLabel,\n    labelText\n  ].filter(part => part && part.trim());\n\n  // Join all parts with spaces to create a comprehensive search query\n  const searchQuery = queryParts.join(' ').toLowerCase()\n    .replace(/[^\\w\\s]/g, ' ') // Remove special characters\n    .replace(/\\s+/g, ' ') // Normalize whitespace\n    .trim();\n\n  return searchQuery || 'text input';\n}\n\n// Search for functions using the API endpoint based on input field characteristics\nasync function searchFunctionForInput(input: HTMLInputElement): Promise<string> {\n  const type = input.type.toLowerCase();\n  \n  // Skip search API for input types that don't need it\n  if (!needsSearchApi(type)) {\n    return getDefaultFunctionForInputType(type);\n  }\n\n  const searchQuery = createSearchQuery(input);\n\n  try {\n    const searchRequest: FuncSearchRequest = {\n      id: input.id || input.name || `input_${Date.now()}`,\n      query: searchQuery\n    };\n\n    const response = await searchMultiFunc([searchRequest]);\n    \n    if (response.success && response.data && response.data.length > 0) {\n      const searchResult = response.data[0];\n      if (searchResult.results && searchResult.results.length > 0) {\n        // Return the highest scoring function\n        const bestMatch = searchResult.results[0];\n        return bestMatch.name;\n      }\n    }\n  } catch (error) {\n    console.warn('[Gofakeit] Function search failed, falling back to default function:', error);\n  }\n\n  // Fallback to default function if search fails\n  return getDefaultFunctionForInputType(type);\n}\n\n// Search for functions for multiple inputs using the API endpoint\nexport async function searchFunctionsForInputs(inputs: HTMLInputElement[]): Promise<Map<HTMLInputElement, string>> {\n  const functionMap = new Map<HTMLInputElement, string>();\n  \n  if (inputs.length === 0) {\n    return functionMap;\n  }\n\n  try {\n    // Create search requests for all inputs using the shared createSearchQuery function\n    const searchRequests: FuncSearchRequest[] = inputs.map((input, index) => {\n      const searchQuery = createSearchQuery(input);\n      \n      return {\n        id: input.id || input.name || `input_${index}`,\n        query: searchQuery\n      };\n    });\n\n    const response = await searchMultiFunc(searchRequests);\n    \n    if (response.success && response.data) {\n      // Map results back to inputs with improved fallback logic\n      for (let i = 0; i < response.data.length; i++) {\n        const searchResult = response.data[i];\n        const input = inputs[i];\n        const inputType = input.type.toLowerCase();\n        \n        if (searchResult.results && searchResult.results.length > 0) {\n          const bestMatch = searchResult.results[0];\n          // Only use the search result if it has a reasonable score\n          if (bestMatch.score >= 100) {\n            functionMap.set(input, bestMatch.name);\n          } else {\n            // Use type-specific fallback for low-scoring results\n            functionMap.set(input, getTypeSpecificFallback(inputType));\n          }\n        } else {\n          // Fallback to type-specific function if no search results\n          functionMap.set(input, getTypeSpecificFallback(inputType));\n        }\n      }\n    } else {\n      // Fallback to default functions for all inputs if search fails\n      for (const input of inputs) {\n        functionMap.set(input, getDefaultFunctionForInputType(input.type.toLowerCase()));\n      }\n    }\n  } catch (error) {\n    console.warn('[Gofakeit] Multi-function search failed, falling back to default functions:', error);\n    // Fallback to default functions for all inputs\n    for (const input of inputs) {\n      functionMap.set(input, getDefaultFunctionForInputType(input.type.toLowerCase()));\n    }\n  }\n\n  return functionMap;\n}\n\n// Find the closest container that has form fields with data-gofakeit attributes\nexport function findFormContainer(element: HTMLElement): HTMLElement | null {\n  // Check if the current element has form fields\n  if (hasFormFields(element)) {\n    return element;\n  }\n  \n  // Check parent elements\n  let parent = element.parentElement;\n  while (parent) {\n    if (hasFormFields(parent)) {\n      return parent;\n    }\n    parent = parent.parentElement;\n  }\n  \n  return null;\n}\n\n// Simple notification function (can be overridden by the consuming application)\nfunction showNotification(message: string, type: 'success' | 'error' | 'info' = 'info'): void {\n  console.log(`[Gofakeit ${type.toUpperCase()}] ${message}`);\n}\n","\n      import { autofill } from \"./src/index.ts\";\n\n      // Make functions available globally\n      window.autofill = async (target) => {\n        try {\n          // Get current settings\n          const settings = getCurrentSettings();\n\n          if (target) {\n            // If target is a string, treat it as an element ID\n            if (typeof target === \"string\") {\n              const element = document.getElementById(target);\n              if (!element) {\n                showStatus(\"❌ Element not found: \" + target, \"error\");\n                return;\n              }\n\n              // Scroll to the section\n              element.scrollIntoView({ behavior: \"smooth\", block: \"start\" });\n\n              // Wait a moment for the scroll to complete, then autofill\n              setTimeout(async () => {\n                await autofill(element, settings);\n                showStatus(\n                  `✅ ${target} section filled successfully!`,\n                  \"success\"\n                );\n              }, 500);\n            } else {\n              await autofill(target, settings);\n              showStatus(\"✅ Element filled successfully!\", \"success\");\n            }\n          } else {\n            // No target - autofill all\n            await autofill(undefined, settings);\n            showStatus(\"✅ All fields filled successfully!\", \"success\");\n          }\n        } catch (error) {\n          showStatus(\"❌ Error filling fields: \" + error.message, \"error\");\n        }\n      };\n\n      // Function to autofill a specific category\n      window.autofillCategory = async () => {\n        const selector = document.getElementById(\"categorySelector\");\n        const selectedCategory = selector.value;\n\n        if (!selectedCategory) {\n          showStatus(\"❌ Please select a category first!\", \"error\");\n          return;\n        }\n\n        try {\n          // Map category values to the actual section IDs and field selectors\n          const categoryMap = {\n            \"person-category\": {\n              section: \"categories\",\n            },\n            \"address-category\": {\n              section: \"categories\",\n            },\n            \"company-category\": {\n              section: \"categories\",\n            },\n            \"payment-category\": {\n              section: \"categories\",\n            },\n            \"internet-category\": {\n              section: \"categories\",\n            },\n            \"time-category\": {\n              section: \"categories\",\n            },\n            \"language-category\": {\n              section: \"categories\",\n            },\n            \"word-category\": {\n              section: \"categories\",\n            },\n            \"color-category\": {\n              section: \"categories\",\n            },\n            \"animal-category\": {\n              section: \"categories\",\n            },\n            \"food-category\": {\n              section: \"categories\",\n            },\n            \"car-category\": {\n              section: \"categories\",\n            },\n            \"game-category\": {\n              section: \"categories\",\n            },\n            \"misc-category\": {\n              section: \"categories\",\n            },\n          };\n\n          const category = categoryMap[selectedCategory];\n          if (!category) {\n            showStatus(\"❌ Invalid category selected!\", \"error\");\n            return;\n          }\n\n          // Map category values to their heading text\n          const categoryHeadingMap = {\n            \"person-category\": \"👤 Person Category\",\n            \"address-category\": \"🏠 Address Category\",\n            \"company-category\": \"🏢 Company Category\",\n            \"payment-category\": \"💳 Payment Category\",\n            \"internet-category\": \"🌐 Internet Category\",\n            \"time-category\": \"⏰ Time Category\",\n            \"language-category\": \"🗣️ Language Category\",\n            \"word-category\": \"📝 Word Category\",\n            \"color-category\": \"🎨 Color Category\",\n            \"animal-category\": \"🐾 Animal Category\",\n            \"food-category\": \"🍕 Food Category\",\n            \"car-category\": \"🚗 Car Category\",\n            \"game-category\": \"🎮 Game Category\",\n            \"misc-category\": \"🎲 Misc Category\",\n          };\n\n          // Find the specific category heading by text content\n          const headingText = categoryHeadingMap[selectedCategory];\n          let categoryHeading = null;\n          if (headingText) {\n            const allHeadings = document.querySelectorAll(\"h4\");\n            for (const heading of allHeadings) {\n              if (heading.textContent?.includes(headingText)) {\n                categoryHeading = heading;\n                break;\n              }\n            }\n          }\n\n          if (categoryHeading) {\n            categoryHeading.scrollIntoView({\n              behavior: \"smooth\",\n              block: \"start\",\n            });\n          } else {\n            // Fallback: scroll to the categories section\n            const section = document.getElementById(category.section);\n            if (section) {\n              section.scrollIntoView({ behavior: \"smooth\", block: \"start\" });\n            }\n          }\n\n          // Wait a moment for the scroll to complete, then autofill the specific fields\n          setTimeout(async () => {\n            // Find the category container\n            const categoryContainer = document.getElementById(selectedCategory);\n            if (!categoryContainer) {\n              showStatus(\"❌ Category container not found!\", \"error\");\n              return;\n            }\n\n            try {\n              // Get current settings\n              const settings = getCurrentSettings();\n\n              // Use the main autofill function with the category container\n              await autofill(categoryContainer, settings);\n\n              // Count filled elements\n              let filledCount = 0;\n              const inputs = categoryContainer.querySelectorAll(\n                \"input, textarea, select\"\n              );\n              inputs.forEach((element) => {\n                if (element instanceof HTMLInputElement) {\n                  if (element.type === \"checkbox\" || element.type === \"radio\") {\n                    if (element.checked) filledCount++;\n                  } else if (element.value) {\n                    filledCount++;\n                  }\n                } else if (\n                  element instanceof HTMLTextAreaElement ||\n                  element instanceof HTMLSelectElement\n                ) {\n                  if (element.value) filledCount++;\n                }\n              });\n\n              const categoryName =\n                selector.options[selector.selectedIndex].text;\n              showStatus(\n                `✅ ${categoryName} filled successfully! (${filledCount} fields)`,\n                \"success\"\n              );\n            } catch (error) {\n              console.warn(\"Failed to fill category:\", error);\n              showStatus(\n                \"❌ Error filling category: \" + error.message,\n                \"error\"\n              );\n            }\n          }, 500);\n        } catch (error) {\n          showStatus(\"❌ Error filling category: \" + error.message, \"error\");\n        }\n      };\n\n      // Function to get current settings from the UI controls\n      function getCurrentSettings() {\n        const smartMode = document.getElementById(\"smartMode\").checked;\n        const staggeredMode = document.getElementById(\"staggeredMode\").checked;\n        const staggerDelay = parseInt(\n          document.getElementById(\"staggerDelay\").value\n        );\n\n        return {\n          smart: smartMode,\n          staggered: staggeredMode,\n          staggerDelay: staggerDelay,\n        };\n      }\n\n      // Function to autofill with current settings\n      window.autofillWithCurrentSettings = async () => {\n        try {\n          const settings = getCurrentSettings();\n          await autofill(undefined, settings);\n\n          const modeText = settings.smart ? \"Smart Mode\" : \"Manual Mode\";\n          const staggerText = settings.staggered\n            ? ` (${settings.staggerDelay}ms delay)`\n            : \" (no stagger)\";\n          showStatus(\n            `✅ All fields filled with ${modeText}${staggerText}!`,\n            \"success\"\n          );\n        } catch (error) {\n          showStatus(\"❌ Error filling fields: \" + error.message, \"error\");\n        }\n      };\n\n      // Update stagger delay value display and handle theme toggle\n      document.addEventListener(\"DOMContentLoaded\", function () {\n        const staggerDelay = document.getElementById(\"staggerDelay\");\n        const staggerDelayValue = document.getElementById(\"staggerDelayValue\");\n        const themeToggle = document.getElementById(\"themeToggle\");\n        const themeIcon = themeToggle.querySelector(\".theme-icon\");\n\n        if (staggerDelay && staggerDelayValue) {\n          staggerDelay.addEventListener(\"input\", function () {\n            staggerDelayValue.textContent = this.value;\n          });\n        }\n\n        // Handle theme toggle\n        if (themeToggle) {\n          // Get user's saved preference or system preference\n          const savedTheme = localStorage.getItem(\"theme\");\n          const systemPrefersDark = window.matchMedia(\n            \"(prefers-color-scheme: dark)\"\n          ).matches;\n\n          // Use saved preference if available, otherwise use system preference\n          const shouldUseDark =\n            savedTheme === \"dark\" || (savedTheme === null && systemPrefersDark);\n\n          if (shouldUseDark) {\n            document.documentElement.setAttribute(\"data-theme\", \"dark\");\n            themeIcon.textContent = \"☀️\";\n          } else {\n            themeIcon.textContent = \"🌙\";\n          }\n\n          themeToggle.addEventListener(\"click\", function () {\n            const isDark = document.documentElement.hasAttribute(\"data-theme\");\n\n            if (isDark) {\n              // Switch to light mode\n              document.documentElement.removeAttribute(\"data-theme\");\n              localStorage.setItem(\"theme\", \"light\");\n              themeIcon.textContent = \"🌙\";\n            } else {\n              // Switch to dark mode\n              document.documentElement.setAttribute(\"data-theme\", \"dark\");\n              localStorage.setItem(\"theme\", \"dark\");\n              themeIcon.textContent = \"☀️\";\n            }\n          });\n\n          // Listen for system preference changes\n          window\n            .matchMedia(\"(prefers-color-scheme: dark)\")\n            .addEventListener(\"change\", function (e) {\n              // Only update if user hasn't set a preference\n              if (localStorage.getItem(\"theme\") === null) {\n                if (e.matches) {\n                  document.documentElement.setAttribute(\"data-theme\", \"dark\");\n                  themeIcon.textContent = \"☀️\";\n                } else {\n                  document.documentElement.removeAttribute(\"data-theme\");\n                  themeIcon.textContent = \"🌙\";\n                }\n              }\n            });\n        }\n      });\n\n      window.clearAll = () => {\n        const inputs = document.querySelectorAll(\"input, textarea, select\");\n        inputs.forEach((input) => {\n          if (input.type === \"checkbox\" || input.type === \"radio\") {\n            input.checked = false;\n          } else {\n            input.value = \"\";\n          }\n        });\n        showStatus(\"🧹 All fields cleared!\", \"success\");\n      };\n\n      function showStatus(message, type) {\n        const status = document.getElementById(\"status\");\n        status.textContent = message;\n        status.className = `status ${type} show`;\n\n        setTimeout(() => {\n          status.classList.remove(\"show\");\n        }, 3000);\n      }\n\n      // Initialize the page\n      console.log(\"🎯 Gofakeit Autofill Comprehensive Testing loaded!\");\n      console.log(\n        \"This page tests the search API with various input contexts and categories.\"\n      );\n      console.log(\n        \"Check the browser network tab to see search API calls in action!\"\n      );\n    "],"names":["GOFAKEIT_COLORS","GOFAKEIT_SPACING","GOFAKEIT_BORDER","GOFAKEIT_FONT","showFieldError","element","message","existingError","tooltip","updateTooltipPosition","rect","scrollTop","scrollLeft","left","top","scrollHandler","resizeHandler","scrollableElements","scrollableListeners","el","style","listener","handler","GOFAKEIT_API_BASE","callFunc","func","questionMarkIndex","functionName","queryString","params","searchParams","key","value","numValue","makeRequest","callMultiFunc","requests","processedRequests","req","index","id","makeMultiRequest","searchMultiFunc","makeSearchRequest","method","url","body","options","response","error","getDateTimeInput","gofakeitFunc","inputType","setDateTimeInput","generateTime","hour","minute","generateMonth","year","month","generateDate","day","generateDateTime","generateWeek","weekYearResponse","weekResponse","week","getISOWeek","date","d","week1","handleDateTimeInput","functionToCall","finalValue","handleError","fallbackFunc","getDefaultFunctionForInputType","fallbackResponse","dateMatch","datetimeMatch","getTextInput","setTextInput","handleTextInput","getTextarea","setTextarea","handleTextarea","handleCheckbox","checkboxGroup","findCheckboxGroup","cb","numToSelect","selectedIndices","i","boolResponse","availableIndices","_","randomIndex","values","v","shouldCheck","handleRadio","radioGroup","findRadioGroup","rb","selectedRadio","name","container","handleSelectWithFunction","option","val","opt","validOptions","randomOption","selectedValues","remainingOptions","getNumberInput","setNumberInput","handleNumberInput","getRangeInput","min","max","setRangeInput","clampedValue","handleRangeInput","autofill","target","settings","finalSettings","autofillAll","hasFormFields","autofillContainer","success","autofillElement","showNotification","findFormContainer","elements","queryFormElements","smartMode","targets","isDataGofakeitFalse","results","processElements","showResults","funcToUse","usedFunc","showFuncBadge","passToHandler","selectedElement","inferred","searchFunctionForInput","selector","nodeList","getUniqueElements","uniqueElements","processedGroups","successfulCount","failedCount","searchInputElements","otherElements","needsSearchApi","inputFunctionMap","searchFunctionsForInputs","getElementFunction","excludedElements","batchElements","staggerDelay","resolve","promises","item","batchResponse","staggered","autofillElementWithValue","showFunctionBadge","context","activeBadges","removeExistingBadges","radio","existing","funcName","badge","updatePosition","vh","vw","onScroll","onResize","ro","cleanup","timeout","getAssociatedLabelText","input","texts","labelledBy","ref","lbl","closestLabel","prev","getTypeSpecificFallback","createSearchQuery","type","placeholder","autocomplete","ariaLabel","labelText","part","searchQuery","searchRequest","searchResult","inputs","functionMap","searchRequests","bestMatch","parent","getCurrentSettings","showStatus","selectedCategory","category","headingText","categoryHeading","allHeadings","heading","section","categoryContainer","filledCount","categoryName","staggeredMode","modeText","staggerText","staggerDelayValue","themeToggle","themeIcon","savedTheme","systemPrefersDark","e","status"],"mappings":"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"}