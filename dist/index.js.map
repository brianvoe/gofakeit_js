{"version":3,"file":"index.js","sources":["../src/api.ts","../src/autofill.ts","../index.html?html-proxy&index=1.js"],"sourcesContent":["// Base URL for the Gofakeit API\nconst GOFAKEIT_API_BASE = 'https://api.gofakeit.com/funcs'\n\nexport interface ApiResponse {\n  success: boolean;\n  data?: string;\n  error?: string;\n  status?: number;\n}\n\n// Multi-function request interface\nexport interface MultiFuncRequest {\n  id?: string;\n  func: string;\n  params?: Record<string, unknown>;\n}\n\n// Multi-function response interface\nexport interface MultiFuncResponse {\n  id?: string;\n  value: string | null;\n  error: string;\n}\n\n// Multi-function API response interface\nexport interface MultiFuncApiResponse {\n  success: boolean;\n  data?: MultiFuncResponse[];\n  error?: string;\n  status?: number;\n}\n\n// Function search request interface\nexport interface FuncSearchRequest {\n  id: string;\n  query: string;\n}\n\n// Function search result interface\nexport interface FuncSearchResult {\n  name: string;     // function name for API usage\n  score: number;    // relevance score (0-100)\n  reasons: string[]; // why it matched\n}\n\n// Function search response interface\nexport interface FuncSearchResponse {\n  id: string;\n  query: string;\n  results: FuncSearchResult[];\n}\n\n// Multi-function search API response interface\nexport interface MultiFuncSearchApiResponse {\n  success: boolean;\n  data?: FuncSearchResponse[];\n  error?: string;\n  status?: number;\n}\n\n// Fetch data from gofakeit API\nexport async function callFunc(func: string): Promise<ApiResponse> {\n  // Check if the function contains query parameters\n  const questionMarkIndex = func.indexOf('?');\n  \n  if (questionMarkIndex !== -1) {\n    // Function has query parameters - use POST with JSON body\n    const functionName = func.substring(0, questionMarkIndex);\n    const queryString = func.substring(questionMarkIndex + 1);\n    \n    // Parse query parameters into an object\n    const params: Record<string, unknown> = {};\n    const searchParams = new URLSearchParams(queryString);\n    \n    for (const [key, value] of searchParams.entries()) {\n      // Try to parse as number if possible\n      const numValue = parseFloat(value);\n      params[key] = isNaN(numValue) ? value : numValue;\n    }\n    \n    return makeRequest('POST', `${GOFAKEIT_API_BASE}/${functionName}`, params);\n  } else {\n    // Simple function - use GET request\n    return makeRequest('GET', `${GOFAKEIT_API_BASE}/${func}`);\n  }\n}\n\n// Call multiple functions in a single request\nexport async function callMultiFunc(requests: MultiFuncRequest[]): Promise<MultiFuncApiResponse> {\n  if (requests.length === 0) {\n    return {\n      success: false,\n      error: 'No functions provided'\n    };\n  }\n\n  // Process each request to extract function name and parameters\n  const processedRequests: MultiFuncRequest[] = requests.map((req, index) => {\n    const { func, id } = req;\n    const questionMarkIndex = func.indexOf('?');\n    \n    if (questionMarkIndex !== -1) {\n      // Function has query parameters\n      const functionName = func.substring(0, questionMarkIndex);\n      const queryString = func.substring(questionMarkIndex + 1);\n      \n      // Parse query parameters into an object\n      const params: Record<string, unknown> = {};\n      const searchParams = new URLSearchParams(queryString);\n      \n      for (const [key, value] of searchParams.entries()) {\n        // Try to parse as number if possible\n        const numValue = parseFloat(value);\n        params[key] = isNaN(numValue) ? value : numValue;\n      }\n      \n      return {\n        id: id || `req_${index}`,\n        func: functionName,\n        params\n      };\n    } else {\n      // Simple function\n      return {\n        id: id || `req_${index}`,\n        func,\n        params: req.params\n      };\n    }\n  });\n\n  return makeMultiRequest('POST', `${GOFAKEIT_API_BASE}/multi`, processedRequests);\n}\n\n// Search for multiple functions in a single request\nexport async function searchMultiFunc(requests: FuncSearchRequest[]): Promise<MultiFuncSearchApiResponse> {\n  if (requests.length === 0) {\n    return {\n      success: false,\n      error: 'No search queries provided'\n    };\n  }\n\n  return makeSearchRequest('POST', `${GOFAKEIT_API_BASE}/search`, requests);\n}\n\n// Base HTTP request function\nasync function makeRequest(method: 'GET' | 'POST', url: string, body?: Record<string, unknown>): Promise<ApiResponse> {\n  try {\n    const options: {\n      method: string;\n      headers: Record<string, string>;\n      body?: string;\n    } = {\n      method: method,\n      headers: {\n        'Content-Type': 'application/json',\n      }\n    };\n\n    if (method === 'POST' && body) {\n      options.body = JSON.stringify(body);\n    }\n\n    const response = await fetch(url, options);\n    \n    if (!response.ok) {\n      return {\n        success: false,\n        error: `HTTP error! status: ${response.status}`,\n        status: response.status\n      };\n    }\n    \n    const data = await response.text();\n    return {\n      success: true,\n      data: data\n    };\n  } catch (error) {\n    console.error(`[Gofakeit Autofill] Error in ${method} request to ${url}:`, error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error'\n    };\n  }\n}\n\n// Multi-function HTTP request function\nasync function makeMultiRequest(method: 'GET' | 'POST', url: string, body: MultiFuncRequest[]): Promise<MultiFuncApiResponse> {\n  try {\n    const options: {\n      method: string;\n      headers: Record<string, string>;\n      body: string;\n    } = {\n      method: method,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(body)\n    };\n\n    const response = await fetch(url, options);\n    \n    if (!response.ok) {\n      return {\n        success: false,\n        error: `HTTP error! status: ${response.status}`,\n        status: response.status\n      };\n    }\n    \n    const data = await response.json();\n    return {\n      success: true,\n      data: data\n    };\n  } catch (error) {\n    console.error(`[Gofakeit Autofill] Error in ${method} request to ${url}:`, error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error'\n    };\n  }\n}\n\n// Multi-function search HTTP request function\nasync function makeSearchRequest(method: 'GET' | 'POST', url: string, body: FuncSearchRequest[]): Promise<MultiFuncSearchApiResponse> {\n  try {\n    const options: {\n      method: string;\n      headers: Record<string, string>;\n      body: string;\n    } = {\n      method: method,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(body)\n    };\n\n    const response = await fetch(url, options);\n    \n    if (!response.ok) {\n      return {\n        success: false,\n        error: `HTTP error! status: ${response.status}`,\n        status: response.status\n      };\n    }\n    \n    const data = await response.json();\n    return {\n      success: true,\n      data: data\n    };\n  } catch (error) {\n    console.error(`[Gofakeit Autofill] Error in ${method} request to ${url}:`, error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error'\n    };\n  }\n}\n","import { callMultiFunc, MultiFuncRequest, searchMultiFunc, FuncSearchRequest } from './api';\n\nexport interface AutofillSettings {\n  mode?: 'auto' | 'manual';\n  staggered?: boolean;\n  staggerDelay?: number;\n  onStatusChange?: (status: string, state: AutofillState) => void;\n}\n\nexport interface AutofillState {\n  status: string;\n  inputs: AutofillElement[];\n}\n\nexport interface AutofillElement {\n  element: Element; // element to autofill\n  type: string;     // input type\n  function: string; // function that will be used to autofill the input\n  value: string;    // value of the autofill result\n  error: string;    // error message\n}\n\nexport interface GetElementsResult {\n  elements: Element[];\n  error?: string;\n}\n\nexport class Autofill {\n  public settings: AutofillSettings;\n  public state: AutofillState;\n\n  constructor(settings: AutofillSettings = {}) {\n    this.settings = {\n      mode: 'auto',\n      staggered: true,\n      staggerDelay: 50,\n      ...settings\n    };\n    \n    this.state = {\n      status: 'idle',\n      inputs: []\n    };\n  }\n\n  // Update status and trigger callback\n  private updateStatus(status: string): void {\n    this.state.status = status;\n    if (this.settings.onStatusChange) {\n      // Create a copy of the state to avoid reference issues\n      const stateCopy = { ...this.state, inputs: [...this.state.inputs] };\n      this.settings.onStatusChange(status, stateCopy);\n    }\n  }\n\n  // Public API methods\n  async autofill(target?: HTMLElement | Element | string): Promise<boolean | void> {\n    this.updateStatus('starting');\n    this.state.inputs = [];\n\n    // Step 1: Get all target elements based on the target parameter\n    const result = this.getElements(target);\n    \n    if (result.error) {\n      console.warn(`[Gofakeit] ${result.error}`);\n      this.showNotification(result.error, 'error');\n      this.updateStatus('error');\n      return false;\n    }\n    \n    if (result.elements.length === 0) {\n      this.showNotification('No form fields found to autofill', 'info');\n      // Only set to idle if we're not already in error state\n      if (this.state.status !== 'error') {\n        this.updateStatus('idle');\n      }\n      return false;\n    }\n    \n    const elements = result.elements;\n\n    console.log(`[Gofakeit] Found ${elements.length} elements to generate data for`);\n    this.showNotification(`Starting data generation for ${elements.length} fields...`, 'info');\n\n    try {\n      // Step 2: Initialize inputs array with all target elements\n      await this.initializeInputs(elements);\n      this.updateStatus('initializing');\n\n      // Step 3: Determine functions for inputs that need search\n      await this.determineFunctions();\n      this.updateStatus('determining_functions');\n\n      // Step 4: Get values for all inputs via multi-function API\n      await this.getValues();\n      this.updateStatus('getting_values');\n\n      // Step 5: Apply values to the actual form elements\n      await this.applyValues();\n      this.updateStatus('applying_values');\n\n      this.updateStatus('completed');\n      return true;\n    } catch (error) {\n      console.error('[Gofakeit] Autofill process failed:', error);\n      this.updateStatus('error');\n      return false;\n    }\n  }\n\n  // Public method to get form elements based on target parameter\n  public getElements(target?: HTMLElement | Element | string): GetElementsResult {\n    // No parameters - get all form fields on the page\n    if (!target) {\n      return { elements: this.queryFormElements() };\n    }\n\n    // Handle string selectors (ID, class, complex CSS selectors)\n    if (typeof target === 'string') {\n      const elements = document.querySelectorAll(target);\n      if (elements.length === 0) {\n        return { \n          elements: [], \n          error: `No element found with selector: \"${target}\"` \n        };\n      }\n      \n      // If it's a single element, treat it as a container\n      if (elements.length === 1) {\n        const element = elements[0] as HTMLElement;\n        // Check if it's a form field itself\n        if ((element.tagName === 'INPUT' || element.tagName === 'TEXTAREA' || element.tagName === 'SELECT') &&\n            element.hasAttribute('data-gofakeit')) {\n          return { elements: [element] };\n        }\n        // Check if it contains form fields\n        const formFields = element.querySelectorAll('input, textarea, select');\n        if (formFields.length > 0) {\n          return { elements: this.queryFormElements(element) };\n        }\n        return { elements: [] };\n      }\n      \n      // If multiple elements, check each one\n      const formFields: Element[] = [];\n      elements.forEach(element => {\n        const htmlElement = element as HTMLElement;\n        if ((htmlElement.tagName === 'INPUT' || htmlElement.tagName === 'TEXTAREA' || htmlElement.tagName === 'SELECT') &&\n            htmlElement.hasAttribute('data-gofakeit')) {\n          formFields.push(element);\n        } else {\n          const nestedFormFields = htmlElement.querySelectorAll('input, textarea, select');\n          if (nestedFormFields.length > 0) {\n            formFields.push(...this.queryFormElements(htmlElement));\n          }\n        }\n      });\n      return { elements: formFields };\n    }\n\n    // Handle HTMLElement or Element\n    if (target instanceof HTMLElement) {\n      // Check if it's a form field itself\n      if ((target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.tagName === 'SELECT') &&\n          target.hasAttribute('data-gofakeit')) {\n        return { elements: [target] };\n      }\n      \n      // Check if it contains form fields\n      const formFields = target.querySelectorAll('input, textarea, select');\n      if (formFields.length > 0) {\n        return { elements: this.queryFormElements(target) };\n      }\n      \n      // If it's neither a form field nor contains form fields, try to find a container\n      const container = this.findFormContainer(target);\n      if (container) {\n        return { elements: this.queryFormElements(container) };\n      }\n      \n      // If it's neither a form field nor contains form fields, return error\n      return { \n        elements: [], \n        error: 'Element is not a form field and does not contain form fields' \n      };\n    }\n\n    // Handle other Element types (like SVGElement, etc.)\n    if (target instanceof Element) {\n      const htmlElement = target as HTMLElement;\n      if ((htmlElement.tagName === 'INPUT' || htmlElement.tagName === 'TEXTAREA' || htmlElement.tagName === 'SELECT') &&\n          htmlElement.hasAttribute('data-gofakeit')) {\n        return { elements: [target] };\n      }\n      \n      const formFields = htmlElement.querySelectorAll('input, textarea, select');\n      if (formFields.length > 0) {\n        return { elements: this.queryFormElements(htmlElement) };\n      }\n      \n      const container = this.findFormContainer(target as HTMLElement);\n      if (container) {\n        return { elements: this.queryFormElements(container) };\n      }\n      \n      return { \n        elements: [], \n        error: 'Element is not a form field and does not contain form fields' \n      };\n    }\n\n    // Fallback - return empty array\n    return { elements: [] };\n  }\n\n  resetState(): void {\n    this.state = {\n      status: 'idle',\n      inputs: []\n    };\n}\n\n// ============================================================================\n// PROCESSING FUNCTIONS (Called by main functions)\n// ============================================================================\n\n// Query all form elements that can be autofilled\n  private queryFormElements(container?: HTMLElement): Element[] {\n  const selector = 'input, textarea, select';\n  const nodeList = container ? container.querySelectorAll(selector) : document.querySelectorAll(selector);\n  const elements: Element[] = [];\n  nodeList.forEach((el) => {\n    if (el instanceof HTMLInputElement) {\n      if (el.type === 'hidden' || el.disabled || el.readOnly) return;\n      elements.push(el);\n    } else if (el instanceof HTMLTextAreaElement) {\n      if (el.disabled || el.readOnly) return;\n      elements.push(el);\n    } else if (el instanceof HTMLSelectElement) {\n      if (el.disabled) return;\n      elements.push(el);\n    }\n  });\n  return elements;\n}\n\n// Get unique elements, handling checkbox and radio groups\n  private getUniqueElements(elements: Element[]): Element[] {\n  const uniqueElements: Element[] = [];\n  const processedGroups = new Set<string>();\n  \n  for (const element of elements) {\n    if (element instanceof HTMLInputElement) {\n      const inputType = element.type.toLowerCase();\n      \n      if (inputType === 'checkbox' || inputType === 'radio') {\n        const name = element.name;\n        if (name && processedGroups.has(name)) {\n          // Skip if we've already processed this group\n          continue;\n        }\n        if (name) {\n          processedGroups.add(name);\n        }\n      }\n    }\n    \n    uniqueElements.push(element);\n  }\n  \n  return uniqueElements;\n}\n\n\n  // ============================================================================\n  // NEW STEP-BY-STEP AUTOFILL PROCESS\n  // ============================================================================\n\n  // Step 1: Initialize inputs array with all target elements\n  private async initializeInputs(elements: Element[]): Promise<void> {\n    const uniqueElements = this.getUniqueElements(elements);\n  \n  for (const element of uniqueElements) {\n      const gofakeitFunc = element.getAttribute('data-gofakeit');\n      const mode = this.settings.mode ?? 'auto';\n      \n      // Skip if explicitly disabled or in manual mode without data-gofakeit\n      if (typeof gofakeitFunc === 'string' && gofakeitFunc.trim().toLowerCase() === 'false') {\n        continue;\n      }\n      if (!gofakeitFunc && mode === 'manual') {\n        continue;\n      }\n\n      // Determine input type\n      let inputType = 'unknown';\n    if (element instanceof HTMLInputElement) {\n        inputType = element.type.toLowerCase();\n      } else if (element instanceof HTMLTextAreaElement) {\n        inputType = 'textarea';\n      } else if (element instanceof HTMLSelectElement) {\n        inputType = 'select';\n      }\n\n      // Determine initial function using input type handlers\n      let initialFunction = '';\n      if (gofakeitFunc && gofakeitFunc !== 'true') {\n        // Specific function provided\n        initialFunction = gofakeitFunc;\n      } else if (gofakeitFunc === 'true') {\n        // Use input type specific function\n        initialFunction = this.getInputTypeFunction(element, gofakeitFunc);\n    } else {\n        // No function specified - will need search\n        initialFunction = '';\n      }\n\n      const autofillInput: AutofillElement = {\n        element,\n        type: inputType,\n        function: initialFunction,\n        value: '',\n        error: ''\n      };\n\n      this.state.inputs.push(autofillInput);\n    }\n\n    console.log(`[Gofakeit] Initialized ${this.state.inputs.length} inputs`);\n  }\n\n  // Step 2: Determine functions for inputs that need search\n  private async determineFunctions(): Promise<void> {\n    const inputsNeedingSearch = this.state.inputs.filter(input => \n      !input.function && this.needsSearchApi(input.type)\n    );\n\n    if (inputsNeedingSearch.length === 0) {\n      console.log('[Gofakeit] No inputs need function search');\n      return;\n    }\n\n    console.log(`[Gofakeit] Determining functions for ${inputsNeedingSearch.length} inputs`);\n\n    // Create search requests for inputs that need function detection\n    const searchRequests: FuncSearchRequest[] = inputsNeedingSearch.map((input, index) => {\n      const element = input.element as HTMLInputElement;\n      const searchQuery = this.createSearchQuery(element);\n      \n      return {\n        id: input.element.id || input.element.getAttribute('name') || `input_${index}`,\n        query: searchQuery\n      };\n    });\n\n    try {\n      const response = await searchMultiFunc(searchRequests);\n      \n      if (response.success && response.data) {\n        // Map results back to inputs\n        for (let i = 0; i < response.data.length; i++) {\n          const searchResult = response.data[i];\n          const input = inputsNeedingSearch[i];\n          \n          if (searchResult.results && searchResult.results.length > 0) {\n            const bestMatch = searchResult.results[0];\n            // Only use the search result if it has a reasonable score\n            if (bestMatch.score >= 100) {\n              input.function = bestMatch.name;\n            } else {\n              // Use type-specific fallback for low-scoring results\n              input.function = this.getTypeSpecificFallback(input.type);\n            }\n          } else {\n            // Fallback to type-specific function if no search results\n            input.function = this.getTypeSpecificFallback(input.type);\n          }\n        }\n      } else {\n        // Fallback to default functions for all inputs if search fails\n        for (const input of inputsNeedingSearch) {\n          input.function = this.getDefaultFunctionForInputType(input.type);\n        }\n      }\n    } catch (error) {\n      console.warn('[Gofakeit] Function search failed, using fallback functions:', error);\n      // Fallback to default functions for all inputs\n      for (const input of inputsNeedingSearch) {\n        input.function = this.getDefaultFunctionForInputType(input.type);\n      }\n    }\n\n    console.log('[Gofakeit] Function determination complete');\n  }\n\n  // Step 3: Get values for all inputs via multi-function API\n  private async getValues(): Promise<void> {\n    const inputsNeedingValues = this.state.inputs.filter(input => \n      input.function && !input.error\n    );\n\n    if (inputsNeedingValues.length === 0) {\n      console.log('[Gofakeit] No inputs need value generation');\n      return;\n    }\n\n    console.log(`[Gofakeit] Getting values for ${inputsNeedingValues.length} inputs`);\n\n    // Separate inputs that need API calls vs local generation\n    const apiInputs: AutofillElement[] = [];\n    const localInputs: AutofillElement[] = [];\n\n    for (const input of inputsNeedingValues) {\n      if (this.isLocalGenerationFunction(input.function)) {\n        localInputs.push(input);\n        } else {\n        apiInputs.push(input);\n      }\n    }\n\n    // Handle local generation first\n    for (const input of localInputs) {\n      try {\n        input.value = this.generateLocalValue(input.function);\n      } catch (error) {\n        input.error = String(error);\n      }\n    }\n\n    // Handle API calls for remaining inputs\n    if (apiInputs.length > 0) {\n      const requests: MultiFuncRequest[] = apiInputs.map((input, index) => ({\n    id: `req_${index}`,\n        func: input.function\n  }));\n\n      try {\n  const batchResponse = await callMultiFunc(requests);\n  \n        if (batchResponse.success && batchResponse.data) {\n          // Map results back to inputs\n          for (let i = 0; i < batchResponse.data.length; i++) {\n    const response = batchResponse.data[i];\n            const input = apiInputs[i];\n            \n            if (response && response.error) {\n              input.error = response.error;\n            } else if (response && response.value !== null) {\n              input.value = response.value;\n            } else {\n              input.error = 'No valid response received';\n            }\n          }\n        } else {\n          // Mark all API inputs as failed\n          for (const input of apiInputs) {\n            input.error = batchResponse.error || 'Batch API call failed';\n          }\n        }\n      } catch (error) {\n        console.error('[Gofakeit] Batch API call failed:', error);\n        // Mark all API inputs as failed\n        for (const input of apiInputs) {\n          input.error = String(error);\n        }\n      }\n    }\n\n    console.log('[Gofakeit] Value generation complete');\n  }\n\n  // Check if a function is a local generation function\n  private isLocalGenerationFunction(func: string): boolean {\n    const localFunctions = ['generateTime', 'generateMonth', 'generateWeek', 'generateDate', 'generateDateTime'];\n    return localFunctions.includes(func);\n  }\n\n  // Generate local values for date/time functions\n  private generateLocalValue(func: string): string {\n    switch (func) {\n      case 'generateTime':\n        return this.generateTime();\n      case 'generateMonth':\n        return this.generateMonth();\n      case 'generateWeek':\n        return this.generateWeek();\n      case 'generateDate':\n        return this.generateDate();\n      case 'generateDateTime':\n        return this.generateDateTime();\n      default:\n        throw new Error(`Unknown local generation function: ${func}`);\n    }\n  }\n\n  // Step 4: Apply values to the actual form elements\n  private async applyValues(): Promise<void> {\n    const inputsToApply = this.state.inputs.filter(input => \n      input.value !== undefined && input.value !== null && !input.error\n    );\n\n    if (inputsToApply.length === 0) {\n      console.log('[Gofakeit] No values to apply');\n      return;\n    }\n\n    console.log(`[Gofakeit] Applying values to ${inputsToApply.length} inputs`);\n\n    const testMode = (globalThis as any).__GOFAKEIT_TEST_MODE__;\n    const staggered = testMode ? false : (this.settings.staggered ?? true);\n    const staggerDelay = this.settings.staggerDelay ?? 50;\n\n    for (let i = 0; i < inputsToApply.length; i++) {\n      const input = inputsToApply[i];\n      \n      // Add staggered delay for visual effect if enabled\n      if (staggered && i > 0) {\n        await new Promise(resolve => setTimeout(resolve, staggerDelay));\n      }\n\n      try {\n        const success = await this.applyValueToElement(input.element, input.function, input.value);\n        if (!success) {\n          input.error = 'Failed to apply value to element';\n        }\n  } catch (error) {\n        input.error = String(error);\n        console.warn(`[Gofakeit] Failed to apply value to element:`, input.element, error);\n      }\n    }\n\n    // Show detailed results using AutofillElement objects\n    this.showDetailedResults();\n    console.log('[Gofakeit] Value application complete');\n  }\n\n  // Helper method to apply a value to a specific element\n  private async applyValueToElement(element: Element, _func: string, value: string): Promise<boolean> {\n  try {\n    // Handle select dropdowns\n    if (element instanceof HTMLSelectElement) {\n        this.setSelectValue(element, value);\n        return true;\n    }\n    \n    // Handle textarea elements\n    if (element instanceof HTMLTextAreaElement) {\n        this.setTextareaValue(element, value);\n      return true;\n    }\n    \n    // Handle input elements\n    if (element instanceof HTMLInputElement) {\n      const inputType = element.type.toLowerCase();\n      \n      // Handle checkbox inputs\n      if (inputType === 'checkbox') {\n          this.setCheckboxValue(element, value);\n          return true;\n      }\n      \n      // Handle radio inputs\n      if (inputType === 'radio') {\n          this.setRadioValue(element, value);\n          return true;\n      }\n      \n      // Handle number inputs\n      if (inputType === 'number') {\n          this.setNumberValue(element, value);\n        return true;\n      }\n      \n      // Handle range inputs\n      if (inputType === 'range') {\n          this.setRangeValue(element, value);\n        return true;\n      }\n      \n      // Handle date/time inputs\n      if (inputType === 'date' || inputType === 'time' || inputType === 'datetime-local' || \n          inputType === 'month' || inputType === 'week') {\n          this.setDateTimeValue(element, value);\n          return true;\n      }\n      \n      // Handle text inputs (text, email, tel, password, search, url, color, etc.)\n        this.setTextValue(element, value);\n      return true;\n    }\n    \n    console.warn('[Gofakeit] Unsupported element type:', element);\n    return false;\n    \n  } catch (error) {\n      console.error('[Gofakeit] Unexpected error applying value to element:', element, error);\n    return false;\n  }\n}\n\n// ============================================================================\n// UTILITY FUNCTIONS (Called by various functions)\n// ============================================================================\n\n// Handle error display and field highlighting\n  public handleError(element: Element, error: string, functionName?: string): void {\n  if (element instanceof HTMLElement) {\n      element.style.border = `2px solid #dc3545`;\n    \n    setTimeout(() => {\n      element.style.border = '';\n    }, 5000);\n  }\n  \n    console.warn(`[Gofakeit] Error for element:`, element, functionName ? `Invalid function: ${functionName}` : error);\n  }\n\n\n// Extract nearby/associated label text for context\n  private getAssociatedLabelText(input: HTMLInputElement): string {\n  const texts: string[] = [];\n  const id = input.id;\n  // aria-labelledby\n  const labelledBy = input.getAttribute('aria-labelledby');\n  if (labelledBy) {\n    labelledBy.split(/\\s+/).forEach((ref) => {\n      const el = document.getElementById(ref);\n      if (el && el.textContent) texts.push(el.textContent);\n    });\n  }\n  // explicit label[for]\n  if (id) {\n    try {\n      const lbl = document.querySelector('label[for=\"' + id.replace(/\"/g, '\\\\\"') + '\"]') as HTMLLabelElement | null;\n      if (lbl && lbl.textContent) texts.push(lbl.textContent);\n    } catch { /* ignore */ }\n  }\n  // implicit parent label\n  const closestLabel = input.closest('label');\n  if (closestLabel && closestLabel.textContent) texts.push(closestLabel.textContent);\n  // previous sibling label (common in some UIs)\n  const prev = input.previousElementSibling as HTMLElement | null;\n  if (prev && prev.tagName === 'LABEL' && prev.textContent) texts.push(prev.textContent);\n  return texts.join(' ').toLowerCase();\n}\n\n// Determine if an input type needs search API for function detection\n  private needsSearchApi(inputType: string): boolean {\n  // These input types have their own specific handling and don't need search API\n    const skipSearchTypes = ['checkbox', 'radio', 'select', 'range', 'file', 'button', 'submit', 'reset', 'image', 'week', 'date', 'time', 'datetime-local', 'month'];\n  return !skipSearchTypes.includes(inputType);\n}\n\n// Get a default function for input types that don't need search API\n  public getDefaultFunctionForInputType(inputType: string): string {\n  switch (inputType) {\n    case 'checkbox':\n    case 'radio':\n    case 'select':\n      return 'true';\n    case 'range':\n      return 'number?min=0&max=100';\n    case 'file':\n      return 'word';\n    case 'button':\n    case 'submit':\n    case 'reset':\n    case 'image':\n      return 'word';\n    case 'week':\n      return 'generateWeek';\n    case 'date':\n      return 'generateDate';\n    case 'time':\n      return 'generateTime';\n    case 'datetime-local':\n      return 'generateDateTime';\n    case 'month':\n      return 'generateMonth';\n    default:\n      return 'word';\n  }\n}\n\n// Get type-specific fallback functions for when search API doesn't find good matches\n  private getTypeSpecificFallback(inputType: string): string {\n  switch (inputType) {\n    case 'email':\n      return 'email';\n    case 'tel':\n      return 'phone';\n    case 'number':\n      return 'number';\n    case 'date':\n      return 'date';\n    case 'time':\n      return 'time';\n    case 'datetime-local':\n      return 'datetime';\n    case 'month':\n      return 'month';\n    case 'week':\n      return 'week';\n    case 'url':\n      return 'url';\n    case 'password':\n      return 'password';\n    case 'search':\n      return 'word';\n    case 'color':\n        return 'hexcolor';\n    case 'text':\n    default:\n      return 'word';\n  }\n}\n\n// Create a comprehensive search query from input field characteristics\n  private createSearchQuery(input: HTMLInputElement): string {\n  const type = input.type.toLowerCase();\n  const name = (input.name || '').toLowerCase();\n  const id = (input.id || '').toLowerCase();\n  const placeholder = (input.placeholder || '').toLowerCase();\n  const autocomplete = (input.autocomplete || '').toLowerCase();\n  const ariaLabel = (input.getAttribute('aria-label') || '').toLowerCase();\n    const labelText = this.getAssociatedLabelText(input);\n\n  // Build a comprehensive search query with all available information\n  const queryParts = [\n    type,\n    name,\n    id,\n    placeholder,\n    autocomplete,\n    ariaLabel,\n    labelText\n  ].filter(part => part && part.trim());\n\n  // Join all parts with spaces to create a comprehensive search query\n  const searchQuery = queryParts.join(' ').toLowerCase()\n    .replace(/[^\\w\\s]/g, ' ') // Remove special characters\n    .replace(/\\s+/g, ' ') // Normalize whitespace\n    .trim();\n\n  return searchQuery || 'text input';\n}\n\n  // Find the closest container that has form fields with data-gofakeit attributes\n  private findFormContainer(element: HTMLElement): HTMLElement | null {\n    // Check if the current element has form fields\n    const formFields = element.querySelectorAll('input, textarea, select');\n    if (formFields.length > 0) {\n      return element;\n    }\n    \n    // Check parent elements\n    let parent = element.parentElement;\n    while (parent) {\n      const parentFormFields = parent.querySelectorAll('input, textarea, select');\n      if (parentFormFields.length > 0) {\n        return parent;\n      }\n      parent = parent.parentElement;\n    }\n    \n    return null;\n  }\n\n  // Simple notification function (can be overridden by the consuming application)\n  private showNotification(message: string, type: 'success' | 'error' | 'info' = 'info'): void {\n    console.log(`[Gofakeit ${type.toUpperCase()}] ${message}`);\n  }\n\n  // ============================================================================\n  // RESULTS DISPLAY\n  // ============================================================================\n\n  // Show detailed results using AutofillElement objects\n  private showDetailedResults(): void {\n    const successfulInputs = this.state.inputs.filter(input => input.value && !input.error);\n    const failedInputs = this.state.inputs.filter(input => input.error);\n    \n    console.log(`[Gofakeit] Autofill Results Summary:`);\n    console.log(`✅ Successful: ${successfulInputs.length} fields`);\n    console.log(`❌ Failed: ${failedInputs.length} fields`);\n    \n    if (successfulInputs.length > 0) {\n      console.log(`\\n📋 Successful Fields:`);\n      successfulInputs.forEach((input, index) => {\n        const elementInfo = this.getElementInfo(input.element);\n        console.log(`  ${index + 1}. ${elementInfo} → ${input.function} → \"${input.value}\"`);\n      });\n    }\n    \n    if (failedInputs.length > 0) {\n      console.log(`\\n⚠️ Failed Fields:`);\n      failedInputs.forEach((input, index) => {\n        const elementInfo = this.getElementInfo(input.element);\n        console.log(`  ${index + 1}. ${elementInfo} → ${input.function} → ERROR: ${input.error}`);\n      });\n    }\n    \n    // Show notification\n    if (successfulInputs.length > 0 && failedInputs.length === 0) {\n      this.showNotification(`Successfully generated data for ${successfulInputs.length} fields!`, 'success');\n    } else if (successfulInputs.length > 0 && failedInputs.length > 0) {\n      this.showNotification(`Generated data for ${successfulInputs.length} fields, ${failedInputs.length} failed`, 'info');\n    } else if (failedInputs.length > 0) {\n      this.showNotification(`Failed to generate data for ${failedInputs.length} fields`, 'error');\n    } else {\n      this.showNotification('No fields were processed', 'info');\n    }\n  }\n\n  // Get a descriptive string for an element\n  private getElementInfo(element: Element): string {\n    let info = '';\n    \n    if (element instanceof HTMLInputElement) {\n      const type = element.type || 'text';\n      const name = element.name || element.id || 'unnamed';\n      const label = this.getAssociatedLabelText(element);\n      info = `input[type=\"${type}\"][name=\"${name}\"]`;\n      if (label) {\n        info += ` (${label})`;\n      }\n    } else if (element instanceof HTMLTextAreaElement) {\n      const name = element.name || element.id || 'unnamed';\n      const label = this.getAssociatedLabelText(element as any);\n      info = `textarea[name=\"${name}\"]`;\n      if (label) {\n        info += ` (${label})`;\n      }\n    } else if (element instanceof HTMLSelectElement) {\n      const name = element.name || element.id || 'unnamed';\n      const label = this.getAssociatedLabelText(element as any);\n      info = `select[name=\"${name}\"]`;\n      if (label) {\n        info += ` (${label})`;\n      }\n    } else {\n      info = element.tagName.toLowerCase();\n      if (element.id) {\n        info += `#${element.id}`;\n      }\n      if (element.className) {\n        info += `.${element.className.split(' ').join('.')}`;\n      }\n    }\n    \n    return info;\n  }\n\n  // ============================================================================\n  // INPUT TYPE HANDLERS\n  // ============================================================================\n\n  // Get function name for any input type\n  private getInputTypeFunction(element: Element, gofakeitFunc: string): string {\n    if (element instanceof HTMLInputElement) {\n      const inputType = element.type.toLowerCase();\n      \n      switch (inputType) {\n        case 'date':\n        case 'time':\n        case 'datetime-local':\n        case 'month':\n        case 'week':\n          return this.getDateTimeFunction(element, gofakeitFunc);\n        case 'number':\n          return this.getNumberFunction(gofakeitFunc);\n        case 'range':\n          return this.getNumberFunction(gofakeitFunc);\n        case 'checkbox':\n          return this.getCheckboxFunction(gofakeitFunc);\n        case 'radio':\n          return this.getRadioFunction(gofakeitFunc);\n        default:\n          return this.getTextFunction(element, gofakeitFunc);\n      }\n    } else if (element instanceof HTMLTextAreaElement) {\n      return this.getTextFunction(element as any, gofakeitFunc);\n    } else if (element instanceof HTMLSelectElement) {\n      return this.getSelectFunction(gofakeitFunc);\n    }\n    \n    return gofakeitFunc;\n  }\n\n  // Get function name for date/time inputs\n  private getDateTimeFunction(element: HTMLInputElement, gofakeitFunc: string): string {\n    const inputType = element.type.toLowerCase();\n    \n    // For all date/time inputs, use local generate functions when gofakeitFunc is 'true'\n    if (inputType === 'date') {\n      return gofakeitFunc === 'true' ? 'generateDate' : gofakeitFunc;\n    }\n    \n    if (inputType === 'datetime-local') {\n      return gofakeitFunc === 'true' ? 'generateDateTime' : gofakeitFunc;\n    }\n    \n    if (inputType === 'time') {\n      return gofakeitFunc === 'true' ? 'generateTime' : gofakeitFunc;\n    }\n    \n    if (inputType === 'month') {\n      return gofakeitFunc === 'true' ? 'generateMonth' : gofakeitFunc;\n    }\n    \n    if (inputType === 'week') {\n      return gofakeitFunc === 'true' ? 'generateWeek' : gofakeitFunc;\n    }\n    \n    return gofakeitFunc;\n  }\n\n  // Set date/time input value\n  private setDateTimeValue(element: HTMLInputElement, value: string): void {\n    element.value = value;\n    element.dispatchEvent(new Event('input', { bubbles: true }));\n    element.dispatchEvent(new Event('change', { bubbles: true }));\n  }\n\n  // Get function name for text inputs\n  private getTextFunction(element: HTMLInputElement, gofakeitFunc: string): string {\n    const inputType = element.type.toLowerCase();\n    \n    // Map input types to appropriate gofakeit functions if 'true' is passed\n    if (gofakeitFunc === 'true') {\n      switch (inputType) {\n        case 'email':\n          return 'email';\n        case 'tel':\n          return 'phone';\n        case 'password':\n          return 'password';\n        case 'search':\n          return 'word';\n        case 'url':\n          return 'url';\n        case 'color':\n          return 'hexcolor';\n        default:\n          return 'word'; // Default for text inputs\n      }\n    }\n    \n    return gofakeitFunc;\n  }\n\n  // Set text input value\n  private setTextValue(element: HTMLInputElement, value: string): void {\n    element.value = value;\n    element.dispatchEvent(new Event('input', { bubbles: true }));\n    element.dispatchEvent(new Event('change', { bubbles: true }));\n  }\n\n  // Set textarea value\n  private setTextareaValue(element: HTMLTextAreaElement, value: string): void {\n    element.value = value;\n    element.dispatchEvent(new Event('input', { bubbles: true }));\n    element.dispatchEvent(new Event('change', { bubbles: true }));\n  }\n\n  // Get function name for number inputs\n  private getNumberFunction(gofakeitFunc: string): string {\n    return gofakeitFunc === 'true' ? 'number' : gofakeitFunc;\n  }\n\n  // Set number input value\n  private setNumberValue(element: HTMLInputElement, value: string): void {\n    element.value = value;\n    element.dispatchEvent(new Event('input', { bubbles: true }));\n    element.dispatchEvent(new Event('change', { bubbles: true }));\n  }\n\n  // Set range input value\n  private setRangeValue(element: HTMLInputElement, value: string): void {\n    element.value = value;\n    element.dispatchEvent(new Event('input', { bubbles: true }));\n    element.dispatchEvent(new Event('change', { bubbles: true }));\n  }\n\n  // Get function name for checkbox inputs\n  private getCheckboxFunction(gofakeitFunc: string): string {\n    return gofakeitFunc === 'true' ? 'bool' : gofakeitFunc;\n  }\n\n  // Set checkbox value\n  private setCheckboxValue(element: HTMLInputElement, value: string | boolean): void {\n    let boolValue: boolean;\n    if (typeof value === 'boolean') {\n      boolValue = value;\n    } else {\n      boolValue = value.toLowerCase() === 'true';\n    }\n    \n    element.checked = boolValue;\n    \n    // Always dispatch change event when setting checkbox value\n    element.dispatchEvent(new Event('change', { bubbles: true }));\n  }\n\n  // Get function name for radio inputs\n  private getRadioFunction(gofakeitFunc: string): string {\n    return gofakeitFunc === 'true' ? 'bool' : gofakeitFunc;\n  }\n\n  // Set radio value\n  private setRadioValue(element: HTMLInputElement, value: string | boolean): void {\n    let boolValue: boolean;\n    if (typeof value === 'boolean') {\n      boolValue = value;\n        } else {\n      boolValue = value.toLowerCase() === 'true';\n    }\n    \n    // Uncheck all other radio buttons in the same group first\n    const name = element.name;\n    if (name) {\n      const groupRadios = document.querySelectorAll(`input[type=\"radio\"][name=\"${name}\"]`);\n      groupRadios.forEach(radio => {\n        (radio as HTMLInputElement).checked = false;\n      });\n    }\n    \n    // Set this radio button to checked if the value is true\n    if (boolValue) {\n      element.checked = true;\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n    } else {\n      // If this radio button gets false, but no other radio in the group is checked,\n      // we need to ensure at least one radio button in the group is selected\n      const name = element.name;\n      if (name) {\n        const groupRadios = document.querySelectorAll(`input[type=\"radio\"][name=\"${name}\"]`);\n        const hasCheckedRadio = Array.from(groupRadios).some(radio => (radio as HTMLInputElement).checked);\n        \n        // If no radio button in the group is checked, check this one\n        if (!hasCheckedRadio) {\n          element.checked = true;\n          element.dispatchEvent(new Event('change', { bubbles: true }));\n        }\n      }\n    }\n    \n    // Always ensure at least one radio button in the group is checked\n    const radioName = element.name;\n    if (radioName) {\n      const groupRadios = document.querySelectorAll(`input[type=\"radio\"][name=\"${radioName}\"]`);\n      const hasCheckedRadio = Array.from(groupRadios).some(radio => (radio as HTMLInputElement).checked);\n      \n      // If no radio button in the group is checked, check the first one\n      if (!hasCheckedRadio && groupRadios.length > 0) {\n        const firstRadio = groupRadios[0] as HTMLInputElement;\n        firstRadio.checked = true;\n        firstRadio.dispatchEvent(new Event('change', { bubbles: true }));\n      }\n    }\n  }\n\n  // Get function name for select inputs\n  private getSelectFunction(gofakeitFunc: string): string {\n    return gofakeitFunc === 'true' ? 'word' : gofakeitFunc;\n  }\n\n  // Set select value\n  private setSelectValue(element: HTMLSelectElement, value: string): void {\n    // Try to find an option with matching text content\n    const options = Array.from(element.options);\n    const matchingOption = options.find(option => \n      option.textContent?.toLowerCase().includes(value.toLowerCase()) ||\n      option.value.toLowerCase().includes(value.toLowerCase())\n    );\n    \n    if (matchingOption) {\n      element.value = matchingOption.value;\n          } else if (options.length > 0) {\n        // Fallback to random selection (skip empty option if it exists)\n        const nonEmptyOptions = options.filter(option => option.value !== '');\n        if (nonEmptyOptions.length > 0) {\n          const randomIndex = Math.floor(Math.random() * nonEmptyOptions.length);\n          element.value = nonEmptyOptions[randomIndex].value;\n        } else {\n          // If all options are empty, just select the first one\n          element.selectedIndex = 0;\n        }\n      }\n    \n    element.dispatchEvent(new Event('change', { bubbles: true }));\n  }\n\n  // ============================================================================\n  // DATE/TIME GENERATION FUNCTIONS\n  // ============================================================================\n\n  // Generate time string (HH:MM format)\n  private generateTime(): string {\n    const hour = Math.floor(Math.random() * 24).toString().padStart(2, '0');\n    const minute = Math.floor(Math.random() * 60).toString().padStart(2, '0');\n    return `${hour}:${minute}`;\n  }\n\n  // Generate month string (YYYY-MM format)\n  private generateMonth(): string {\n    const year = Math.floor(Math.random() * 30) + 1990; // Random year between 1990-2020\n    const month = Math.floor(Math.random() * 12) + 1;\n    return `${year}-${month.toString().padStart(2, '0')}`;\n  }\n\n  // Generate week string (YYYY-W## format)\n  private generateWeek(): string {\n    const year = Math.floor(Math.random() * 30) + 1990;\n    const week = Math.floor(Math.random() * 52) + 1;\n    return `${year}-W${week.toString().padStart(2, '0')}`;\n  }\n\n  // Generate date string (YYYY-MM-DD format)\n  private generateDate(): string {\n    const year = Math.floor(Math.random() * 30) + 1990;\n    const month = Math.floor(Math.random() * 12) + 1;\n    const day = Math.floor(Math.random() * 28) + 1; // Use 28 to avoid month/day issues\n    return `${year}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`;\n  }\n\n  // Generate datetime-local string (YYYY-MM-DDTHH:MM format)\n  private generateDateTime(): string {\n    const date = this.generateDate();\n    const time = this.generateTime();\n    return `${date}T${time}`;\n  }\n}\n","\n      import { Autofill } from \"./src/index.ts\";\n\n      // Make functions available globally\n      window.autofill = async (target) => {\n        try {\n          // Get current settings\n          const settings = getCurrentSettings();\n\n          if (target) {\n            // If target is a string, treat it as a CSS selector (ID, class, or other)\n            if (typeof target === \"string\") {\n              // Scroll to the section first\n              const element = document.querySelector(target);\n              if (element) {\n                element.scrollIntoView({ behavior: \"smooth\", block: \"start\" });\n                \n                // Wait a moment for the scroll to complete, then autofill\n                setTimeout(async () => {\n                  const manager = new Autofill(settings);\n                  await manager.autofill(target);\n                  showStatus(\n                    `✅ ${target} section filled successfully!`,\n                    \"success\"\n                  );\n                }, 500);\n              } else {\n                showStatus(\"❌ Element not found: \" + target, \"error\");\n              }\n            } else {\n              const manager = new AutofillManager(settings);\n              await manager.autofill(target);\n              showStatus(\"✅ Element filled successfully!\", \"success\");\n            }\n          } else {\n            // No target - autofill all\n            const manager = new AutofillManager(settings);\n            await manager.autofill(undefined);\n            showStatus(\"✅ All fields filled successfully!\", \"success\");\n          }\n        } catch (error) {\n          showStatus(\"❌ Error filling fields: \" + error.message, \"error\");\n        }\n      };\n\n      // Function to handle category selection from dropdown\n      window.handleCategorySelection = async () => {\n        const selector = document.getElementById(\"categorySelector\");\n        const selectedCategory = selector.value;\n\n        if (!selectedCategory) {\n          return;\n        }\n\n        try {\n          // Map category values to their heading text\n          const categoryHeadingMap = {\n            \"person-category\": \"👤 Person Category\",\n            \"address-category\": \"🏠 Address Category\",\n            \"company-category\": \"🏢 Company Category\",\n            \"payment-category\": \"💳 Payment Category\",\n            \"internet-category\": \"🌐 Internet Category\",\n            \"time-category\": \"⏰ Time Category\",\n            \"language-category\": \"🗣️ Language Category\",\n            \"word-category\": \"📝 Word Category\",\n            \"color-category\": \"🎨 Color Category\",\n            \"animal-category\": \"🐾 Animal Category\",\n            \"food-category\": \"🍕 Food Category\",\n            \"car-category\": \"🚗 Car Category\",\n            \"game-category\": \"🎮 Game Category\",\n            \"misc-category\": \"🎲 Misc Category\",\n          };\n\n          // Find the specific category heading by text content\n          const headingText = categoryHeadingMap[selectedCategory];\n          let categoryHeading = null;\n          if (headingText) {\n            const allHeadings = document.querySelectorAll(\"h4\");\n            for (const heading of allHeadings) {\n              if (heading.textContent?.includes(headingText)) {\n                categoryHeading = heading;\n                break;\n              }\n            }\n          }\n\n          if (categoryHeading) {\n            categoryHeading.scrollIntoView({\n              behavior: \"smooth\",\n              block: \"start\",\n            });\n          } else {\n            // Fallback: scroll to the categories section\n            const section = document.getElementById(\"categories\");\n            if (section) {\n              section.scrollIntoView({ behavior: \"smooth\", block: \"start\" });\n            }\n          }\n\n          // Wait a moment for the scroll to complete, then autofill the specific fields\n          setTimeout(async () => {\n            // Find the category container\n            const categoryContainer = document.getElementById(selectedCategory);\n            if (!categoryContainer) {\n              showStatus(\"❌ Category container not found!\", \"error\");\n              return;\n            }\n\n            try {\n              // Get current settings\n              const settings = getCurrentSettings();\n\n              // Use the main autofill function with the category container\n              const manager = new Autofill(settings);\n              await manager.autofill(categoryContainer);\n\n              // Count filled elements\n              let filledCount = 0;\n              const inputs = categoryContainer.querySelectorAll(\n                \"input, textarea, select\"\n              );\n              inputs.forEach((element) => {\n                if (element instanceof HTMLInputElement) {\n                  if (element.type === \"checkbox\" || element.type === \"radio\") {\n                    if (element.checked) filledCount++;\n                  } else if (element.value) {\n                    filledCount++;\n                  }\n                } else if (\n                  element instanceof HTMLTextAreaElement ||\n                  element instanceof HTMLSelectElement\n                ) {\n                  if (element.value) filledCount++;\n                }\n              });\n\n              const categoryName = selector.options[selector.selectedIndex].text;\n              showStatus(\n                `✅ ${categoryName} filled successfully! (${filledCount} fields)`,\n                \"success\"\n              );\n            } catch (error) {\n              console.warn(\"Failed to fill category:\", error);\n              showStatus(\n                \"❌ Error filling category: \" + error.message,\n                \"error\"\n              );\n            }\n\n            // Reset the dropdown\n            selector.value = \"\";\n          }, 500);\n        } catch (error) {\n          showStatus(\"❌ Error filling category: \" + error.message, \"error\");\n          // Reset the dropdown even on error\n          selector.value = \"\";\n        }\n      };\n\n      // Function to get current settings from the UI controls\n      function getCurrentSettings() {\n        const mode = document.querySelector('input[name=\"mode\"]:checked').value;\n        const staggeredMode = document.querySelector('input[name=\"staggered\"]:checked').value === 'on';\n        const staggerDelay = parseInt(\n          document.getElementById(\"staggerDelay\").value\n        );\n\n        return {\n          mode: mode,\n          staggered: staggeredMode,\n          staggerDelay: staggerDelay,\n          onStatusChange: (status, state) => {\n            console.log(`[Status Update] ${status}:`, state);\n            \n            // Update status display in UI\n            const statusElement = document.getElementById('statusDisplay');\n            if (statusElement) {\n              const statusText = {\n                'idle': 'Ready',\n                'starting': 'Starting...',\n                'initializing': 'Initializing inputs...',\n                'determining_functions': 'Determining functions...',\n                'getting_values': 'Getting values...',\n                'applying_values': 'Applying values...',\n                'completed': 'Completed!',\n                'error': 'Error occurred'\n              }[status] || status;\n              \n              statusElement.textContent = statusText;\n              statusElement.className = `status-badge ${status}`;\n            }\n            \n            // Show progress for certain statuses\n            if (status === 'getting_values' || status === 'applying_values') {\n              const processedCount = state.inputs.filter(input => input.value || input.error).length;\n              const totalCount = state.inputs.length;\n              if (totalCount > 0) {\n                showStatus(`Processing ${processedCount}/${totalCount} fields...`, 'info');\n              }\n            }\n          }\n        };\n      }\n\n      // Function to autofill with current settings\n      window.autofillWithCurrentSettings = async () => {\n        try {\n          const settings = getCurrentSettings();\n          const manager = new Autofill(settings);\n          await manager.autofill(undefined);\n\n          const modeText = settings.mode === 'auto' ? \"Auto Mode\" : \"Manual Mode\";\n          const staggerText = settings.staggered\n            ? ` (${settings.staggerDelay}ms delay)`\n            : \" (no stagger)\";\n          showStatus(\n            `✅ All fields filled with ${modeText}${staggerText}!`,\n            \"success\"\n          );\n        } catch (error) {\n          showStatus(\"❌ Error filling fields: \" + error.message, \"error\");\n        }\n      };\n\n      // Update stagger delay value display and handle theme toggle\n      document.addEventListener(\"DOMContentLoaded\", function () {\n        const staggerDelay = document.getElementById(\"staggerDelay\");\n        const staggerDelayValue = document.getElementById(\"staggerDelayValue\");\n        const themeToggle = document.getElementById(\"themeToggle\");\n        const themeIcon = themeToggle.querySelector(\".theme-icon\");\n\n        if (staggerDelay && staggerDelayValue) {\n          staggerDelay.addEventListener(\"input\", function () {\n            staggerDelayValue.textContent = this.value;\n          });\n        }\n\n        // Handle theme toggle\n        if (themeToggle) {\n          // Get user's saved preference or system preference\n          const savedTheme = localStorage.getItem(\"theme\");\n          const systemPrefersDark = window.matchMedia(\n            \"(prefers-color-scheme: dark)\"\n          ).matches;\n\n          // Use saved preference if available, otherwise use system preference\n          // Since dark is now default, we need to check if user wants light mode\n          const shouldUseLight =\n            savedTheme === \"light\" || (savedTheme === null && !systemPrefersDark);\n\n          if (shouldUseLight) {\n            document.documentElement.setAttribute(\"data-theme\", \"light\");\n            themeIcon.textContent = \"🌙\";\n          } else {\n            // Dark is default, no data-theme attribute needed\n            themeIcon.textContent = \"☀️\";\n          }\n\n          themeToggle.addEventListener(\"click\", function () {\n            const isLight = document.documentElement.hasAttribute(\"data-theme\") && \n                           document.documentElement.getAttribute(\"data-theme\") === \"light\";\n\n            if (isLight) {\n              // Switch to dark mode (default)\n              document.documentElement.removeAttribute(\"data-theme\");\n              localStorage.setItem(\"theme\", \"dark\");\n              themeIcon.textContent = \"☀️\";\n            } else {\n              // Switch to light mode\n              document.documentElement.setAttribute(\"data-theme\", \"light\");\n              localStorage.setItem(\"theme\", \"light\");\n              themeIcon.textContent = \"🌙\";\n            }\n          });\n\n          // Listen for system preference changes\n          window\n            .matchMedia(\"(prefers-color-scheme: dark)\")\n            .addEventListener(\"change\", function (e) {\n              // Only update if user hasn't set a preference\n              if (localStorage.getItem(\"theme\") === null) {\n                if (e.matches) {\n                  // System prefers dark, use default (dark)\n                  document.documentElement.removeAttribute(\"data-theme\");\n                  themeIcon.textContent = \"☀️\";\n                } else {\n                  // System prefers light, switch to light\n                  document.documentElement.setAttribute(\"data-theme\", \"light\");\n                  themeIcon.textContent = \"🌙\";\n                }\n              }\n            });\n        }\n      });\n\n      window.clearAll = () => {\n        // only search in main content container, not sidebar\n        const mainContent = document.querySelector(\".main-content\");\n        if (!mainContent) return;\n        \n        const inputs = mainContent.querySelectorAll(\"input, textarea, select\");\n        inputs.forEach((input) => {\n          if (input.type === \"checkbox\" || input.type === \"radio\") {\n            input.checked = false;\n          } else {\n            input.value = \"\";\n          }\n        });\n        showStatus(\"🧹 All fields cleared!\", \"success\");\n      };\n\n      function showStatus(message, type) {\n        const status = document.getElementById(\"status\");\n        status.textContent = message;\n        status.style.display = \"block\";\n        status.className = `status ${type} show`;\n\n        setTimeout(() => {\n          status.classList.remove(\"show\");\n          // Hide the status element completely after animation\n          setTimeout(() => {\n            status.style.display = \"none\";\n          }, 300);\n        }, 3000);\n      }\n\n      // Initialize the page\n      console.log(\"🎯 Gofakeit Autofill Comprehensive Testing loaded!\");\n      console.log(\n        \"This page tests the search API with various input contexts and categories.\"\n      );\n      console.log(\n        \"Check the browser network tab to see search API calls in action!\"\n      );\n    "],"names":["GOFAKEIT_API_BASE","callMultiFunc","requests","processedRequests","req","index","func","id","questionMarkIndex","functionName","queryString","params","searchParams","key","value","numValue","makeMultiRequest","searchMultiFunc","makeSearchRequest","method","url","body","options","response","error","Autofill","settings","status","stateCopy","target","result","elements","element","formFields","htmlElement","container","selector","nodeList","el","uniqueElements","processedGroups","inputType","name","gofakeitFunc","mode","initialFunction","autofillInput","inputsNeedingSearch","input","searchRequests","searchQuery","i","searchResult","bestMatch","inputsNeedingValues","apiInputs","localInputs","batchResponse","inputsToApply","staggered","staggerDelay","resolve","_func","texts","labelledBy","ref","lbl","closestLabel","prev","type","placeholder","autocomplete","ariaLabel","labelText","part","parent","message","successfulInputs","failedInputs","elementInfo","info","label","boolValue","radio","groupRadios","radioName","firstRadio","matchingOption","option","nonEmptyOptions","randomIndex","hour","minute","year","month","week","day","date","time","getCurrentSettings","showStatus","selectedCategory","headingText","categoryHeading","allHeadings","heading","section","categoryContainer","filledCount","categoryName","staggeredMode","state","statusElement","statusText","processedCount","totalCount","modeText","staggerText","staggerDelayValue","themeToggle","themeIcon","savedTheme","systemPrefersDark","e","mainContent"],"mappings":"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"}