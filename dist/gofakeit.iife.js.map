{"version":3,"file":"gofakeit.iife.js","sources":["../src/api.ts","../src/styles.ts","../src/autofill.ts"],"sourcesContent":["// Base URL for the Gofakeit API\nconst GOFAKEIT_API_BASE = 'https://api.gofakeit.com/funcs';\n\n// Interface for function parameters\nexport interface FetchFuncParams {\n  [key: string]: string | number | boolean | string[];\n}\n\nexport interface FetchFuncResponse {\n  success: boolean;\n  data?: string;\n  error?: string;\n  status?: number;\n}\n\n// Multi-function request interface\nexport interface FetchFuncMultiRequest {\n  id?: string;\n  func: string;\n  params?: FetchFuncParams;\n}\n\n// Multi-function response item interface\nexport interface FetchFuncMultiResponseItem {\n  id?: string;\n  value: string | number | boolean | null;\n  error?: string;\n}\n\n// Multi-function response interface\nexport interface FetchFuncMultiResponse {\n  success: boolean;\n  data?: FetchFuncMultiResponseItem[];\n  error?: string;\n  status?: number;\n}\n\n// Function search request interface\nexport interface FetchFuncSearchRequest {\n  id: string;\n  query: string;\n}\n\n// Function search result interface\nexport interface FetchFuncSearchResult {\n  name: string; // function name for API usage\n  score: number; // relevance score (0-100)\n  reasons: string[]; // why it matched\n}\n\n// Function search response item interface\nexport interface FetchFuncSearchResponseItem {\n  id: string;\n  query: string;\n  results: FetchFuncSearchResult[];\n}\n\n// Multi-function search response interface\nexport interface FetchFuncSearchResponse {\n  success: boolean;\n  data?: FetchFuncSearchResponseItem[];\n  error?: string;\n  status?: number;\n}\n\n// Fetch data from gofakeit API\nexport async function fetchFunc(\n  func: string,\n  params?: FetchFuncParams\n): Promise<FetchFuncResponse> {\n  const { func: funcName, params: extractedParams } = parseFunctionString(func);\n\n  // Merge extracted params with provided params (provided params take precedence)\n  const finalParams = { ...extractedParams, ...(params || {}) };\n\n  // Always use POST request\n  return makeRequest('POST', `${GOFAKEIT_API_BASE}/${funcName}`, finalParams);\n}\n\n// Call multiple functions in a single request\nexport async function fetchFuncMulti(\n  requests: FetchFuncMultiRequest[]\n): Promise<FetchFuncMultiResponse> {\n  if (requests.length === 0) {\n    return {\n      success: false,\n      error: 'No functions provided',\n    };\n  }\n\n  // Process each request to extract function name and parameters\n  const processedRequests: FetchFuncMultiRequest[] = requests.map(\n    (req, index) => {\n      const { func, id, params } = req;\n      const { func: funcName, params: extractedParams } =\n        parseFunctionString(func);\n\n      // Merge extracted params with provided params (provided params take precedence)\n      const finalParams = { ...extractedParams, ...(params || {}) };\n\n      return {\n        id: id || `req_${index}`,\n        func: funcName,\n        params: finalParams,\n      };\n    }\n  );\n\n  return makeRequest<FetchFuncMultiResponse>(\n    'POST',\n    `${GOFAKEIT_API_BASE}/multi`,\n    processedRequests\n  );\n}\n\n// Search for multiple functions in a single request\nexport async function fetchFuncSearch(\n  requests: FetchFuncSearchRequest[]\n): Promise<FetchFuncSearchResponse> {\n  if (requests.length === 0) {\n    return {\n      success: false,\n      error: 'No search queries provided',\n    };\n  }\n\n  return makeRequest<FetchFuncSearchResponse>(\n    'POST',\n    `${GOFAKEIT_API_BASE}/search`,\n    requests\n  );\n}\n\n// Base HTTP request function\n// Unified HTTP request function for all API calls\nasync function makeRequest<T>(\n  method: 'GET' | 'POST',\n  url: string,\n  body?: FetchFuncParams | FetchFuncMultiRequest[] | FetchFuncSearchRequest[]\n): Promise<T> {\n  try {\n    const options: {\n      method: string;\n      headers: Record<string, string>;\n      body?: string;\n    } = {\n      method: method,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    };\n\n    if (method === 'POST' && body) {\n      options.body = JSON.stringify(body);\n    }\n\n    const response = await fetch(url, options);\n\n    if (!response.ok) {\n      return {\n        success: false,\n        error: `HTTP error! status: ${response.status}`,\n        status: response.status,\n      } as T;\n    }\n\n    // Determine response parsing based on URL\n    let data;\n    if (url.includes('/multi') || url.includes('/search')) {\n      data = await response.json();\n    } else {\n      data = await response.text();\n    }\n\n    return {\n      success: true,\n      data: data,\n    } as T;\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    } as T;\n  }\n}\n\n// Parse function string to extract function name and parameters\nexport function parseFunctionString(func: string): {\n  func: string;\n  params: FetchFuncParams;\n} {\n  const questionMarkIndex = func.indexOf('?');\n\n  if (questionMarkIndex !== -1) {\n    // Function has query parameters - extract them\n    const functionName = func.substring(0, questionMarkIndex);\n    const queryString = func.substring(questionMarkIndex + 1);\n\n    // Parse query parameters into an object\n    const params: FetchFuncParams = {};\n    const searchParams = new URLSearchParams(queryString);\n\n    for (const [key, value] of searchParams.entries()) {\n      // Try to parse as number if possible\n      const numValue = parseFloat(value);\n      params[key] = isNaN(numValue) ? value : numValue;\n    }\n\n    return { func: functionName, params };\n  } else {\n    // Simple function with no parameters\n    return { func: func, params: {} };\n  }\n}\n","// Centralized style tokens for injected UI (avoid dependency on site CSS)\n\nexport const GOFAKEIT_COLORS = {\n  primary: '#ffa000',\n  white: '#ffffff',\n  success: '#48c774',\n  error: '#ff3860',\n  info: '#209cee',\n  text: '#333333',\n  border: '#686868',\n  background: '#22272e',\n};\n\nexport const GOFAKEIT_SPACING = {\n  base: 16, // px\n  half: 8, // px\n  quarter: 4, // px\n};\n\nexport const GOFAKEIT_BORDER = {\n  radius: 4, // px\n  width: 2, // px\n};\n\nexport const GOFAKEIT_FONT = {\n  size: 12, // px\n  family: 'Helvetica, Arial, sans-serif',\n};\n","import {\n  fetchFuncMulti,\n  FetchFuncMultiRequest,\n  fetchFuncSearch,\n  FetchFuncSearchRequest,\n  FetchFuncParams,\n} from './api';\nimport {\n  GOFAKEIT_COLORS,\n  GOFAKEIT_SPACING,\n  GOFAKEIT_BORDER,\n  GOFAKEIT_FONT,\n} from './styles';\n\nexport enum AutofillStatus {\n  STARTING = 'starting',\n  FOUND = 'found',\n  DETERMINED = 'determined',\n  GENERATED = 'generated',\n  SET = 'set',\n  COMPLETED = 'completed',\n  ERROR = 'error',\n}\n\nexport interface AutofillSettings {\n  mode?: 'auto' | 'manual';\n  stagger?: number;\n  badges?: number;\n  debug?: boolean;\n\n  // Callbacks\n  onStatusChange?: (\n    status: AutofillStatus,\n    elements: AutofillElement[]\n  ) => void;\n}\n\nexport interface AutofillState {\n  status?: AutofillStatus;\n  elements: AutofillElement[];\n}\n\nexport interface AutofillElement {\n  id: string; // id of the element\n  name: string; // name of the element\n  element: Element; // element to autofill\n  type: string; // element type\n  function: string; // function that will be used to autofill the element\n  params?: Record<string, any>; // parameters for the function\n  search: string; // search query that will be used to autofill the element\n  value: string; // value of the autofill result\n  error: string; // error message\n}\n\nexport interface AutofillResult {\n  elements: AutofillElement[];\n  error?: string;\n}\n\nexport interface AutofillResults {\n  success: number;\n  failed: number;\n  elements: AutofillElement[];\n}\n\nexport class Autofill {\n  public settings: AutofillSettings;\n  public state: AutofillState;\n\n  constructor(settings: AutofillSettings = {}) {\n    this.settings = {\n      mode: 'auto',\n      stagger: 50,\n      badges: 3000,\n      debug: false,\n      ...settings,\n    };\n\n    this.state = {\n      elements: [],\n    };\n  }\n\n  public updateSettings(settings: AutofillSettings): void {\n    this.settings = { ...this.settings, ...settings };\n  }\n\n  // ============================================================================\n  // MAIN FILL FUNCTION\n  // ============================================================================\n\n  async fill(\n    target?: HTMLElement | Element | string,\n    functionName?: string,\n    params?: Record<string, any>\n  ): Promise<AutofillResults> {\n    this.state.elements = []; // Clear previous elements\n    this.updateStatus(AutofillStatus.STARTING);\n\n    // Step 1: Set all target elements based on the target parameter\n    this.setElements(target);\n    if (this.state.elements.length === 0) {\n      this.debug('info', 'No form fields found to fill');\n      this.updateStatus(AutofillStatus.COMPLETED);\n      return this.results();\n    }\n    this.updateStatus(AutofillStatus.FOUND);\n\n    // Step 2: Determine functions for elements that need search\n    await this.setElementFunctions(functionName, params);\n    this.updateStatus(AutofillStatus.DETERMINED);\n\n    // Step 3: Get values for all elements via multi-function API\n    await this.getElementValues();\n    this.updateStatus(AutofillStatus.GENERATED);\n\n    // Step 4: set values to the actual form elements\n    await this.setElementValues();\n    this.updateStatus(AutofillStatus.SET);\n\n    // Return the results\n    this.updateStatus(AutofillStatus.COMPLETED);\n    return this.results();\n  }\n\n  // ============================================================================\n  // Step 1: Set all target elements based on the target parameter\n  // ============================================================================\n\n  // Public method to set form elements based on target parameter\n  public setElements(target?: HTMLElement | Element | string): void {\n    const allFormElements: Element[] = [];\n\n    if (target) {\n      if (typeof target === 'string') {\n        // For string selectors, get the matching elements and search within them\n        const elements = document.querySelectorAll(target);\n        if (elements.length === 0) {\n          this.debug('error', `No element found with selector: \"${target}\"`);\n          this.updateStatus(AutofillStatus.ERROR);\n          this.state.elements = [];\n          return;\n        }\n        // Search within each matching element for form elements\n        elements.forEach(el => {\n          if (\n            el instanceof HTMLInputElement ||\n            el instanceof HTMLTextAreaElement ||\n            el instanceof HTMLSelectElement\n          ) {\n            // If the element itself is a form element, add it\n            if (this.shouldSkipElement(el)) return;\n            allFormElements.push(el);\n          } else {\n            // If it's not a form element, search within it for form elements\n            const selector = 'input, textarea, select';\n            const nodeList = el.querySelectorAll(selector);\n\n            nodeList.forEach(formEl => {\n              // Skip hidden, disabled, or readonly elements\n              if (this.shouldSkipElement(formEl)) return;\n              allFormElements.push(formEl);\n            });\n          }\n        });\n      } else if (target instanceof HTMLElement || target instanceof Element) {\n        // For element targets, check if the element itself is a form element\n        if (\n          target instanceof HTMLInputElement ||\n          target instanceof HTMLTextAreaElement ||\n          target instanceof HTMLSelectElement\n        ) {\n          // Skip hidden, disabled, or readonly elements\n          if (this.shouldSkipElement(target)) {\n            this.state.elements = [];\n            return;\n          }\n          allFormElements.push(target);\n        } else {\n          // If it's not a form element, search within it\n          const selector = 'input, textarea, select';\n          const nodeList = target.querySelectorAll(selector);\n\n          nodeList.forEach(el => {\n            // Skip hidden, disabled, or readonly elements\n            if (this.shouldSkipElement(el)) return;\n            allFormElements.push(el);\n          });\n        }\n      }\n    } else {\n      // No target specified, search the entire document\n      const selector = 'input, textarea, select';\n      const nodeList = document.querySelectorAll(selector);\n\n      nodeList.forEach(el => {\n        // Skip hidden, disabled, or readonly elements\n        if (this.shouldSkipElement(el)) return;\n        allFormElements.push(el);\n      });\n    }\n\n    // Step 3: Filter elements based on mode and data-gofakeit attributes\n    const mode = this.settings.mode ?? 'auto';\n    const filteredElements: Element[] = [];\n\n    for (const element of allFormElements) {\n      const gofakeitFunc = element.getAttribute('data-gofakeit');\n\n      // Skip if explicitly disabled\n      if (\n        typeof gofakeitFunc === 'string' &&\n        gofakeitFunc.trim().toLowerCase() === 'false'\n      ) {\n        continue;\n      }\n\n      // In manual mode, only include elements with data-gofakeit attribute\n      if (mode === 'manual' && !gofakeitFunc) {\n        continue;\n      }\n\n      // In auto mode, include all elements (with or without data-gofakeit)\n      filteredElements.push(element);\n    }\n\n    // Loop through filteredElements and create AutofillElement objects\n    const autofillElements: AutofillElement[] = [];\n    for (const element of filteredElements) {\n      // random 8 digit alphanumeric string\n      const id =\n        Math.random().toString(36).substring(2, 15) +\n        Math.random().toString(36).substring(2, 15);\n\n      // add new element to the autofillElements array\n      autofillElements.push({\n        id: id,\n        name: element.getAttribute('name') || '',\n        element,\n        type: this.getElementType(element),\n        function: '',\n        search: this.getElementSearch(element as HTMLInputElement),\n        value: '',\n        error: '',\n      });\n    }\n\n    this.state.elements = autofillElements;\n\n    // Debug output for element selection\n    if (autofillElements.length > 0) {\n      this.debug(\n        'info',\n        `Found ${autofillElements.length} elements to generate data for`\n      );\n    }\n  }\n\n  // Check if an element should be skipped (hidden, disabled, or readonly)\n  public shouldSkipElement(element: Element): boolean {\n    if (element instanceof HTMLInputElement) {\n      return element.type === 'hidden' || element.disabled || element.readOnly;\n    } else if (element instanceof HTMLTextAreaElement) {\n      return element.disabled || element.readOnly;\n    } else if (element instanceof HTMLSelectElement) {\n      return element.disabled;\n    }\n    return false;\n  }\n\n  // Get the element type\n  private getElementType(element: Element): string {\n    if (element instanceof HTMLInputElement) {\n      return element.type.toLowerCase();\n    } else if (element instanceof HTMLTextAreaElement) {\n      return 'textarea';\n    } else if (element instanceof HTMLSelectElement) {\n      return 'select';\n    }\n    return 'unknown';\n  }\n\n  // Get the comprehensive search string for an element\n  public getElementSearch(el: Element): string {\n    // Get label text from various sources\n    const labelTexts: string[] = [];\n    const id = el.id;\n\n    // aria-labelledby\n    const labelledBy = el.getAttribute('aria-labelledby');\n    if (labelledBy) {\n      labelledBy.split(/\\s+/).forEach(ref => {\n        const labelEl = document.getElementById(ref);\n        if (labelEl && labelEl.textContent)\n          labelTexts.push(labelEl.textContent);\n      });\n    }\n\n    // explicit label[for]\n    if (id) {\n      const lbl = document.querySelector(\n        'label[for=\"' + id.replace(/\"/g, '\\\\\"') + '\"]'\n      ) as HTMLLabelElement | null;\n      if (lbl && lbl.textContent) labelTexts.push(lbl.textContent);\n    }\n\n    // implicit parent label\n    const closestLabel = el.closest('label');\n    if (closestLabel && closestLabel.textContent)\n      labelTexts.push(closestLabel.textContent);\n\n    // previous sibling label (common in some UIs)\n    const prev = el.previousElementSibling as HTMLElement | null;\n    if (prev && prev.tagName === 'LABEL' && prev.textContent)\n      labelTexts.push(prev.textContent);\n\n    const labelText = labelTexts.join(' ').toLowerCase();\n\n    // Get additional element attributes for comprehensive search\n    const type = el instanceof HTMLInputElement ? el.type.toLowerCase() : '';\n    const name = (el.getAttribute('name') || '').toLowerCase();\n    const elementId = (el.id || '').toLowerCase();\n    const placeholder =\n      el instanceof HTMLInputElement\n        ? (el.placeholder || '').toLowerCase()\n        : '';\n    const autocomplete =\n      el instanceof HTMLInputElement\n        ? (el.autocomplete || '').toLowerCase()\n        : '';\n    const ariaLabel = (el.getAttribute('aria-label') || '').toLowerCase();\n\n    // Build a comprehensive search query with all available information\n    const queryParts = [\n      type,\n      name,\n      elementId,\n      placeholder,\n      autocomplete,\n      ariaLabel,\n      labelText,\n    ].filter(part => part && part.trim());\n\n    // Join all parts with spaces to create a comprehensive search query\n    const searchQuery = queryParts\n      .join(' ')\n      .toLowerCase()\n      .replace(/[^\\w\\s]/g, ' ') // Remove special characters\n      .replace(/\\s+/g, ' ') // Normalize whitespace\n      .trim();\n\n    return searchQuery;\n  }\n\n  // ============================================================================\n  // Step 2: Determine functions for elements that need search\n  // ============================================================================\n\n  public async setElementFunctions(\n    functionOverride?: string,\n    params?: Record<string, any>\n  ): Promise<void> {\n    this.debug(\n      'info',\n      `Determining functions for ${this.state.elements.length} elements`\n    );\n\n    // If function override is provided, apply it to all elements\n    if (functionOverride) {\n      this.debug('info', `Using function override: ${functionOverride}`);\n      for (const el of this.state.elements) {\n        el.function = functionOverride;\n        if (params) {\n          el.params = params;\n        }\n      }\n      return;\n    }\n\n    // Step 1: Loop through elements and set functions for types that don't need search\n    const elementsNeedingSearch: AutofillElement[] = [];\n\n    for (const el of this.state.elements) {\n      const functionName = this.getElementFunction(el.element);\n\n      if (functionName !== null) {\n        // Function determined - use it directly\n        el.function = functionName;\n      } else {\n        // Function needs search - add to search array\n        elementsNeedingSearch.push(el);\n      }\n    }\n\n    // Step 2: Handle elements that need search\n    if (elementsNeedingSearch.length > 0) {\n      this.debug(\n        'info',\n        `${elementsNeedingSearch.length} elements need function search`\n      );\n\n      // Create search requests using existing search values from state\n      const searchRequests: FetchFuncSearchRequest[] =\n        elementsNeedingSearch.map((el, index) => {\n          return {\n            id:\n              el.element.id ||\n              el.element.getAttribute('name') ||\n              `input_${index}`,\n            query: el.search,\n          };\n        });\n\n      const response = await fetchFuncSearch(searchRequests);\n\n      if (response.success && response.data) {\n        // Map results back to elements - use first result regardless of score\n        for (let i = 0; i < response.data.length; i++) {\n          const searchResult = response.data[i];\n          const el = elementsNeedingSearch[i];\n\n          if (searchResult.results && searchResult.results.length > 0) {\n            // Use the first result, not based on score\n            el.function = searchResult.results[0].name;\n          } else {\n            // Fallback to type-specific function if no search results\n            el.function = this.getElementFunctionFallback(el.element);\n          }\n        }\n      } else {\n        // Fallback to type-specific functions if search fails\n        for (const el of elementsNeedingSearch) {\n          el.function = this.getElementFunctionFallback(el.element);\n        }\n      }\n    }\n\n    this.debug('info', 'Function determination complete');\n  }\n\n  public getElementFunction(element: Element): string | null {\n    const gofakeitFunc = element.getAttribute('data-gofakeit');\n    const elementType = this.getElementType(element);\n\n    if (gofakeitFunc && gofakeitFunc !== 'true') {\n      // Specific function provided - use it directly\n      return gofakeitFunc;\n    } else if (gofakeitFunc === 'true') {\n      // Function is 'true' - check if element type needs search\n      const needsSearch = this.elementTypeNeedsSearch(elementType);\n\n      if (needsSearch) {\n        // Element type needs search - return null\n        return null;\n      } else {\n        // Element type doesn't need search - use fallback function even with data-gofakeit=\"true\"\n        return this.getElementFunctionFallback(element);\n      }\n    } else {\n      // No function specified - check if element type needs search\n      const needsSearch = this.elementTypeNeedsSearch(elementType);\n\n      if (needsSearch) {\n        // Element type needs search - return null\n        return null;\n      } else {\n        // Element type doesn't need search - use fallback function\n        return this.getElementFunctionFallback(element);\n      }\n    }\n  }\n\n  private elementTypeNeedsSearch(elementType: string): boolean {\n    const skipSearchTypes = [\n      'checkbox',\n      'radio',\n      'select',\n      'number',\n      'range',\n      'file',\n      'button',\n      'submit',\n      'reset',\n      'image',\n      'week',\n      'date',\n      'time',\n      'datetime-local',\n      'month',\n      'color',\n    ];\n    return !skipSearchTypes.includes(elementType);\n  }\n\n  // If the element doesnt have a function and search doesnt return a function,\n  // we will use a fallback function\n  private getElementFunctionFallback(element: Element): string {\n    if (element instanceof HTMLInputElement) {\n      const elementType = element.type.toLowerCase();\n\n      switch (elementType) {\n        case 'date':\n        case 'datetime-local':\n        case 'month':\n        case 'week': {\n          // Check if input has min/max attributes to determine if it should use daterange\n          const min = element.getAttribute('min');\n          const max = element.getAttribute('max');\n          return min || max ? 'daterange' : 'date';\n        }\n        case 'time':\n          return 'time';\n        case 'text':\n          return 'word';\n        case 'email':\n          return 'email';\n        case 'tel':\n          return 'phone';\n        case 'url':\n          return 'url';\n        case 'password':\n          return 'password';\n        case 'search':\n          return 'word';\n        case 'number':\n        case 'range': {\n          // Check if input has min/max attributes to determine if it should use number with parameters\n          const min = element.getAttribute('min');\n          const max = element.getAttribute('max');\n          return min || max ? 'number' : 'number'; // Both use 'number' function, but with different parameters\n        }\n        case 'color':\n          return 'hexcolor';\n        case 'checkbox':\n          return 'bool';\n        case 'radio':\n          return 'randomstring';\n        default:\n          return 'word';\n      }\n    } else if (element instanceof HTMLTextAreaElement) {\n      return 'sentence';\n    } else if (element instanceof HTMLSelectElement) {\n      return 'randomstring';\n    }\n\n    return 'word';\n  }\n\n  // ============================================================================\n  // Step 3: Get values for all elements via multi-function API\n  // ============================================================================\n\n  // Get values for all elements via multi-function API\n  public async getElementValues(): Promise<void> {\n    this.debug('info', 'Starting value generation...');\n    const elementsNeedingValues = this.state.elements.filter(\n      el => el.function && !el.error\n    );\n\n    if (elementsNeedingValues.length === 0) {\n      this.debug('info', 'No elements need value generation');\n      return;\n    }\n\n    this.debug(\n      'info',\n      `Getting values for ${elementsNeedingValues.length} elements from API`\n    );\n\n    const requests: FetchFuncMultiRequest[] = [];\n    const processedNames: string[] = []; // Track processed radio group names\n    const requestToElementMap: AutofillElement[] = []; // Map requests to elements\n\n    // Process each element, adding parameters based on function type\n    for (const el of elementsNeedingValues) {\n      // Skip radio elements that are part of a group we've already processed\n      if (el.type === 'radio' && el.name && processedNames.includes(el.name)) {\n        continue;\n      }\n\n      const request: FetchFuncMultiRequest = {\n        id: el.id,\n        func: el.function,\n      };\n\n      // Use custom params if provided, otherwise use default parameter logic\n      if (el.params) {\n        request.params = el.params;\n      } else {\n        // Add parameters based on element type\n        switch (el.type) {\n          case 'select':\n            request.params = this.paramsSelect(el.element as HTMLSelectElement);\n            break;\n          case 'radio': {\n            // For radio groups, get all radio elements with the same name\n            const radioGroup = elementsNeedingValues.filter(\n              otherEl => otherEl.type === 'radio' && otherEl.name === el.name\n            );\n            request.params = this.paramsRadio(radioGroup);\n            // Mark this radio group as processed\n            if (el.name) {\n              processedNames.push(el.name);\n            }\n            break;\n          }\n          case 'date':\n          case 'datetime-local':\n          case 'month': {\n            const params = this.paramsDate(el);\n            if (params && (params.startdate || params.enddate)) {\n              request.func = 'daterange';\n              request.params = params;\n            } else {\n              request.params = params;\n            }\n            break;\n          }\n          case 'time': {\n            // For time inputs, use 'time' function with format\n            request.params = { format: 'HH:mm' };\n            break;\n          }\n          case 'week': {\n            const params = this.paramsWeek(el);\n            if (params && (params.startdate || params.enddate)) {\n              request.func = 'daterange';\n              request.params = params;\n            } else {\n              request.func = 'date';\n              request.params = params;\n            }\n            break;\n          }\n          case 'number':\n          case 'range': {\n            const params = this.paramsNumber(el);\n            request.params = params;\n            break;\n          }\n          // Add other element type cases here as needed\n          default:\n            // No special parameters needed\n            break;\n        }\n      }\n\n      requests.push(request);\n      requestToElementMap.push(el);\n    }\n\n    const response = await fetchFuncMulti(requests);\n\n    if (response.success && response.data) {\n      // Map results back to elements using the correct mapping\n      for (let i = 0; i < response.data.length; i++) {\n        const result = response.data[i];\n        const el = requestToElementMap[i];\n\n        if (result.value !== null && result.value !== undefined) {\n          el.value = String(result.value);\n        } else if (result.error) {\n          el.error = result.error;\n        } else {\n          el.error = 'Unknown API error';\n        }\n      }\n    } else {\n      // Set error for all elements if the request failed\n      for (const el of elementsNeedingValues) {\n        el.error = response.error || 'API request failed';\n      }\n    }\n\n    this.debug('info', 'Value generation complete');\n  }\n\n  // ============================================================================\n  // Step 4: Set values to the actual form elements\n  // ============================================================================\n\n  // Set values to the actual form elements\n  public async setElementValues(): Promise<void> {\n    this.debug('info', 'Starting value application...');\n    if (this.state.elements.length === 0) {\n      this.debug('info', 'No elements to apply values to');\n      return;\n    }\n\n    this.debug('info', `Processing ${this.state.elements.length} elements`);\n\n    // Track processed radio group names to avoid duplicate badges\n    const processedRadioNames: string[] = [];\n\n    // Process all elements with optional staggering and show badges for each\n    for (let i = 0; i < this.state.elements.length; i++) {\n      const el = this.state.elements[i];\n      let elementToShowBadge: AutofillElement | null = null;\n\n      // Handle different element types\n      switch (el.type) {\n        case 'radio':\n          // Only process if we haven't already processed this radio group\n          if (el.name && !processedRadioNames.includes(el.name)) {\n            processedRadioNames.push(el.name);\n            elementToShowBadge = this.setRadioGroup(el);\n          }\n          break;\n        default:\n          // Only set value if el has a valid value and no error\n          if (el.value !== undefined && el.value !== null && !el.error) {\n            this.setElementValue(el);\n          }\n          elementToShowBadge = el;\n          break;\n      }\n\n      // Show badge for the appropriate element\n      if (\n        this.settings.badges &&\n        this.settings.badges > 0 &&\n        elementToShowBadge\n      ) {\n        this.showBadge(elementToShowBadge);\n      }\n\n      // Add delay between applications (except for the last one) if stagger is enabled\n      if (\n        this.settings.stagger &&\n        this.settings.stagger > 0 &&\n        i < this.state.elements.length - 1\n      ) {\n        await new Promise(resolve =>\n          setTimeout(resolve, this.settings.stagger)\n        );\n      }\n    }\n\n    this.debug('info', 'Value application complete');\n  }\n\n  private setRadioGroup(el: AutofillElement): AutofillElement | null {\n    // Find all radio elements in the same group\n    const radioGroup = this.state.elements.filter(\n      otherEl => otherEl.type === 'radio' && otherEl.name === el.name\n    );\n\n    // Find the radio element that matches the returned value\n    const selectedRadio = radioGroup.find(radioEl => {\n      const input = radioEl.element as HTMLInputElement;\n\n      // Check if the value attribute is explicitly set\n      const hasExplicitValue = input.hasAttribute('value');\n\n      // First try to match by value attribute if it's explicitly set or not the default \"on\"\n      if (\n        (hasExplicitValue || input.value !== 'on') &&\n        input.value === el.value\n      ) {\n        return true;\n      }\n\n      // If value is \"on\" (default) or no match, try to match by label text\n      const label = document.querySelector(`label[for=\"${input.id}\"]`);\n      if (label && label.textContent && label.textContent.trim() === el.value) {\n        return true;\n      }\n\n      // Final fallback: match by id\n      if (input.id === el.value) {\n        return true;\n      }\n\n      return false;\n    });\n\n    if (selectedRadio && !selectedRadio.error) {\n      // Uncheck all radios in the same group first\n      const radioName = (selectedRadio.element as HTMLInputElement).name;\n      if (radioName) {\n        const otherRadios = document.querySelectorAll(\n          `input[type=\"radio\"][name=\"${radioName}\"]`\n        );\n        otherRadios.forEach(radio => {\n          (radio as HTMLInputElement).checked = false;\n        });\n      }\n\n      // Check the selected radio button\n      (selectedRadio.element as HTMLInputElement).checked = true;\n      (selectedRadio.element as HTMLInputElement).dispatchEvent(\n        new Event('change', { bubbles: true })\n      );\n\n      // Return the selected radio element for badge display\n      return selectedRadio;\n    } else if (el.error) {\n      // Return the original element if there's an error\n      return el;\n    }\n\n    return null;\n  }\n\n  private setElementValue(el: AutofillElement): void {\n    const element = el.element;\n\n    if (element instanceof HTMLInputElement) {\n      const elementType = element.type.toLowerCase();\n\n      switch (elementType) {\n        case 'checkbox':\n          this.setCheckboxValue(element, el.value);\n          break;\n        case 'radio':\n          this.setRadioValue(element, el.value);\n          break;\n        case 'number':\n        case 'range':\n        case 'date':\n        case 'time':\n        case 'datetime-local':\n        case 'month':\n        case 'color':\n          this.setGeneralValue(element, el.value);\n          break;\n        case 'week':\n          // Convert date value to week format\n          this.setGeneralValue(element, this.convertDateToWeek(el.value));\n          break;\n        default:\n          this.setGeneralValue(element, el.value);\n      }\n    } else if (element instanceof HTMLTextAreaElement) {\n      this.setGeneralValue(element, el.value);\n    } else if (element instanceof HTMLSelectElement) {\n      this.setSelectValue(element, el.value);\n    }\n  }\n\n  // ============================================================================\n  // ELEMENT TYPE SPECIFIC FUNCTIONS\n  // ============================================================================\n\n  private setGeneralValue(\n    element: HTMLInputElement | HTMLTextAreaElement,\n    value: string\n  ): void {\n    element.value = value;\n    element.dispatchEvent(new Event('input', { bubbles: true }));\n    element.dispatchEvent(new Event('change', { bubbles: true }));\n  }\n\n  private setCheckboxValue(\n    element: HTMLInputElement,\n    value: string | boolean\n  ): void {\n    const boolValue = value === 'true' || value === true;\n    element.checked = boolValue;\n    element.dispatchEvent(new Event('change', { bubbles: true }));\n  }\n\n  private setRadioValue(\n    element: HTMLInputElement,\n    value: string | boolean\n  ): void {\n    const boolValue = value === 'true' || value === true;\n\n    if (boolValue) {\n      // Uncheck other radios in the same group\n      const radioName = element.name;\n      if (radioName) {\n        const otherRadios = document.querySelectorAll(\n          `input[type=\"radio\"][name=\"${radioName}\"]`\n        );\n        otherRadios.forEach(radio => {\n          if (radio !== element) {\n            (radio as HTMLInputElement).checked = false;\n          }\n        });\n      }\n\n      element.checked = true;\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n    } else {\n      element.checked = false;\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n    }\n  }\n\n  private setSelectValue(element: HTMLSelectElement, value: string): void {\n    // Try to find an option with the exact value\n    const exactMatch = Array.from(element.options).find(\n      option => option.value === value\n    );\n    if (exactMatch) {\n      element.value = value;\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n      return;\n    }\n\n    // Try to find an option with matching text content\n    const textMatch = Array.from(element.options).find(option =>\n      option.textContent?.toLowerCase().includes(value.toLowerCase())\n    );\n    if (textMatch) {\n      element.value = textMatch.value;\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n      return;\n    }\n\n    // Fallback: select a random non-empty option\n    const nonEmptyOptions = Array.from(element.options).filter(\n      option => option.value && option.value.trim() !== ''\n    );\n    if (nonEmptyOptions.length > 0) {\n      const randomOption =\n        nonEmptyOptions[Math.floor(Math.random() * nonEmptyOptions.length)];\n      element.value = randomOption.value;\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n    }\n  }\n\n  private showBadge(el: AutofillElement): void {\n    // Remove any existing badge for this element\n    this.removeBadge(el.id);\n\n    // Create badge element with optimized styling\n    const badge = document.createElement('div');\n    badge.id = `gofakeit-badge-${el.id}`;\n    const isError = Boolean(el.error && el.error.trim() !== '');\n    badge.textContent = isError ? el.error : el.function;\n\n    // Batch all style changes to minimize reflows\n    const badgeStyles = {\n      position: 'fixed',\n      zIndex: '999999',\n      padding: `${GOFAKEIT_SPACING.quarter}px ${GOFAKEIT_SPACING.half}px`,\n      borderRadius: `${GOFAKEIT_BORDER.radius}px`,\n      fontSize: `${GOFAKEIT_FONT.size}px`,\n      fontWeight: 'bold',\n      fontFamily: GOFAKEIT_FONT.family,\n      boxShadow: '0 2px 4px rgba(0,0,0,0.2)',\n      pointerEvents: 'none',\n      userSelect: 'none',\n      transition: 'opacity 0.3s ease-in-out',\n      opacity: '0',\n      whiteSpace: 'nowrap',\n      backgroundColor: isError\n        ? GOFAKEIT_COLORS.error\n        : GOFAKEIT_COLORS.primary,\n      color: isError ? GOFAKEIT_COLORS.white : GOFAKEIT_COLORS.text,\n    };\n\n    // Apply all styles at once\n    Object.assign(badge.style, badgeStyles);\n\n    // Append badge to body\n    document.body.appendChild(badge);\n\n    // Performance optimizations\n    let lastRect: DOMRect | null = null;\n    let animationId: number | null = null;\n    let isVisible = true;\n    let lastVisibilityCheck = 0;\n    const VISIBILITY_CHECK_INTERVAL = 100; // Check visibility every 100ms instead of every frame\n\n    // Cache scrollable parents to avoid repeated DOM traversal\n    const scrollableParents = this.getScrollableParents(el.element);\n    const parentRects = new Map<Element, DOMRect>();\n\n    // Function to check if element is visible (optimized)\n    const checkElementVisibility = (element: Element): boolean => {\n      const rect = element.getBoundingClientRect();\n\n      // Quick window viewport check first\n      if (\n        rect.top < 0 ||\n        rect.left < 0 ||\n        rect.bottom > window.innerHeight ||\n        rect.right > window.innerWidth\n      ) {\n        return false;\n      }\n\n      // Check cached scrollable parents\n      for (const parent of scrollableParents) {\n        let parentRect = parentRects.get(parent);\n        if (!parentRect) {\n          parentRect = parent.getBoundingClientRect();\n          parentRects.set(parent, parentRect);\n        }\n\n        // Check if element is within parent bounds\n        if (\n          rect.top < parentRect.top ||\n          rect.left < parentRect.left ||\n          rect.bottom > parentRect.bottom ||\n          rect.right > parentRect.right\n        ) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    // Optimized position update function\n    const updateBadgePosition = () => {\n      const rect = el.element.getBoundingClientRect();\n\n      // Check if element has moved (position or size changed)\n      const hasMoved =\n        !lastRect ||\n        rect.top !== lastRect.top ||\n        rect.left !== lastRect.left ||\n        rect.width !== lastRect.width ||\n        rect.height !== lastRect.height;\n\n      if (hasMoved) {\n        lastRect = rect;\n\n        // Only check visibility periodically to reduce DOM queries\n        const now = performance.now();\n        if (now - lastVisibilityCheck > VISIBILITY_CHECK_INTERVAL) {\n          isVisible = checkElementVisibility(el.element);\n          lastVisibilityCheck = now;\n          // Clear parent rects cache periodically\n          parentRects.clear();\n        }\n\n        if (isVisible) {\n          // Position badge above the element\n          const top = rect.top - 30; // Offset based upon badge size\n          const left = rect.left;\n\n          // Batch style updates to minimize reflows\n          badge.style.cssText += `top:${top}px;left:${left}px;display:block;`;\n        } else {\n          // Hide badge if element is not visible\n          badge.style.display = 'none';\n        }\n      }\n\n      // Continue the animation loop\n      animationId = requestAnimationFrame(updateBadgePosition);\n    };\n\n    // Start the position tracking loop\n    updateBadgePosition();\n\n    // Store animation ID for cleanup\n    (badge as any)._animationId = animationId;\n\n    // Trigger fade-in animation\n    requestAnimationFrame(() => {\n      badge.style.opacity = '1';\n    });\n\n    // Auto-remove after duration with fade-out animation\n    setTimeout(() => {\n      this.removeBadge(el.id);\n    }, this.settings.badges);\n  }\n\n  // Helper method to cache scrollable parents\n  private getScrollableParents(element: Element): Element[] {\n    const scrollableParents: Element[] = [];\n    let parent = element.parentElement;\n\n    while (parent && parent !== document.body) {\n      const style = getComputedStyle(parent);\n      const overflow = style.overflow + style.overflowY + style.overflowX;\n\n      if (overflow.includes('scroll') || overflow.includes('auto')) {\n        scrollableParents.push(parent);\n      }\n\n      parent = parent.parentElement;\n    }\n\n    return scrollableParents;\n  }\n\n  private removeBadge(autofillElementId: string): void {\n    const existingBadge = document.getElementById(\n      `gofakeit-badge-${autofillElementId}`\n    );\n\n    // If badge doesn't exist, return\n    if (!existingBadge) {\n      return;\n    }\n\n    // Clean up animation frame immediately\n    const animationId = (existingBadge as any)._animationId;\n    if (animationId) {\n      cancelAnimationFrame(animationId);\n      (existingBadge as any)._animationId = null; // Clear reference\n    }\n\n    // Trigger fade-out animation\n    existingBadge.style.opacity = '0';\n\n    // Remove element after animation completes\n    setTimeout(() => {\n      // Double-check badge still exists before removing\n      if (existingBadge.parentNode) {\n        existingBadge.remove();\n      }\n    }, 300); // Match the transition duration\n  }\n\n  // ============================================================================\n  // PARAMETER GENERATION FUNCTIONS\n  // ============================================================================\n\n  private paramsSelect(\n    element: HTMLSelectElement\n  ): FetchFuncParams | undefined {\n    const options = Array.from(element.options)\n      .map(option => option.value)\n      .filter(value => value !== ''); // Filter out empty values\n\n    if (options.length > 0) {\n      return {\n        strs: options,\n      };\n    }\n    return undefined;\n  }\n\n  private paramsRadio(\n    radioGroup: AutofillElement[]\n  ): FetchFuncParams | undefined {\n    const values = radioGroup\n      .map(el => {\n        const input = el.element as HTMLInputElement;\n\n        // Check if the value attribute is explicitly set\n        const hasExplicitValue = input.hasAttribute('value');\n\n        // Use value attribute if it's explicitly set or if it's not the default \"on\"\n        if (\n          hasExplicitValue ||\n          (input.value && input.value.trim() !== '' && input.value !== 'on')\n        ) {\n          return input.value;\n        }\n\n        // Fallback to label text\n        const label = document.querySelector(`label[for=\"${input.id}\"]`);\n        if (label && label.textContent) {\n          return label.textContent.trim();\n        }\n\n        // Final fallback to id\n        return input.id;\n      })\n      .filter(value => value !== ''); // Filter out empty values\n\n    if (values.length > 0) {\n      return {\n        strs: values,\n      };\n    }\n    return undefined;\n  }\n\n  private convertDateToWeek(dateValue: string): string {\n    // Convert date string (yyyy-MM-dd) to week format (yyyy-Www)\n    try {\n      const date = new Date(dateValue + 'T00:00:00');\n      const year = date.getFullYear();\n\n      // Get the week number using ISO week calculation\n      const startOfYear = new Date(year, 0, 1);\n      const days = Math.floor(\n        (date.getTime() - startOfYear.getTime()) / (24 * 60 * 60 * 1000)\n      );\n      const weekNumber = Math.ceil((days + startOfYear.getDay() + 1) / 7);\n\n      // Format as yyyy-Www (with leading zero for week number)\n      return `${year}-W${weekNumber.toString().padStart(2, '0')}`;\n    } catch (error) {\n      // If conversion fails, return a default week value\n      const currentYear = new Date().getFullYear();\n      return `${currentYear}-W01`;\n    }\n  }\n\n  private convertWeekToDate(weekValue: string): string {\n    // Convert week format (yyyy-Www) to date format (yyyy-MM-dd)\n    try {\n      const match = weekValue.match(/^(\\d{4})-W(\\d{2})$/);\n      if (!match) {\n        throw new Error('Invalid week format');\n      }\n\n      const year = parseInt(match[1]);\n      const week = parseInt(match[2]);\n\n      // Calculate the date for the first day of the week\n      const jan1 = new Date(year, 0, 1);\n      const daysToAdd = (week - 1) * 7;\n      const targetDate = new Date(\n        jan1.getTime() + daysToAdd * 24 * 60 * 60 * 1000\n      );\n\n      // Format as yyyy-MM-dd\n      const month = (targetDate.getMonth() + 1).toString().padStart(2, '0');\n      const day = targetDate.getDate().toString().padStart(2, '0');\n      return `${year}-${month}-${day}`;\n    } catch (error) {\n      // If conversion fails, return a default date\n      const currentYear = new Date().getFullYear();\n      return `${currentYear}-01-01`;\n    }\n  }\n\n  private paramsDate(el: AutofillElement): FetchFuncParams | undefined {\n    const input = el.element as HTMLInputElement;\n    const min = input.getAttribute('min');\n    const max = input.getAttribute('max');\n\n    // Determine format based on input type\n    let format: string;\n    switch (el.type) {\n      case 'datetime-local':\n        format = 'yyyy-MM-ddTHH:mm';\n        break;\n      case 'month':\n        format = 'yyyy-MM';\n        break;\n      case 'date':\n      default:\n        format = 'yyyy-MM-dd';\n        break;\n    }\n\n    const params: any = {\n      format: format,\n    };\n\n    // If no min/max attributes, return just format\n    if (!min && !max) {\n      return params;\n    }\n\n    // Set startdate (min) or allow api to use default\n    if (min) {\n      params.startdate = min;\n    }\n\n    // Set enddate (max) or allow api to use default\n    if (max) {\n      params.enddate = max;\n    }\n\n    return params;\n  }\n\n  private paramsWeek(el: AutofillElement): FetchFuncParams {\n    const input = el.element as HTMLInputElement;\n    const min = input.getAttribute('min');\n    const max = input.getAttribute('max');\n\n    const params: any = {\n      format: 'yyyy-MM-dd', // Week inputs use date format for API calls\n    };\n\n    // Convert week format min/max attributes to date format for API\n    if (min) {\n      params.startdate = this.convertWeekToDate(min);\n    }\n\n    if (max) {\n      params.enddate = this.convertWeekToDate(max);\n    }\n\n    return params;\n  }\n\n  private paramsNumber(el: AutofillElement): FetchFuncParams {\n    const input = el.element as HTMLInputElement;\n    const min = input.getAttribute('min');\n    const max = input.getAttribute('max');\n\n    const params: any = {};\n\n    if (min) {\n      params.min = parseInt(min, 10);\n    }\n    if (max) {\n      params.max = parseInt(max, 10);\n    }\n    return params;\n  }\n\n  // ============================================================================\n  // MISC UTILITY FUNCTIONS\n  // ============================================================================\n\n  // Debug logging function controlled by settings.debug\n  private debug(type: 'warning' | 'error' | 'info', message: string): void {\n    if (this.settings.debug) {\n      const prefix = `[Gofakeit] ${type.toUpperCase()}:`;\n\n      switch (type) {\n        case 'error':\n          console.error(prefix, message);\n          break;\n        case 'warning':\n          console.warn(prefix, message);\n          break;\n        case 'info':\n        default:\n          console.log(prefix, message);\n          break;\n      }\n    }\n  }\n\n  // Reset state to initial values - useful for testing\n  public resetState(): void {\n    this.state = {\n      elements: [],\n    };\n  }\n\n  // Update status and trigger callback\n  private updateStatus(status: AutofillStatus): void {\n    this.state.status = status;\n    if (this.settings.onStatusChange) {\n      // Create a copy of elements to prevent reference issues\n      const elementsCopy = [...this.state.elements];\n      this.settings.onStatusChange(status, elementsCopy);\n    }\n  }\n\n  private results(): AutofillResults {\n    const successfulElements = this.state.elements.filter(\n      element => element.value && !element.error\n    );\n    const failedElements = this.state.elements.filter(element => element.error);\n\n    // Prepare results data for callback\n    const resultsData: AutofillResults = {\n      success: successfulElements.length,\n      failed: failedElements.length,\n      elements: this.state.elements,\n    };\n\n    this.debug('info', `\\n🎯 Autofill Results Summary:`);\n    this.debug('info', `   Total elements: ${this.state.elements.length}`);\n    this.debug('info', `   Successful: ${successfulElements.length}`);\n    this.debug('info', `   Failed: ${failedElements.length}`);\n\n    // Show notification\n    if (successfulElements.length > 0 && failedElements.length === 0) {\n      this.debug(\n        'warning',\n        `Successfully generated data for ${successfulElements.length} fields!`\n      );\n    } else if (successfulElements.length > 0 && failedElements.length > 0) {\n      this.debug(\n        'warning',\n        `Generated data for ${successfulElements.length} fields, ${failedElements.length} failed`\n      );\n    } else if (failedElements.length > 0) {\n      this.debug(\n        'error',\n        `Failed to generate data for ${failedElements.length} fields`\n      );\n    } else {\n      this.debug('warning', 'No fields were processed');\n    }\n\n    return resultsData;\n  }\n}\n"],"names":["GOFAKEIT_API_BASE","fetchFunc","func","params","funcName","extractedParams","parseFunctionString","finalParams","makeRequest","fetchFuncMulti","requests","processedRequests","req","index","id","fetchFuncSearch","method","url","body","options","response","data","error","questionMarkIndex","functionName","queryString","searchParams","key","value","numValue","GOFAKEIT_COLORS","GOFAKEIT_SPACING","GOFAKEIT_BORDER","GOFAKEIT_FONT","AutofillStatus","Autofill","settings","target","allFormElements","elements","el","formEl","mode","filteredElements","element","gofakeitFunc","autofillElements","labelTexts","labelledBy","ref","labelEl","lbl","closestLabel","prev","labelText","type","name","elementId","placeholder","autocomplete","ariaLabel","part","functionOverride","elementsNeedingSearch","searchRequests","i","searchResult","elementType","min","max","elementsNeedingValues","processedNames","requestToElementMap","request","radioGroup","otherEl","result","processedRadioNames","elementToShowBadge","resolve","selectedRadio","radioEl","input","label","radioName","radio","boolValue","option","textMatch","nonEmptyOptions","randomOption","badge","isError","badgeStyles","lastRect","animationId","isVisible","lastVisibilityCheck","VISIBILITY_CHECK_INTERVAL","scrollableParents","parentRects","checkElementVisibility","rect","parent","parentRect","updateBadgePosition","now","top","left","style","overflow","autofillElementId","existingBadge","values","dateValue","date","year","startOfYear","days","weekNumber","weekValue","match","week","jan1","daysToAdd","targetDate","month","day","format","message","prefix","status","elementsCopy","successfulElements","failedElements","resultsData"],"mappings":"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"}