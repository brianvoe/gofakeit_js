{"version":3,"file":"index.cjs","sources":["../src/api.ts","../src/autofill.ts","../index.html?html-proxy&index=1.js"],"sourcesContent":["// Base URL for the Gofakeit API\nconst GOFAKEIT_API_BASE = 'https://api.gofakeit.com/funcs'\n\nexport interface ApiResponse {\n  success: boolean;\n  data?: string;\n  error?: string;\n  status?: number;\n}\n\n// Multi-function request interface\nexport interface MultiFuncRequest {\n  id?: string;\n  func: string;\n  params?: Record<string, unknown>;\n}\n\n// Multi-function response interface\nexport interface MultiFuncResponse {\n  id?: string;\n  value: string | null;\n  error: string;\n}\n\n// Multi-function API response interface\nexport interface MultiFuncApiResponse {\n  success: boolean;\n  data?: MultiFuncResponse[];\n  error?: string;\n  status?: number;\n}\n\n// Function search request interface\nexport interface FuncSearchRequest {\n  id: string;\n  query: string;\n}\n\n// Function search result interface\nexport interface FuncSearchResult {\n  name: string;     // function name for API usage\n  score: number;    // relevance score (0-100)\n  reasons: string[]; // why it matched\n}\n\n// Function search response interface\nexport interface FuncSearchResponse {\n  id: string;\n  query: string;\n  results: FuncSearchResult[];\n}\n\n// Multi-function search API response interface\nexport interface MultiFuncSearchApiResponse {\n  success: boolean;\n  data?: FuncSearchResponse[];\n  error?: string;\n  status?: number;\n}\n\n// Fetch data from gofakeit API\nexport async function callFunc(func: string): Promise<ApiResponse> {\n  // Check if the function contains query parameters\n  const questionMarkIndex = func.indexOf('?');\n  \n  if (questionMarkIndex !== -1) {\n    // Function has query parameters - use POST with JSON body\n    const functionName = func.substring(0, questionMarkIndex);\n    const queryString = func.substring(questionMarkIndex + 1);\n    \n    // Parse query parameters into an object\n    const params: Record<string, unknown> = {};\n    const searchParams = new URLSearchParams(queryString);\n    \n    for (const [key, value] of searchParams.entries()) {\n      // Try to parse as number if possible\n      const numValue = parseFloat(value);\n      params[key] = isNaN(numValue) ? value : numValue;\n    }\n    \n    return makeRequest('POST', `${GOFAKEIT_API_BASE}/${functionName}`, params);\n  } else {\n    // Simple function - use GET request\n    return makeRequest('GET', `${GOFAKEIT_API_BASE}/${func}`);\n  }\n}\n\n// Call multiple functions in a single request\nexport async function callMultiFunc(requests: MultiFuncRequest[]): Promise<MultiFuncApiResponse> {\n  if (requests.length === 0) {\n    return {\n      success: false,\n      error: 'No functions provided'\n    };\n  }\n\n  // Process each request to extract function name and parameters\n  const processedRequests: MultiFuncRequest[] = requests.map((req, index) => {\n    const { func, id } = req;\n    const questionMarkIndex = func.indexOf('?');\n    \n    if (questionMarkIndex !== -1) {\n      // Function has query parameters\n      const functionName = func.substring(0, questionMarkIndex);\n      const queryString = func.substring(questionMarkIndex + 1);\n      \n      // Parse query parameters into an object\n      const params: Record<string, unknown> = {};\n      const searchParams = new URLSearchParams(queryString);\n      \n      for (const [key, value] of searchParams.entries()) {\n        // Try to parse as number if possible\n        const numValue = parseFloat(value);\n        params[key] = isNaN(numValue) ? value : numValue;\n      }\n      \n      return {\n        id: id || `req_${index}`,\n        func: functionName,\n        params\n      };\n    } else {\n      // Simple function\n      return {\n        id: id || `req_${index}`,\n        func,\n        params: req.params\n      };\n    }\n  });\n\n  return makeMultiRequest('POST', `${GOFAKEIT_API_BASE}/multi`, processedRequests);\n}\n\n// Search for multiple functions in a single request\nexport async function searchMultiFunc(requests: FuncSearchRequest[]): Promise<MultiFuncSearchApiResponse> {\n  if (requests.length === 0) {\n    return {\n      success: false,\n      error: 'No search queries provided'\n    };\n  }\n\n  return makeSearchRequest('POST', `${GOFAKEIT_API_BASE}/search`, requests);\n}\n\n// Base HTTP request function\nasync function makeRequest(method: 'GET' | 'POST', url: string, body?: Record<string, unknown>): Promise<ApiResponse> {\n  try {\n    const options: {\n      method: string;\n      headers: Record<string, string>;\n      body?: string;\n    } = {\n      method: method,\n      headers: {\n        'Content-Type': 'application/json',\n      }\n    };\n\n    if (method === 'POST' && body) {\n      options.body = JSON.stringify(body);\n    }\n\n    const response = await fetch(url, options);\n    \n    if (!response.ok) {\n      return {\n        success: false,\n        error: `HTTP error! status: ${response.status}`,\n        status: response.status\n      };\n    }\n    \n    const data = await response.text();\n    return {\n      success: true,\n      data: data\n    };\n  } catch (error) {\n    console.error(`[Gofakeit Autofill] Error in ${method} request to ${url}:`, error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error'\n    };\n  }\n}\n\n// Multi-function HTTP request function\nasync function makeMultiRequest(method: 'GET' | 'POST', url: string, body: MultiFuncRequest[]): Promise<MultiFuncApiResponse> {\n  try {\n    const options: {\n      method: string;\n      headers: Record<string, string>;\n      body: string;\n    } = {\n      method: method,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(body)\n    };\n\n    const response = await fetch(url, options);\n    \n    if (!response.ok) {\n      return {\n        success: false,\n        error: `HTTP error! status: ${response.status}`,\n        status: response.status\n      };\n    }\n    \n    const data = await response.json();\n    return {\n      success: true,\n      data: data\n    };\n  } catch (error) {\n    console.error(`[Gofakeit Autofill] Error in ${method} request to ${url}:`, error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error'\n    };\n  }\n}\n\n// Multi-function search HTTP request function\nasync function makeSearchRequest(method: 'GET' | 'POST', url: string, body: FuncSearchRequest[]): Promise<MultiFuncSearchApiResponse> {\n  try {\n    const options: {\n      method: string;\n      headers: Record<string, string>;\n      body: string;\n    } = {\n      method: method,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(body)\n    };\n\n    const response = await fetch(url, options);\n    \n    if (!response.ok) {\n      return {\n        success: false,\n        error: `HTTP error! status: ${response.status}`,\n        status: response.status\n      };\n    }\n    \n    const data = await response.json();\n    return {\n      success: true,\n      data: data\n    };\n  } catch (error) {\n    console.error(`[Gofakeit Autofill] Error in ${method} request to ${url}:`, error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error'\n    };\n  }\n}\n","import { callMultiFunc, MultiFuncRequest, searchMultiFunc, FuncSearchRequest } from './api';\n\nexport interface AutofillSettings {\n  mode?: 'auto' | 'manual';\n  staggered?: boolean;\n  staggerDelay?: number;\n  onStatusChange?: (status: string, state: AutofillState) => void;\n}\n\nexport interface AutofillState {\n  status: string;\n  inputs: AutofillElement[];\n}\n\nexport interface AutofillElement {\n  element: Element; // element to autofill\n  type: string;     // input type\n  function: string; // function that will be used to autofill the input\n  value: string;    // value of the autofill result\n  error: string;    // error message\n}\n\nexport interface GetElementsResult {\n  elements: Element[];\n  error?: string;\n}\n\nexport class Autofill {\n  public settings: AutofillSettings;\n  public state: AutofillState;\n\n  constructor(settings: AutofillSettings = {}) {\n    this.settings = {\n      mode: 'auto',\n      staggered: true,\n      staggerDelay: 50,\n      ...settings\n    };\n    \n    this.state = {\n      status: 'idle',\n      inputs: []\n    };\n  }\n\n  // Update status and trigger callback\n  private updateStatus(status: string): void {\n    this.state.status = status;\n    if (this.settings.onStatusChange) {\n      // Create a copy of the state to avoid reference issues\n      const stateCopy = { ...this.state, inputs: [...this.state.inputs] };\n      this.settings.onStatusChange(status, stateCopy);\n    }\n  }\n\n  // Public API methods\n  async autofill(target?: HTMLElement | Element | string): Promise<boolean | void> {\n    this.updateStatus('starting');\n    this.state.inputs = [];\n\n    // Step 1: Get all target elements based on the target parameter\n    const result = this.getElements(target);\n    \n    if (result.error) {\n      console.warn(`[Gofakeit] ${result.error}`);\n      this.showNotification(result.error, 'error');\n      this.updateStatus('error');\n      return false;\n    }\n    \n    if (result.elements.length === 0) {\n      this.showNotification('No form fields found to autofill', 'info');\n      // Only set to idle if we're not already in error state\n      if (this.state.status !== 'error') {\n        this.updateStatus('idle');\n      }\n      return false;\n    }\n    \n    const elements = result.elements;\n\n    console.log(`[Gofakeit] Found ${elements.length} elements to generate data for`);\n    this.showNotification(`Starting data generation for ${elements.length} fields...`, 'info');\n\n    try {\n      // Step 2: Initialize inputs array with all target elements\n      await this.initializeInputs(elements);\n      this.updateStatus('initializing');\n\n      // Step 3: Determine functions for inputs that need search\n      await this.determineFunctions();\n      this.updateStatus('determining_functions');\n\n      // Step 4: Get values for all inputs via multi-function API\n      await this.getValues();\n      this.updateStatus('getting_values');\n\n      // Step 5: Apply values to the actual form elements\n      await this.applyValues();\n      this.updateStatus('applying_values');\n\n      this.updateStatus('completed');\n      return true;\n    } catch (error) {\n      console.error('[Gofakeit] Autofill process failed:', error);\n      this.updateStatus('error');\n      return false;\n    }\n  }\n\n  // Public method to get form elements based on target parameter\n  public getElements(target?: HTMLElement | Element | string): GetElementsResult {\n    // No parameters - get all form fields on the page\n    if (!target) {\n      return { elements: this.queryFormElements() };\n    }\n\n    // Handle string selectors (ID, class, complex CSS selectors)\n    if (typeof target === 'string') {\n      const elements = document.querySelectorAll(target);\n      if (elements.length === 0) {\n        return { \n          elements: [], \n          error: `No element found with selector: \"${target}\"` \n        };\n      }\n      \n      // If it's a single element, treat it as a container\n      if (elements.length === 1) {\n        const element = elements[0] as HTMLElement;\n        // Check if it's a form field itself\n        if ((element.tagName === 'INPUT' || element.tagName === 'TEXTAREA' || element.tagName === 'SELECT') &&\n            element.hasAttribute('data-gofakeit')) {\n          return { elements: [element] };\n        }\n        // Check if it contains form fields\n        const formFields = element.querySelectorAll('input, textarea, select');\n        if (formFields.length > 0) {\n          return { elements: this.queryFormElements(element) };\n        }\n        return { elements: [] };\n      }\n      \n      // If multiple elements, check each one\n      const formFields: Element[] = [];\n      elements.forEach(element => {\n        const htmlElement = element as HTMLElement;\n        if ((htmlElement.tagName === 'INPUT' || htmlElement.tagName === 'TEXTAREA' || htmlElement.tagName === 'SELECT') &&\n            htmlElement.hasAttribute('data-gofakeit')) {\n          formFields.push(element);\n        } else {\n          const nestedFormFields = htmlElement.querySelectorAll('input, textarea, select');\n          if (nestedFormFields.length > 0) {\n            formFields.push(...this.queryFormElements(htmlElement));\n          }\n        }\n      });\n      return { elements: formFields };\n    }\n\n    // Handle HTMLElement or Element\n    if (target instanceof HTMLElement) {\n      // Check if it's a form field itself\n      if ((target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.tagName === 'SELECT') &&\n          target.hasAttribute('data-gofakeit')) {\n        return { elements: [target] };\n      }\n      \n      // Check if it contains form fields\n      const formFields = target.querySelectorAll('input, textarea, select');\n      if (formFields.length > 0) {\n        return { elements: this.queryFormElements(target) };\n      }\n      \n      // If it's neither a form field nor contains form fields, try to find a container\n      const container = this.findFormContainer(target);\n      if (container) {\n        return { elements: this.queryFormElements(container) };\n      }\n      \n      // If it's neither a form field nor contains form fields, return error\n      return { \n        elements: [], \n        error: 'Element is not a form field and does not contain form fields' \n      };\n    }\n\n    // Handle other Element types (like SVGElement, etc.)\n    if (target instanceof Element) {\n      const htmlElement = target as HTMLElement;\n      if ((htmlElement.tagName === 'INPUT' || htmlElement.tagName === 'TEXTAREA' || htmlElement.tagName === 'SELECT') &&\n          htmlElement.hasAttribute('data-gofakeit')) {\n        return { elements: [target] };\n      }\n      \n      const formFields = htmlElement.querySelectorAll('input, textarea, select');\n      if (formFields.length > 0) {\n        return { elements: this.queryFormElements(htmlElement) };\n      }\n      \n      const container = this.findFormContainer(target as HTMLElement);\n      if (container) {\n        return { elements: this.queryFormElements(container) };\n      }\n      \n      return { \n        elements: [], \n        error: 'Element is not a form field and does not contain form fields' \n      };\n    }\n\n    // Fallback - return empty array\n    return { elements: [] };\n  }\n\n  resetState(): void {\n    this.state = {\n      status: 'idle',\n      inputs: []\n    };\n}\n\n// ============================================================================\n// PROCESSING FUNCTIONS (Called by main functions)\n// ============================================================================\n\n// Query all form elements that can be autofilled\n  private queryFormElements(container?: HTMLElement): Element[] {\n  const selector = 'input, textarea, select';\n  const nodeList = container ? container.querySelectorAll(selector) : document.querySelectorAll(selector);\n  const elements: Element[] = [];\n  nodeList.forEach((el) => {\n    if (el instanceof HTMLInputElement) {\n      if (el.type === 'hidden' || el.disabled || el.readOnly) return;\n      elements.push(el);\n    } else if (el instanceof HTMLTextAreaElement) {\n      if (el.disabled || el.readOnly) return;\n      elements.push(el);\n    } else if (el instanceof HTMLSelectElement) {\n      if (el.disabled) return;\n      elements.push(el);\n    }\n  });\n  return elements;\n}\n\n// Get unique elements, handling checkbox and radio groups\n  private getUniqueElements(elements: Element[]): Element[] {\n  const uniqueElements: Element[] = [];\n  const processedGroups = new Set<string>();\n  \n  for (const element of elements) {\n    if (element instanceof HTMLInputElement) {\n      const inputType = element.type.toLowerCase();\n      \n      if (inputType === 'checkbox' || inputType === 'radio') {\n        const name = element.name;\n        if (name && processedGroups.has(name)) {\n          // Skip if we've already processed this group\n          continue;\n        }\n        if (name) {\n          processedGroups.add(name);\n        }\n      }\n    }\n    \n    uniqueElements.push(element);\n  }\n  \n  return uniqueElements;\n}\n\n\n  // ============================================================================\n  // NEW STEP-BY-STEP AUTOFILL PROCESS\n  // ============================================================================\n\n  // Step 1: Initialize inputs array with all target elements\n  private async initializeInputs(elements: Element[]): Promise<void> {\n    const uniqueElements = this.getUniqueElements(elements);\n  \n  for (const element of uniqueElements) {\n      const gofakeitFunc = element.getAttribute('data-gofakeit');\n      const mode = this.settings.mode ?? 'auto';\n      \n      // Skip if explicitly disabled or in manual mode without data-gofakeit\n      if (typeof gofakeitFunc === 'string' && gofakeitFunc.trim().toLowerCase() === 'false') {\n        continue;\n      }\n      if (!gofakeitFunc && mode === 'manual') {\n        continue;\n      }\n\n      // Determine input type\n      let inputType = 'unknown';\n    if (element instanceof HTMLInputElement) {\n        inputType = element.type.toLowerCase();\n      } else if (element instanceof HTMLTextAreaElement) {\n        inputType = 'textarea';\n      } else if (element instanceof HTMLSelectElement) {\n        inputType = 'select';\n      }\n\n      // Determine initial function using input type handlers\n      let initialFunction = '';\n      if (gofakeitFunc && gofakeitFunc !== 'true') {\n        // Specific function provided\n        initialFunction = gofakeitFunc;\n      } else if (gofakeitFunc === 'true') {\n        // Use input type specific function\n        initialFunction = this.getInputTypeFunction(element, gofakeitFunc);\n    } else {\n        // No function specified - will need search\n        initialFunction = '';\n      }\n\n      const autofillInput: AutofillElement = {\n        element,\n        type: inputType,\n        function: initialFunction,\n        value: '',\n        error: ''\n      };\n\n      this.state.inputs.push(autofillInput);\n    }\n\n    console.log(`[Gofakeit] Initialized ${this.state.inputs.length} inputs`);\n  }\n\n  // Step 2: Determine functions for inputs that need search\n  private async determineFunctions(): Promise<void> {\n    const inputsNeedingSearch = this.state.inputs.filter(input => \n      !input.function && this.needsSearchApi(input.type)\n    );\n\n    if (inputsNeedingSearch.length === 0) {\n      console.log('[Gofakeit] No inputs need function search');\n      return;\n    }\n\n    console.log(`[Gofakeit] Determining functions for ${inputsNeedingSearch.length} inputs`);\n\n    // Create search requests for inputs that need function detection\n    const searchRequests: FuncSearchRequest[] = inputsNeedingSearch.map((input, index) => {\n      const element = input.element as HTMLInputElement;\n      const searchQuery = this.createSearchQuery(element);\n      \n      return {\n        id: input.element.id || input.element.getAttribute('name') || `input_${index}`,\n        query: searchQuery\n      };\n    });\n\n    try {\n      const response = await searchMultiFunc(searchRequests);\n      \n      if (response.success && response.data) {\n        // Map results back to inputs\n        for (let i = 0; i < response.data.length; i++) {\n          const searchResult = response.data[i];\n          const input = inputsNeedingSearch[i];\n          \n          if (searchResult.results && searchResult.results.length > 0) {\n            const bestMatch = searchResult.results[0];\n            // Only use the search result if it has a reasonable score\n            if (bestMatch.score >= 100) {\n              input.function = bestMatch.name;\n            } else {\n              // Use type-specific fallback for low-scoring results\n              input.function = this.getTypeSpecificFallback(input.type);\n            }\n          } else {\n            // Fallback to type-specific function if no search results\n            input.function = this.getTypeSpecificFallback(input.type);\n          }\n        }\n      } else {\n        // Fallback to default functions for all inputs if search fails\n        for (const input of inputsNeedingSearch) {\n          input.function = this.getDefaultFunctionForInputType(input.type);\n        }\n      }\n    } catch (error) {\n      console.warn('[Gofakeit] Function search failed, using fallback functions:', error);\n      // Fallback to default functions for all inputs\n      for (const input of inputsNeedingSearch) {\n        input.function = this.getDefaultFunctionForInputType(input.type);\n      }\n    }\n\n    console.log('[Gofakeit] Function determination complete');\n  }\n\n  // Step 3: Get values for all inputs via multi-function API\n  private async getValues(): Promise<void> {\n    const inputsNeedingValues = this.state.inputs.filter(input => \n      input.function && !input.error\n    );\n\n    if (inputsNeedingValues.length === 0) {\n      console.log('[Gofakeit] No inputs need value generation');\n      return;\n    }\n\n    console.log(`[Gofakeit] Getting values for ${inputsNeedingValues.length} inputs`);\n\n    // Separate inputs that need API calls vs local generation\n    const apiInputs: AutofillElement[] = [];\n    const localInputs: AutofillElement[] = [];\n\n    for (const input of inputsNeedingValues) {\n      if (this.isLocalGenerationFunction(input.function)) {\n        localInputs.push(input);\n        } else {\n        apiInputs.push(input);\n      }\n    }\n\n    // Handle local generation first\n    for (const input of localInputs) {\n      try {\n        input.value = this.generateLocalValue(input.function);\n      } catch (error) {\n        input.error = String(error);\n      }\n    }\n\n    // Handle API calls for remaining inputs\n    if (apiInputs.length > 0) {\n      const requests: MultiFuncRequest[] = apiInputs.map((input, index) => ({\n    id: `req_${index}`,\n        func: input.function\n  }));\n\n      try {\n  const batchResponse = await callMultiFunc(requests);\n  \n        if (batchResponse.success && batchResponse.data) {\n          // Map results back to inputs\n          for (let i = 0; i < batchResponse.data.length; i++) {\n    const response = batchResponse.data[i];\n            const input = apiInputs[i];\n            \n            if (response && response.error) {\n              input.error = response.error;\n            } else if (response && response.value !== null) {\n              input.value = response.value;\n            } else {\n              input.error = 'No valid response received';\n            }\n          }\n        } else {\n          // Mark all API inputs as failed\n          for (const input of apiInputs) {\n            input.error = batchResponse.error || 'Batch API call failed';\n          }\n        }\n      } catch (error) {\n        console.error('[Gofakeit] Batch API call failed:', error);\n        // Mark all API inputs as failed\n        for (const input of apiInputs) {\n          input.error = String(error);\n        }\n      }\n    }\n\n    console.log('[Gofakeit] Value generation complete');\n  }\n\n  // Check if a function is a local generation function\n  private isLocalGenerationFunction(func: string): boolean {\n    const localFunctions = ['generateTime', 'generateMonth', 'generateWeek', 'generateDate', 'generateDateTime'];\n    return localFunctions.includes(func);\n  }\n\n  // Generate local values for date/time functions\n  private generateLocalValue(func: string): string {\n    switch (func) {\n      case 'generateTime':\n        return this.generateTime();\n      case 'generateMonth':\n        return this.generateMonth();\n      case 'generateWeek':\n        return this.generateWeek();\n      case 'generateDate':\n        return this.generateDate();\n      case 'generateDateTime':\n        return this.generateDateTime();\n      default:\n        throw new Error(`Unknown local generation function: ${func}`);\n    }\n  }\n\n  // Step 4: Apply values to the actual form elements\n  private async applyValues(): Promise<void> {\n    const inputsToApply = this.state.inputs.filter(input => \n      input.value !== undefined && input.value !== null && !input.error\n    );\n\n    if (inputsToApply.length === 0) {\n      console.log('[Gofakeit] No values to apply');\n      return;\n    }\n\n    console.log(`[Gofakeit] Applying values to ${inputsToApply.length} inputs`);\n\n    const testMode = (globalThis as any).__GOFAKEIT_TEST_MODE__;\n    const staggered = testMode ? false : (this.settings.staggered ?? true);\n    const staggerDelay = this.settings.staggerDelay ?? 50;\n\n    for (let i = 0; i < inputsToApply.length; i++) {\n      const input = inputsToApply[i];\n      \n      // Add staggered delay for visual effect if enabled\n      if (staggered && i > 0) {\n        await new Promise(resolve => setTimeout(resolve, staggerDelay));\n      }\n\n      try {\n        const success = await this.applyValueToElement(input.element, input.function, input.value);\n        if (!success) {\n          input.error = 'Failed to apply value to element';\n        }\n  } catch (error) {\n        input.error = String(error);\n        console.warn(`[Gofakeit] Failed to apply value to element:`, input.element, error);\n      }\n    }\n\n    // Show detailed results using AutofillElement objects\n    this.showDetailedResults();\n    console.log('[Gofakeit] Value application complete');\n  }\n\n  // Helper method to apply a value to a specific element\n  private async applyValueToElement(element: Element, _func: string, value: string): Promise<boolean> {\n  try {\n    // Handle select dropdowns\n    if (element instanceof HTMLSelectElement) {\n        this.setSelectValue(element, value);\n        return true;\n    }\n    \n    // Handle textarea elements\n    if (element instanceof HTMLTextAreaElement) {\n        this.setTextareaValue(element, value);\n      return true;\n    }\n    \n    // Handle input elements\n    if (element instanceof HTMLInputElement) {\n      const inputType = element.type.toLowerCase();\n      \n      // Handle checkbox inputs\n      if (inputType === 'checkbox') {\n          this.setCheckboxValue(element, value);\n          return true;\n      }\n      \n      // Handle radio inputs\n      if (inputType === 'radio') {\n          this.setRadioValue(element, value);\n          return true;\n      }\n      \n      // Handle number inputs\n      if (inputType === 'number') {\n          this.setNumberValue(element, value);\n        return true;\n      }\n      \n      // Handle range inputs\n      if (inputType === 'range') {\n          this.setRangeValue(element, value);\n        return true;\n      }\n      \n      // Handle date/time inputs\n      if (inputType === 'date' || inputType === 'time' || inputType === 'datetime-local' || \n          inputType === 'month' || inputType === 'week') {\n          this.setDateTimeValue(element, value);\n          return true;\n      }\n      \n      // Handle text inputs (text, email, tel, password, search, url, color, etc.)\n        this.setTextValue(element, value);\n      return true;\n    }\n    \n    console.warn('[Gofakeit] Unsupported element type:', element);\n    return false;\n    \n  } catch (error) {\n      console.error('[Gofakeit] Unexpected error applying value to element:', element, error);\n    return false;\n  }\n}\n\n// ============================================================================\n// UTILITY FUNCTIONS (Called by various functions)\n// ============================================================================\n\n// Handle error display and field highlighting\n  public handleError(element: Element, error: string, functionName?: string): void {\n  if (element instanceof HTMLElement) {\n      element.style.border = `2px solid #dc3545`;\n    \n    setTimeout(() => {\n      element.style.border = '';\n    }, 5000);\n  }\n  \n    console.warn(`[Gofakeit] Error for element:`, element, functionName ? `Invalid function: ${functionName}` : error);\n  }\n\n\n// Extract nearby/associated label text for context\n  private getAssociatedLabelText(input: HTMLInputElement): string {\n  const texts: string[] = [];\n  const id = input.id;\n  // aria-labelledby\n  const labelledBy = input.getAttribute('aria-labelledby');\n  if (labelledBy) {\n    labelledBy.split(/\\s+/).forEach((ref) => {\n      const el = document.getElementById(ref);\n      if (el && el.textContent) texts.push(el.textContent);\n    });\n  }\n  // explicit label[for]\n  if (id) {\n    try {\n      const lbl = document.querySelector('label[for=\"' + id.replace(/\"/g, '\\\\\"') + '\"]') as HTMLLabelElement | null;\n      if (lbl && lbl.textContent) texts.push(lbl.textContent);\n    } catch { /* ignore */ }\n  }\n  // implicit parent label\n  const closestLabel = input.closest('label');\n  if (closestLabel && closestLabel.textContent) texts.push(closestLabel.textContent);\n  // previous sibling label (common in some UIs)\n  const prev = input.previousElementSibling as HTMLElement | null;\n  if (prev && prev.tagName === 'LABEL' && prev.textContent) texts.push(prev.textContent);\n  return texts.join(' ').toLowerCase();\n}\n\n// Determine if an input type needs search API for function detection\n  private needsSearchApi(inputType: string): boolean {\n  // These input types have their own specific handling and don't need search API\n    const skipSearchTypes = ['checkbox', 'radio', 'select', 'range', 'file', 'button', 'submit', 'reset', 'image', 'week', 'date', 'time', 'datetime-local', 'month'];\n  return !skipSearchTypes.includes(inputType);\n}\n\n// Get a default function for input types that don't need search API\n  public getDefaultFunctionForInputType(inputType: string): string {\n  switch (inputType) {\n    case 'checkbox':\n    case 'radio':\n    case 'select':\n      return 'true';\n    case 'range':\n      return 'number?min=0&max=100';\n    case 'file':\n      return 'word';\n    case 'button':\n    case 'submit':\n    case 'reset':\n    case 'image':\n      return 'word';\n    case 'week':\n      return 'generateWeek';\n    case 'date':\n      return 'generateDate';\n    case 'time':\n      return 'generateTime';\n    case 'datetime-local':\n      return 'generateDateTime';\n    case 'month':\n      return 'generateMonth';\n    default:\n      return 'word';\n  }\n}\n\n// Get type-specific fallback functions for when search API doesn't find good matches\n  private getTypeSpecificFallback(inputType: string): string {\n  switch (inputType) {\n    case 'email':\n      return 'email';\n    case 'tel':\n      return 'phone';\n    case 'number':\n      return 'number';\n    case 'date':\n      return 'date';\n    case 'time':\n      return 'time';\n    case 'datetime-local':\n      return 'datetime';\n    case 'month':\n      return 'month';\n    case 'week':\n      return 'week';\n    case 'url':\n      return 'url';\n    case 'password':\n      return 'password';\n    case 'search':\n      return 'word';\n    case 'color':\n        return 'hexcolor';\n    case 'text':\n    default:\n      return 'word';\n  }\n}\n\n// Create a comprehensive search query from input field characteristics\n  private createSearchQuery(input: HTMLInputElement): string {\n  const type = input.type.toLowerCase();\n  const name = (input.name || '').toLowerCase();\n  const id = (input.id || '').toLowerCase();\n  const placeholder = (input.placeholder || '').toLowerCase();\n  const autocomplete = (input.autocomplete || '').toLowerCase();\n  const ariaLabel = (input.getAttribute('aria-label') || '').toLowerCase();\n    const labelText = this.getAssociatedLabelText(input);\n\n  // Build a comprehensive search query with all available information\n  const queryParts = [\n    type,\n    name,\n    id,\n    placeholder,\n    autocomplete,\n    ariaLabel,\n    labelText\n  ].filter(part => part && part.trim());\n\n  // Join all parts with spaces to create a comprehensive search query\n  const searchQuery = queryParts.join(' ').toLowerCase()\n    .replace(/[^\\w\\s]/g, ' ') // Remove special characters\n    .replace(/\\s+/g, ' ') // Normalize whitespace\n    .trim();\n\n  return searchQuery || 'text input';\n}\n\n  // Find the closest container that has form fields with data-gofakeit attributes\n  private findFormContainer(element: HTMLElement): HTMLElement | null {\n    // Check if the current element has form fields\n    const formFields = element.querySelectorAll('input, textarea, select');\n    if (formFields.length > 0) {\n      return element;\n    }\n    \n    // Check parent elements\n    let parent = element.parentElement;\n    while (parent) {\n      const parentFormFields = parent.querySelectorAll('input, textarea, select');\n      if (parentFormFields.length > 0) {\n        return parent;\n      }\n      parent = parent.parentElement;\n    }\n    \n    return null;\n  }\n\n  // Simple notification function (can be overridden by the consuming application)\n  private showNotification(message: string, type: 'success' | 'error' | 'info' = 'info'): void {\n    console.log(`[Gofakeit ${type.toUpperCase()}] ${message}`);\n  }\n\n  // ============================================================================\n  // RESULTS DISPLAY\n  // ============================================================================\n\n  // Show detailed results using AutofillElement objects\n  private showDetailedResults(): void {\n    const successfulInputs = this.state.inputs.filter(input => input.value && !input.error);\n    const failedInputs = this.state.inputs.filter(input => input.error);\n    \n    console.log(`[Gofakeit] Autofill Results Summary:`);\n    console.log(`✅ Successful: ${successfulInputs.length} fields`);\n    console.log(`❌ Failed: ${failedInputs.length} fields`);\n    \n    if (successfulInputs.length > 0) {\n      console.log(`\\n📋 Successful Fields:`);\n      successfulInputs.forEach((input, index) => {\n        const elementInfo = this.getElementInfo(input.element);\n        console.log(`  ${index + 1}. ${elementInfo} → ${input.function} → \"${input.value}\"`);\n      });\n    }\n    \n    if (failedInputs.length > 0) {\n      console.log(`\\n⚠️ Failed Fields:`);\n      failedInputs.forEach((input, index) => {\n        const elementInfo = this.getElementInfo(input.element);\n        console.log(`  ${index + 1}. ${elementInfo} → ${input.function} → ERROR: ${input.error}`);\n      });\n    }\n    \n    // Show notification\n    if (successfulInputs.length > 0 && failedInputs.length === 0) {\n      this.showNotification(`Successfully generated data for ${successfulInputs.length} fields!`, 'success');\n    } else if (successfulInputs.length > 0 && failedInputs.length > 0) {\n      this.showNotification(`Generated data for ${successfulInputs.length} fields, ${failedInputs.length} failed`, 'info');\n    } else if (failedInputs.length > 0) {\n      this.showNotification(`Failed to generate data for ${failedInputs.length} fields`, 'error');\n    } else {\n      this.showNotification('No fields were processed', 'info');\n    }\n  }\n\n  // Get a descriptive string for an element\n  private getElementInfo(element: Element): string {\n    let info = '';\n    \n    if (element instanceof HTMLInputElement) {\n      const type = element.type || 'text';\n      const name = element.name || element.id || 'unnamed';\n      const label = this.getAssociatedLabelText(element);\n      info = `input[type=\"${type}\"][name=\"${name}\"]`;\n      if (label) {\n        info += ` (${label})`;\n      }\n    } else if (element instanceof HTMLTextAreaElement) {\n      const name = element.name || element.id || 'unnamed';\n      const label = this.getAssociatedLabelText(element as any);\n      info = `textarea[name=\"${name}\"]`;\n      if (label) {\n        info += ` (${label})`;\n      }\n    } else if (element instanceof HTMLSelectElement) {\n      const name = element.name || element.id || 'unnamed';\n      const label = this.getAssociatedLabelText(element as any);\n      info = `select[name=\"${name}\"]`;\n      if (label) {\n        info += ` (${label})`;\n      }\n    } else {\n      info = element.tagName.toLowerCase();\n      if (element.id) {\n        info += `#${element.id}`;\n      }\n      if (element.className) {\n        info += `.${element.className.split(' ').join('.')}`;\n      }\n    }\n    \n    return info;\n  }\n\n  // ============================================================================\n  // INPUT TYPE HANDLERS\n  // ============================================================================\n\n  // Get function name for any input type\n  private getInputTypeFunction(element: Element, gofakeitFunc: string): string {\n    if (element instanceof HTMLInputElement) {\n      const inputType = element.type.toLowerCase();\n      \n      switch (inputType) {\n        case 'date':\n        case 'time':\n        case 'datetime-local':\n        case 'month':\n        case 'week':\n          return this.getDateTimeFunction(element, gofakeitFunc);\n        case 'number':\n          return this.getNumberFunction(gofakeitFunc);\n        case 'range':\n          return this.getNumberFunction(gofakeitFunc);\n        case 'checkbox':\n          return this.getCheckboxFunction(gofakeitFunc);\n        case 'radio':\n          return this.getRadioFunction(gofakeitFunc);\n        default:\n          return this.getTextFunction(element, gofakeitFunc);\n      }\n    } else if (element instanceof HTMLTextAreaElement) {\n      return this.getTextFunction(element as any, gofakeitFunc);\n    } else if (element instanceof HTMLSelectElement) {\n      return this.getSelectFunction(gofakeitFunc);\n    }\n    \n    return gofakeitFunc;\n  }\n\n  // Get function name for date/time inputs\n  private getDateTimeFunction(element: HTMLInputElement, gofakeitFunc: string): string {\n    const inputType = element.type.toLowerCase();\n    \n    // For all date/time inputs, use local generate functions when gofakeitFunc is 'true'\n    if (inputType === 'date') {\n      return gofakeitFunc === 'true' ? 'generateDate' : gofakeitFunc;\n    }\n    \n    if (inputType === 'datetime-local') {\n      return gofakeitFunc === 'true' ? 'generateDateTime' : gofakeitFunc;\n    }\n    \n    if (inputType === 'time') {\n      return gofakeitFunc === 'true' ? 'generateTime' : gofakeitFunc;\n    }\n    \n    if (inputType === 'month') {\n      return gofakeitFunc === 'true' ? 'generateMonth' : gofakeitFunc;\n    }\n    \n    if (inputType === 'week') {\n      return gofakeitFunc === 'true' ? 'generateWeek' : gofakeitFunc;\n    }\n    \n    return gofakeitFunc;\n  }\n\n  // Set date/time input value\n  private setDateTimeValue(element: HTMLInputElement, value: string): void {\n    element.value = value;\n    element.dispatchEvent(new Event('input', { bubbles: true }));\n    element.dispatchEvent(new Event('change', { bubbles: true }));\n  }\n\n  // Get function name for text inputs\n  private getTextFunction(element: HTMLInputElement, gofakeitFunc: string): string {\n    const inputType = element.type.toLowerCase();\n    \n    // Map input types to appropriate gofakeit functions if 'true' is passed\n    if (gofakeitFunc === 'true') {\n      switch (inputType) {\n        case 'email':\n          return 'email';\n        case 'tel':\n          return 'phone';\n        case 'password':\n          return 'password';\n        case 'search':\n          return 'word';\n        case 'url':\n          return 'url';\n        case 'color':\n          return 'hexcolor';\n        default:\n          return 'word'; // Default for text inputs\n      }\n    }\n    \n    return gofakeitFunc;\n  }\n\n  // Set text input value\n  private setTextValue(element: HTMLInputElement, value: string): void {\n    element.value = value;\n    element.dispatchEvent(new Event('input', { bubbles: true }));\n    element.dispatchEvent(new Event('change', { bubbles: true }));\n  }\n\n  // Set textarea value\n  private setTextareaValue(element: HTMLTextAreaElement, value: string): void {\n    element.value = value;\n    element.dispatchEvent(new Event('input', { bubbles: true }));\n    element.dispatchEvent(new Event('change', { bubbles: true }));\n  }\n\n  // Get function name for number inputs\n  private getNumberFunction(gofakeitFunc: string): string {\n    return gofakeitFunc === 'true' ? 'number' : gofakeitFunc;\n  }\n\n  // Set number input value\n  private setNumberValue(element: HTMLInputElement, value: string): void {\n    element.value = value;\n    element.dispatchEvent(new Event('input', { bubbles: true }));\n    element.dispatchEvent(new Event('change', { bubbles: true }));\n  }\n\n  // Set range input value\n  private setRangeValue(element: HTMLInputElement, value: string): void {\n    element.value = value;\n    element.dispatchEvent(new Event('input', { bubbles: true }));\n    element.dispatchEvent(new Event('change', { bubbles: true }));\n  }\n\n  // Get function name for checkbox inputs\n  private getCheckboxFunction(gofakeitFunc: string): string {\n    return gofakeitFunc === 'true' ? 'bool' : gofakeitFunc;\n  }\n\n  // Set checkbox value\n  private setCheckboxValue(element: HTMLInputElement, value: string | boolean): void {\n    let boolValue: boolean;\n    if (typeof value === 'boolean') {\n      boolValue = value;\n    } else {\n      boolValue = value.toLowerCase() === 'true';\n    }\n    \n    element.checked = boolValue;\n    \n    // Always dispatch change event when setting checkbox value\n    element.dispatchEvent(new Event('change', { bubbles: true }));\n  }\n\n  // Get function name for radio inputs\n  private getRadioFunction(gofakeitFunc: string): string {\n    return gofakeitFunc === 'true' ? 'bool' : gofakeitFunc;\n  }\n\n  // Set radio value\n  private setRadioValue(element: HTMLInputElement, value: string | boolean): void {\n    let boolValue: boolean;\n    if (typeof value === 'boolean') {\n      boolValue = value;\n        } else {\n      boolValue = value.toLowerCase() === 'true';\n    }\n    \n    // Uncheck all other radio buttons in the same group first\n    const name = element.name;\n    if (name) {\n      const groupRadios = document.querySelectorAll(`input[type=\"radio\"][name=\"${name}\"]`);\n      groupRadios.forEach(radio => {\n        (radio as HTMLInputElement).checked = false;\n      });\n    }\n    \n    // Set this radio button to checked if the value is true\n    if (boolValue) {\n      element.checked = true;\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n    } else {\n      // If this radio button gets false, but no other radio in the group is checked,\n      // we need to ensure at least one radio button in the group is selected\n      const name = element.name;\n      if (name) {\n        const groupRadios = document.querySelectorAll(`input[type=\"radio\"][name=\"${name}\"]`);\n        const hasCheckedRadio = Array.from(groupRadios).some(radio => (radio as HTMLInputElement).checked);\n        \n        // If no radio button in the group is checked, check this one\n        if (!hasCheckedRadio) {\n          element.checked = true;\n          element.dispatchEvent(new Event('change', { bubbles: true }));\n        }\n      }\n    }\n    \n    // Always ensure at least one radio button in the group is checked\n    const radioName = element.name;\n    if (radioName) {\n      const groupRadios = document.querySelectorAll(`input[type=\"radio\"][name=\"${radioName}\"]`);\n      const hasCheckedRadio = Array.from(groupRadios).some(radio => (radio as HTMLInputElement).checked);\n      \n      // If no radio button in the group is checked, check the first one\n      if (!hasCheckedRadio && groupRadios.length > 0) {\n        const firstRadio = groupRadios[0] as HTMLInputElement;\n        firstRadio.checked = true;\n        firstRadio.dispatchEvent(new Event('change', { bubbles: true }));\n      }\n    }\n  }\n\n  // Get function name for select inputs\n  private getSelectFunction(gofakeitFunc: string): string {\n    return gofakeitFunc === 'true' ? 'word' : gofakeitFunc;\n  }\n\n  // Set select value\n  private setSelectValue(element: HTMLSelectElement, value: string): void {\n    // Try to find an option with matching text content\n    const options = Array.from(element.options);\n    const matchingOption = options.find(option => \n      option.textContent?.toLowerCase().includes(value.toLowerCase()) ||\n      option.value.toLowerCase().includes(value.toLowerCase())\n    );\n    \n    if (matchingOption) {\n      element.value = matchingOption.value;\n          } else if (options.length > 0) {\n        // Fallback to random selection (skip empty option if it exists)\n        const nonEmptyOptions = options.filter(option => option.value !== '');\n        if (nonEmptyOptions.length > 0) {\n          const randomIndex = Math.floor(Math.random() * nonEmptyOptions.length);\n          element.value = nonEmptyOptions[randomIndex].value;\n        } else {\n          // If all options are empty, just select the first one\n          element.selectedIndex = 0;\n        }\n      }\n    \n    element.dispatchEvent(new Event('change', { bubbles: true }));\n  }\n\n  // ============================================================================\n  // DATE/TIME GENERATION FUNCTIONS\n  // ============================================================================\n\n  // Generate time string (HH:MM format)\n  private generateTime(): string {\n    const hour = Math.floor(Math.random() * 24).toString().padStart(2, '0');\n    const minute = Math.floor(Math.random() * 60).toString().padStart(2, '0');\n    return `${hour}:${minute}`;\n  }\n\n  // Generate month string (YYYY-MM format)\n  private generateMonth(): string {\n    const year = Math.floor(Math.random() * 30) + 1990; // Random year between 1990-2020\n    const month = Math.floor(Math.random() * 12) + 1;\n    return `${year}-${month.toString().padStart(2, '0')}`;\n  }\n\n  // Generate week string (YYYY-W## format)\n  private generateWeek(): string {\n    const year = Math.floor(Math.random() * 30) + 1990;\n    const week = Math.floor(Math.random() * 52) + 1;\n    return `${year}-W${week.toString().padStart(2, '0')}`;\n  }\n\n  // Generate date string (YYYY-MM-DD format)\n  private generateDate(): string {\n    const year = Math.floor(Math.random() * 30) + 1990;\n    const month = Math.floor(Math.random() * 12) + 1;\n    const day = Math.floor(Math.random() * 28) + 1; // Use 28 to avoid month/day issues\n    return `${year}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`;\n  }\n\n  // Generate datetime-local string (YYYY-MM-DDTHH:MM format)\n  private generateDateTime(): string {\n    const date = this.generateDate();\n    const time = this.generateTime();\n    return `${date}T${time}`;\n  }\n}\n","\n      import { Autofill } from \"./src/index.ts\";\n\n      // Make functions available globally\n      window.autofill = async (target) => {\n        try {\n          // Get current settings\n          const settings = getCurrentSettings();\n\n          if (target) {\n            // If target is a string, treat it as a CSS selector (ID, class, or other)\n            if (typeof target === \"string\") {\n              // Scroll to the section first\n              const element = document.querySelector(target);\n              if (element) {\n                element.scrollIntoView({ behavior: \"smooth\", block: \"start\" });\n                \n                // Wait a moment for the scroll to complete, then autofill\n                setTimeout(async () => {\n                  const manager = new Autofill(settings);\n                  await manager.autofill(target);\n                  showStatus(\n                    `✅ ${target} section filled successfully!`,\n                    \"success\"\n                  );\n                }, 500);\n              } else {\n                showStatus(\"❌ Element not found: \" + target, \"error\");\n              }\n            } else {\n              const manager = new AutofillManager(settings);\n              await manager.autofill(target);\n              showStatus(\"✅ Element filled successfully!\", \"success\");\n            }\n          } else {\n            // No target - autofill all\n            const manager = new AutofillManager(settings);\n            await manager.autofill(undefined);\n            showStatus(\"✅ All fields filled successfully!\", \"success\");\n          }\n        } catch (error) {\n          showStatus(\"❌ Error filling fields: \" + error.message, \"error\");\n        }\n      };\n\n      // Function to handle category selection from dropdown\n      window.handleCategorySelection = async () => {\n        const selector = document.getElementById(\"categorySelector\");\n        const selectedCategory = selector.value;\n\n        if (!selectedCategory) {\n          return;\n        }\n\n        try {\n          // Map category values to their heading text\n          const categoryHeadingMap = {\n            \"person-category\": \"👤 Person Category\",\n            \"address-category\": \"🏠 Address Category\",\n            \"company-category\": \"🏢 Company Category\",\n            \"payment-category\": \"💳 Payment Category\",\n            \"internet-category\": \"🌐 Internet Category\",\n            \"time-category\": \"⏰ Time Category\",\n            \"language-category\": \"🗣️ Language Category\",\n            \"word-category\": \"📝 Word Category\",\n            \"color-category\": \"🎨 Color Category\",\n            \"animal-category\": \"🐾 Animal Category\",\n            \"food-category\": \"🍕 Food Category\",\n            \"car-category\": \"🚗 Car Category\",\n            \"game-category\": \"🎮 Game Category\",\n            \"misc-category\": \"🎲 Misc Category\",\n          };\n\n          // Find the specific category heading by text content\n          const headingText = categoryHeadingMap[selectedCategory];\n          let categoryHeading = null;\n          if (headingText) {\n            const allHeadings = document.querySelectorAll(\"h4\");\n            for (const heading of allHeadings) {\n              if (heading.textContent?.includes(headingText)) {\n                categoryHeading = heading;\n                break;\n              }\n            }\n          }\n\n          if (categoryHeading) {\n            categoryHeading.scrollIntoView({\n              behavior: \"smooth\",\n              block: \"start\",\n            });\n          } else {\n            // Fallback: scroll to the categories section\n            const section = document.getElementById(\"categories\");\n            if (section) {\n              section.scrollIntoView({ behavior: \"smooth\", block: \"start\" });\n            }\n          }\n\n          // Wait a moment for the scroll to complete, then autofill the specific fields\n          setTimeout(async () => {\n            // Find the category container\n            const categoryContainer = document.getElementById(selectedCategory);\n            if (!categoryContainer) {\n              showStatus(\"❌ Category container not found!\", \"error\");\n              return;\n            }\n\n            try {\n              // Get current settings\n              const settings = getCurrentSettings();\n\n              // Use the main autofill function with the category container\n              const manager = new Autofill(settings);\n              await manager.autofill(categoryContainer);\n\n              // Count filled elements\n              let filledCount = 0;\n              const inputs = categoryContainer.querySelectorAll(\n                \"input, textarea, select\"\n              );\n              inputs.forEach((element) => {\n                if (element instanceof HTMLInputElement) {\n                  if (element.type === \"checkbox\" || element.type === \"radio\") {\n                    if (element.checked) filledCount++;\n                  } else if (element.value) {\n                    filledCount++;\n                  }\n                } else if (\n                  element instanceof HTMLTextAreaElement ||\n                  element instanceof HTMLSelectElement\n                ) {\n                  if (element.value) filledCount++;\n                }\n              });\n\n              const categoryName = selector.options[selector.selectedIndex].text;\n              showStatus(\n                `✅ ${categoryName} filled successfully! (${filledCount} fields)`,\n                \"success\"\n              );\n            } catch (error) {\n              console.warn(\"Failed to fill category:\", error);\n              showStatus(\n                \"❌ Error filling category: \" + error.message,\n                \"error\"\n              );\n            }\n\n            // Reset the dropdown\n            selector.value = \"\";\n          }, 500);\n        } catch (error) {\n          showStatus(\"❌ Error filling category: \" + error.message, \"error\");\n          // Reset the dropdown even on error\n          selector.value = \"\";\n        }\n      };\n\n      // Function to get current settings from the UI controls\n      function getCurrentSettings() {\n        const mode = document.querySelector('input[name=\"mode\"]:checked').value;\n        const staggeredMode = document.querySelector('input[name=\"staggered\"]:checked').value === 'on';\n        const staggerDelay = parseInt(\n          document.getElementById(\"staggerDelay\").value\n        );\n\n        return {\n          mode: mode,\n          staggered: staggeredMode,\n          staggerDelay: staggerDelay,\n          onStatusChange: (status, state) => {\n            console.log(`[Status Update] ${status}:`, state);\n            \n            // Update status display in UI\n            const statusElement = document.getElementById('statusDisplay');\n            if (statusElement) {\n              const statusText = {\n                'idle': 'Ready',\n                'starting': 'Starting...',\n                'initializing': 'Initializing inputs...',\n                'determining_functions': 'Determining functions...',\n                'getting_values': 'Getting values...',\n                'applying_values': 'Applying values...',\n                'completed': 'Completed!',\n                'error': 'Error occurred'\n              }[status] || status;\n              \n              statusElement.textContent = statusText;\n              statusElement.className = `status-badge ${status}`;\n            }\n            \n            // Show progress for certain statuses\n            if (status === 'getting_values' || status === 'applying_values') {\n              const processedCount = state.inputs.filter(input => input.value || input.error).length;\n              const totalCount = state.inputs.length;\n              if (totalCount > 0) {\n                showStatus(`Processing ${processedCount}/${totalCount} fields...`, 'info');\n              }\n            }\n          }\n        };\n      }\n\n      // Function to autofill with current settings\n      window.autofillWithCurrentSettings = async () => {\n        try {\n          const settings = getCurrentSettings();\n          const manager = new Autofill(settings);\n          await manager.autofill(undefined);\n\n          const modeText = settings.mode === 'auto' ? \"Auto Mode\" : \"Manual Mode\";\n          const staggerText = settings.staggered\n            ? ` (${settings.staggerDelay}ms delay)`\n            : \" (no stagger)\";\n          showStatus(\n            `✅ All fields filled with ${modeText}${staggerText}!`,\n            \"success\"\n          );\n        } catch (error) {\n          showStatus(\"❌ Error filling fields: \" + error.message, \"error\");\n        }\n      };\n\n      // Update stagger delay value display and handle theme toggle\n      document.addEventListener(\"DOMContentLoaded\", function () {\n        const staggerDelay = document.getElementById(\"staggerDelay\");\n        const staggerDelayValue = document.getElementById(\"staggerDelayValue\");\n        const themeToggle = document.getElementById(\"themeToggle\");\n        const themeIcon = themeToggle.querySelector(\".theme-icon\");\n\n        if (staggerDelay && staggerDelayValue) {\n          staggerDelay.addEventListener(\"input\", function () {\n            staggerDelayValue.textContent = this.value;\n          });\n        }\n\n        // Handle theme toggle\n        if (themeToggle) {\n          // Get user's saved preference or system preference\n          const savedTheme = localStorage.getItem(\"theme\");\n          const systemPrefersDark = window.matchMedia(\n            \"(prefers-color-scheme: dark)\"\n          ).matches;\n\n          // Use saved preference if available, otherwise use system preference\n          // Since dark is now default, we need to check if user wants light mode\n          const shouldUseLight =\n            savedTheme === \"light\" || (savedTheme === null && !systemPrefersDark);\n\n          if (shouldUseLight) {\n            document.documentElement.setAttribute(\"data-theme\", \"light\");\n            themeIcon.textContent = \"🌙\";\n          } else {\n            // Dark is default, no data-theme attribute needed\n            themeIcon.textContent = \"☀️\";\n          }\n\n          themeToggle.addEventListener(\"click\", function () {\n            const isLight = document.documentElement.hasAttribute(\"data-theme\") && \n                           document.documentElement.getAttribute(\"data-theme\") === \"light\";\n\n            if (isLight) {\n              // Switch to dark mode (default)\n              document.documentElement.removeAttribute(\"data-theme\");\n              localStorage.setItem(\"theme\", \"dark\");\n              themeIcon.textContent = \"☀️\";\n            } else {\n              // Switch to light mode\n              document.documentElement.setAttribute(\"data-theme\", \"light\");\n              localStorage.setItem(\"theme\", \"light\");\n              themeIcon.textContent = \"🌙\";\n            }\n          });\n\n          // Listen for system preference changes\n          window\n            .matchMedia(\"(prefers-color-scheme: dark)\")\n            .addEventListener(\"change\", function (e) {\n              // Only update if user hasn't set a preference\n              if (localStorage.getItem(\"theme\") === null) {\n                if (e.matches) {\n                  // System prefers dark, use default (dark)\n                  document.documentElement.removeAttribute(\"data-theme\");\n                  themeIcon.textContent = \"☀️\";\n                } else {\n                  // System prefers light, switch to light\n                  document.documentElement.setAttribute(\"data-theme\", \"light\");\n                  themeIcon.textContent = \"🌙\";\n                }\n              }\n            });\n        }\n      });\n\n      window.clearAll = () => {\n        // only search in main content container, not sidebar\n        const mainContent = document.querySelector(\".main-content\");\n        if (!mainContent) return;\n        \n        const inputs = mainContent.querySelectorAll(\"input, textarea, select\");\n        inputs.forEach((input) => {\n          if (input.type === \"checkbox\" || input.type === \"radio\") {\n            input.checked = false;\n          } else {\n            input.value = \"\";\n          }\n        });\n        showStatus(\"🧹 All fields cleared!\", \"success\");\n      };\n\n      function showStatus(message, type) {\n        const status = document.getElementById(\"status\");\n        status.textContent = message;\n        status.style.display = \"block\";\n        status.className = `status ${type} show`;\n\n        setTimeout(() => {\n          status.classList.remove(\"show\");\n          // Hide the status element completely after animation\n          setTimeout(() => {\n            status.style.display = \"none\";\n          }, 300);\n        }, 3000);\n      }\n\n      // Initialize the page\n      console.log(\"🎯 Gofakeit Autofill Comprehensive Testing loaded!\");\n      console.log(\n        \"This page tests the search API with various input contexts and categories.\"\n      );\n      console.log(\n        \"Check the browser network tab to see search API calls in action!\"\n      );\n    "],"names":["GOFAKEIT_API_BASE","callMultiFunc","requests","processedRequests","req","index","func","id","questionMarkIndex","functionName","queryString","params","searchParams","key","value","numValue","makeMultiRequest","searchMultiFunc","makeSearchRequest","method","url","body","options","response","error","Autofill","settings","status","stateCopy","target","result","elements","element","formFields","htmlElement","container","selector","nodeList","el","uniqueElements","processedGroups","inputType","name","gofakeitFunc","mode","initialFunction","autofillInput","inputsNeedingSearch","input","searchRequests","searchQuery","i","searchResult","bestMatch","inputsNeedingValues","apiInputs","localInputs","batchResponse","inputsToApply","staggered","staggerDelay","resolve","_func","texts","labelledBy","ref","lbl","closestLabel","prev","type","placeholder","autocomplete","ariaLabel","labelText","part","parent","message","successfulInputs","failedInputs","elementInfo","info","label","boolValue","radio","groupRadios","radioName","firstRadio","matchingOption","option","nonEmptyOptions","randomIndex","hour","minute","year","month","week","day","date","time","getCurrentSettings","showStatus","selectedCategory","headingText","categoryHeading","allHeadings","heading","section","categoryContainer","filledCount","categoryName","staggeredMode","state","statusElement","statusText","processedCount","totalCount","modeText","staggerText","staggerDelayValue","themeToggle","themeIcon","savedTheme","systemPrefersDark","e","mainContent"],"mappings":"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"}