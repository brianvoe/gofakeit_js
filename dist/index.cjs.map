{"version":3,"file":"index.cjs","sources":["../src/styles.ts","../src/api.ts","../src/input-datetime.ts","../src/input-text.ts","../src/input-misc.ts","../src/input-number.ts","../src/autofill.ts","../index.html?html-proxy&index=1.js"],"sourcesContent":["// Centralized style tokens for injected UI (avoid dependency on site CSS)\n\nexport const GOFAKEIT_COLORS = {\n\tprimary: '#ffa000',\n\twhite: '#ffffff',\n\tsuccess: '#48c774',\n\terror: '#ff3860',\n\tinfo: '#209cee',\n\ttext: '#ffffff',\n\tborder: '#686868',\n\tbackground: '#ffffff',\n};\n\nexport const GOFAKEIT_SPACING = {\n\tbase: 24, // px\n\thalf: 12, // px\n\tquarter: 8, // px\n};\n\nexport const GOFAKEIT_BORDER = {\n\tradius: 6, // px\n\twidth: 2, // px\n};\n\nexport const GOFAKEIT_FONT = {\n\tsize: 14, // px\n\tfamily: 'Helvetica, Arial, sans-serif',\n};\n","// Base URL for the Gofakeit API\nconst GOFAKEIT_API_BASE = 'https://api.gofakeit.com/funcs'\n\nexport interface ApiResponse {\n  success: boolean;\n  data?: string;\n  error?: string;\n  status?: number;\n}\n\n// Multi-function request interface\nexport interface MultiFuncRequest {\n  id?: string;\n  func: string;\n  params?: Record<string, unknown>;\n}\n\n// Multi-function response interface\nexport interface MultiFuncResponse {\n  id?: string;\n  value: string | null;\n  error: string;\n}\n\n// Multi-function API response interface\nexport interface MultiFuncApiResponse {\n  success: boolean;\n  data?: MultiFuncResponse[];\n  error?: string;\n  status?: number;\n}\n\n// Function search request interface\nexport interface FuncSearchRequest {\n  id: string;\n  query: string;\n}\n\n// Function search result interface\nexport interface FuncSearchResult {\n  name: string;     // function name for API usage\n  score: number;    // relevance score (0-100)\n  reasons: string[]; // why it matched\n}\n\n// Function search response interface\nexport interface FuncSearchResponse {\n  id: string;\n  query: string;\n  results: FuncSearchResult[];\n}\n\n// Multi-function search API response interface\nexport interface MultiFuncSearchApiResponse {\n  success: boolean;\n  data?: FuncSearchResponse[];\n  error?: string;\n  status?: number;\n}\n\n// Fetch data from gofakeit API\nexport async function callFunc(func: string): Promise<ApiResponse> {\n  // Check if the function contains query parameters\n  const questionMarkIndex = func.indexOf('?');\n  \n  if (questionMarkIndex !== -1) {\n    // Function has query parameters - use POST with JSON body\n    const functionName = func.substring(0, questionMarkIndex);\n    const queryString = func.substring(questionMarkIndex + 1);\n    \n    // Parse query parameters into an object\n    const params: Record<string, unknown> = {};\n    const searchParams = new URLSearchParams(queryString);\n    \n    for (const [key, value] of searchParams.entries()) {\n      // Try to parse as number if possible\n      const numValue = parseFloat(value);\n      params[key] = isNaN(numValue) ? value : numValue;\n    }\n    \n    return makeRequest('POST', `${GOFAKEIT_API_BASE}/${functionName}`, params);\n  } else {\n    // Simple function - use GET request\n    return makeRequest('GET', `${GOFAKEIT_API_BASE}/${func}`);\n  }\n}\n\n// Call multiple functions in a single request\nexport async function callMultiFunc(requests: MultiFuncRequest[]): Promise<MultiFuncApiResponse> {\n  if (requests.length === 0) {\n    return {\n      success: false,\n      error: 'No functions provided'\n    };\n  }\n\n  // Process each request to extract function name and parameters\n  const processedRequests: MultiFuncRequest[] = requests.map((req, index) => {\n    const { func, id } = req;\n    const questionMarkIndex = func.indexOf('?');\n    \n    if (questionMarkIndex !== -1) {\n      // Function has query parameters\n      const functionName = func.substring(0, questionMarkIndex);\n      const queryString = func.substring(questionMarkIndex + 1);\n      \n      // Parse query parameters into an object\n      const params: Record<string, unknown> = {};\n      const searchParams = new URLSearchParams(queryString);\n      \n      for (const [key, value] of searchParams.entries()) {\n        // Try to parse as number if possible\n        const numValue = parseFloat(value);\n        params[key] = isNaN(numValue) ? value : numValue;\n      }\n      \n      return {\n        id: id || `req_${index}`,\n        func: functionName,\n        params\n      };\n    } else {\n      // Simple function\n      return {\n        id: id || `req_${index}`,\n        func,\n        params: req.params\n      };\n    }\n  });\n\n  return makeMultiRequest('POST', `${GOFAKEIT_API_BASE}/multi`, processedRequests);\n}\n\n// Search for multiple functions in a single request\nexport async function searchMultiFunc(requests: FuncSearchRequest[]): Promise<MultiFuncSearchApiResponse> {\n  if (requests.length === 0) {\n    return {\n      success: false,\n      error: 'No search queries provided'\n    };\n  }\n\n  return makeSearchRequest('POST', `${GOFAKEIT_API_BASE}/search`, requests);\n}\n\n// Base HTTP request function\nasync function makeRequest(method: 'GET' | 'POST', url: string, body?: Record<string, unknown>): Promise<ApiResponse> {\n  try {\n    const options: {\n      method: string;\n      headers: Record<string, string>;\n      body?: string;\n    } = {\n      method: method,\n      headers: {\n        'Content-Type': 'application/json',\n      }\n    };\n\n    if (method === 'POST' && body) {\n      options.body = JSON.stringify(body);\n    }\n\n    const response = await fetch(url, options);\n    \n    if (!response.ok) {\n      return {\n        success: false,\n        error: `HTTP error! status: ${response.status}`,\n        status: response.status\n      };\n    }\n    \n    const data = await response.text();\n    return {\n      success: true,\n      data: data\n    };\n  } catch (error) {\n    console.error(`[Gofakeit Autofill] Error in ${method} request to ${url}:`, error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error'\n    };\n  }\n}\n\n// Multi-function HTTP request function\nasync function makeMultiRequest(method: 'GET' | 'POST', url: string, body: MultiFuncRequest[]): Promise<MultiFuncApiResponse> {\n  try {\n    const options: {\n      method: string;\n      headers: Record<string, string>;\n      body: string;\n    } = {\n      method: method,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(body)\n    };\n\n    const response = await fetch(url, options);\n    \n    if (!response.ok) {\n      return {\n        success: false,\n        error: `HTTP error! status: ${response.status}`,\n        status: response.status\n      };\n    }\n    \n    const data = await response.json();\n    return {\n      success: true,\n      data: data\n    };\n  } catch (error) {\n    console.error(`[Gofakeit Autofill] Error in ${method} request to ${url}:`, error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error'\n    };\n  }\n}\n\n// Multi-function search HTTP request function\nasync function makeSearchRequest(method: 'GET' | 'POST', url: string, body: FuncSearchRequest[]): Promise<MultiFuncSearchApiResponse> {\n  try {\n    const options: {\n      method: string;\n      headers: Record<string, string>;\n      body: string;\n    } = {\n      method: method,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(body)\n    };\n\n    const response = await fetch(url, options);\n    \n    if (!response.ok) {\n      return {\n        success: false,\n        error: `HTTP error! status: ${response.status}`,\n        status: response.status\n      };\n    }\n    \n    const data = await response.json();\n    return {\n      success: true,\n      data: data\n    };\n  } catch (error) {\n    console.error(`[Gofakeit Autofill] Error in ${method} request to ${url}:`, error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error'\n    };\n  }\n}\n","import { callFunc } from './api';\nimport { handleError, getDefaultFunctionForInputType } from './autofill';\n\n// Get function name for date/time input (for batch processing)\nexport function getDateTimeInput(element: HTMLInputElement, gofakeitFunc: string): string {\n  const inputType = element.type.toLowerCase();\n  \n  // For all date/time inputs, use local generate functions when gofakeitFunc is 'true'\n  if (inputType === 'date') {\n    return gofakeitFunc === 'true' ? 'generateDate' : gofakeitFunc;\n  }\n  \n  if (inputType === 'datetime-local') {\n    return gofakeitFunc === 'true' ? 'generateDateTime' : gofakeitFunc;\n  }\n  \n  if (inputType === 'time') {\n    return gofakeitFunc === 'true' ? 'generateTime' : gofakeitFunc;\n  }\n  \n  if (inputType === 'month') {\n    return gofakeitFunc === 'true' ? 'generateMonth' : gofakeitFunc;\n  }\n  \n  if (inputType === 'week') {\n    return gofakeitFunc === 'true' ? 'generateWeek' : gofakeitFunc;\n  }\n  \n  return gofakeitFunc;\n}\n\n// Set date/time input value (for batch processing)\nexport function setDateTimeInput(element: HTMLInputElement, value: string): void {\n  element.value = value;\n  element.dispatchEvent(new Event('input', { bubbles: true }));\n  element.dispatchEvent(new Event('change', { bubbles: true }));\n}\n\n// Generate time string (HH:MM format)\nexport async function generateTime(): Promise<string> {\n  // Generate random hour and minute locally\n  const hour = Math.floor(Math.random() * 24).toString().padStart(2, '0');\n  const minute = Math.floor(Math.random() * 60).toString().padStart(2, '0');\n  return `${hour}:${minute}`;\n}\n\n// Generate month string (YYYY-MM format)\nexport async function generateMonth(): Promise<string> {\n  // Generate random year and month locally\n  const year = Math.floor(Math.random() * 30) + 1990; // Random year between 1990-2020\n  const month = (Math.floor(Math.random() * 12) + 1).toString().padStart(2, '0');\n  return `${year}-${month}`;\n}\n\n// Generate date string (YYYY-MM-DD format)\nexport async function generateDate(): Promise<string> {\n  // Generate random year, month, and day locally\n  const year = Math.floor(Math.random() * 30) + 1990; // Random year between 1990-2020\n  const month = (Math.floor(Math.random() * 12) + 1).toString().padStart(2, '0');\n  const day = (Math.floor(Math.random() * 28) + 1).toString().padStart(2, '0'); // Use 28 to avoid invalid dates\n  return `${year}-${month}-${day}`;\n}\n\n// Generate datetime string (YYYY-MM-DDTHH:MM format)\nexport async function generateDateTime(): Promise<string> {\n  // Generate random date and time locally\n  const year = Math.floor(Math.random() * 30) + 1990; // Random year between 1990-2020\n  const month = (Math.floor(Math.random() * 12) + 1).toString().padStart(2, '0');\n  const day = (Math.floor(Math.random() * 28) + 1).toString().padStart(2, '0'); // Use 28 to avoid invalid dates\n  const hour = Math.floor(Math.random() * 24).toString().padStart(2, '0');\n  const minute = Math.floor(Math.random() * 60).toString().padStart(2, '0');\n  return `${year}-${month}-${day}T${hour}:${minute}`;\n}\n\n// Generate week string (YYYY-W## format)\nexport async function generateWeek(): Promise<string> {\n  const weekYearResponse = await callFunc('year');\n  const weekResponse = await callFunc('number?min=1&max=53');\n  \n  if (!weekYearResponse.success || !weekResponse.success) {\n    throw new Error(`Failed to generate week: ${weekYearResponse.error || weekResponse.error}`);\n  }\n  \n  const week = weekResponse.data!.padStart(2, '0');\n  return `${weekYearResponse.data!}-W${week}`;\n}\n\n// Get ISO week number for a date\nfunction getISOWeek(date: Date): number {\n  const d = new Date(date.getTime());\n  d.setUTCHours(0, 0, 0, 0);\n  // Thursday in current week decides the year\n  d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));\n  // January 4 is always in week 1\n  const week1 = new Date(d.getUTCFullYear(), 0, 4);\n  // Adjust to Thursday in week 1 and count number of weeks from date to week1\n  const week = Math.ceil((((d.getTime() - week1.getTime()) / 86400000) - 3 + (week1.getUTCDay() || 7)) / 7);\n  return week;\n}\n\n// Handle date/time input elements\nexport async function handleDateTimeInput(element: HTMLInputElement, gofakeitFunc: string, value?: string): Promise<{ success: boolean, usedFunc: string }> {\n  const inputType = element.type.toLowerCase();\n  const functionToCall = getDateTimeInput(element, gofakeitFunc);\n  \n  try {\n    let finalValue: string;\n    \n    // If value is provided (batch processing), use it directly\n    if (value !== undefined) {\n      finalValue = value;\n    } else {\n      // Handle generate functions (multi-function cases)\n      if (functionToCall === 'generateTime') {\n        finalValue = await generateTime();\n      } else if (functionToCall === 'generateMonth') {\n        finalValue = await generateMonth();\n      } else if (functionToCall === 'generateWeek') {\n        finalValue = await generateWeek();\n      } else if (functionToCall === 'generateDate') {\n        finalValue = await generateDate();\n      } else if (functionToCall === 'generateDateTime') {\n        finalValue = await generateDateTime();\n      } else {\n        // Handle single function cases\n        const response = await callFunc(functionToCall);\n        \n        if (!response.success) {\n          console.warn(`[Gofakeit Autofill] Error for ${inputType} input:`, response.error);\n          if (response.status === 400) {\n            handleError(element, `Failed to get random ${inputType}`);\n          }\n          \n          // Fallback to default function for this input type\n          const fallbackFunc = getDefaultFunctionForInputType(inputType);\n          if (fallbackFunc !== functionToCall) {\n            console.warn(`[Gofakeit Autofill] Falling back to default function: ${fallbackFunc}`);\n            \n            // Handle generate functions directly\n            if (fallbackFunc === 'generateWeek') {\n              finalValue = await generateWeek();\n            } else if (fallbackFunc === 'generateTime') {\n              finalValue = await generateTime();\n            } else if (fallbackFunc === 'generateMonth') {\n              finalValue = await generateMonth();\n            } else if (fallbackFunc === 'generateDate') {\n              finalValue = await generateDate();\n            } else if (fallbackFunc === 'generateDateTime') {\n              finalValue = await generateDateTime();\n            } else {\n              // For other functions, try calling the API\n              const fallbackResponse = await callFunc(fallbackFunc);\n              if (fallbackResponse.success) {\n                finalValue = fallbackResponse.data!;\n              } else {\n                return { success: false, usedFunc: functionToCall };\n              }\n            }\n          } else {\n            return { success: false, usedFunc: functionToCall };\n          }\n        } else {\n          finalValue = response.data!;\n        }\n      }\n    }\n    \n    // Parse and format the value based on input type\n    if (inputType === 'date') {\n      // Extract YYYY-MM-DD part from ISO date string\n      const dateMatch = finalValue.match(/^(\\d{4}-\\d{2}-\\d{2})/);\n      if (dateMatch) {\n        finalValue = dateMatch[1];\n      } else {\n        console.warn('[Gofakeit Autofill] Could not parse date from response:', finalValue);\n        return { success: false, usedFunc: functionToCall };\n      }\n    } else if (inputType === 'datetime-local') {\n      // Extract YYYY-MM-DDTHH:MM part from ISO datetime string\n      const datetimeMatch = finalValue.match(/^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2})(:\\d{2})?/);\n      if (datetimeMatch) {\n        finalValue = datetimeMatch[1];\n      } else {\n        console.warn('[Gofakeit Autofill] Could not parse datetime from response:', finalValue);\n        return { success: false, usedFunc: functionToCall };\n      }\n    } else if (inputType === 'week' && functionToCall !== 'generateWeek') {\n      // Handle custom week functions (like date/daterange)\n      if (functionToCall === 'date' || functionToCall.startsWith('daterange')) {\n        const dateMatch = finalValue.match(/^(\\d{4}-\\d{2}-\\d{2})/);\n        if (dateMatch) {\n          const date = new Date(dateMatch[1]);\n          const year = date.getFullYear();\n          const week = getISOWeek(date);\n          finalValue = `${year}-W${week.toString().padStart(2, '0')}`;\n        } else {\n          console.warn('[Gofakeit Autofill] Could not parse date for week from response:', finalValue);\n          return { success: false, usedFunc: functionToCall };\n        }\n      }\n    }\n    \n    setDateTimeInput(element, finalValue);\n    return { success: true, usedFunc: functionToCall };\n    \n  } catch (error) {\n    console.warn(`[Gofakeit Autofill] Unexpected error handling ${inputType} input:`, error);\n    return { success: false, usedFunc: functionToCall };\n  }\n}\n","import { callFunc } from './api';\nimport { handleError, getDefaultFunctionForInputType } from './autofill';\n\n// Get function name for text input (for batch processing)\nexport function getTextInput(element: HTMLInputElement, gofakeitFunc: string): string {\n  const inputType = element.type.toLowerCase();\n  \n  // Map input types to appropriate gofakeit functions if 'true' is passed\n  if (gofakeitFunc === 'true') {\n    switch (inputType) {\n      case 'email':\n        return 'email';\n      case 'tel':\n        return 'phone';\n      case 'password':\n        return 'password';\n      case 'search':\n        return 'word';\n      case 'url':\n        return 'url';\n      case 'color':\n        return 'hexcolor';\n      default:\n        return 'word'; // Default for text inputs\n    }\n  }\n  \n  return gofakeitFunc;\n}\n\n// Set text input value (for batch processing)\nexport function setTextInput(element: HTMLInputElement, value: string): void {\n  element.value = value;\n  element.dispatchEvent(new Event('input', { bubbles: true }));\n  element.dispatchEvent(new Event('change', { bubbles: true }));\n}\n\n// Handle text input elements (text, email, tel, password, search, url, color)\nexport async function handleTextInput(element: HTMLInputElement, gofakeitFunc: string): Promise<{ success: boolean, usedFunc: string }> {\n  const functionToCall = getTextInput(element, gofakeitFunc);\n  \n  const response = await callFunc(functionToCall);\n  \n  if (!response.success) {\n    console.warn(`[Gofakeit Autofill] Error for function ${functionToCall}:`, response.error);\n    \n    if (response.status === 400) {\n      handleError(element, '', functionToCall);\n    }\n    \n    // Fallback to default function for this input type\n    const inputType = element.type.toLowerCase();\n    const fallbackFunc = getDefaultFunctionForInputType(inputType);\n    if (fallbackFunc !== functionToCall) {\n      console.warn(`[Gofakeit Autofill] Falling back to default function: ${fallbackFunc}`);\n      const fallbackResponse = await callFunc(fallbackFunc);\n      if (fallbackResponse.success) {\n        setTextInput(element, fallbackResponse.data!);\n        return { success: true, usedFunc: fallbackFunc };\n      }\n    }\n    \n    return { success: false, usedFunc: functionToCall };\n  }\n  \n  setTextInput(element, response.data!);\n  return { success: true, usedFunc: functionToCall };\n}\n\n// Get function name for textarea (for batch processing)\nexport function getTextarea(gofakeitFunc: string): string {\n  return gofakeitFunc === 'true' ? 'sentence' : gofakeitFunc;\n}\n\n// Set textarea value (for batch processing)\nexport function setTextarea(element: HTMLTextAreaElement, value: string): void {\n  element.value = value;\n  element.dispatchEvent(new Event('input', { bubbles: true }));\n  element.dispatchEvent(new Event('change', { bubbles: true }));\n}\n\n// Handle textarea elements\nexport async function handleTextarea(element: HTMLTextAreaElement, gofakeitFunc: string): Promise<{ success: boolean, usedFunc: string }> {\n  // Use sentence function if 'true' is passed, otherwise use the provided function\n  const functionToCall = getTextarea(gofakeitFunc);\n  \n  const response = await callFunc(functionToCall);\n  \n  if (!response.success) {\n    console.warn(`[Gofakeit Autofill] Error for function ${functionToCall}:`, response.error);\n    \n    if (response.status === 400) {\n      handleError(element, '', functionToCall);\n    }\n    \n    // Fallback to default function (sentence)\n    const fallbackFunc = 'sentence';\n    if (fallbackFunc !== functionToCall) {\n      console.warn(`[Gofakeit Autofill] Falling back to default function: ${fallbackFunc}`);\n      const fallbackResponse = await callFunc(fallbackFunc);\n      if (fallbackResponse.success) {\n        setTextarea(element, fallbackResponse.data!);\n        return { success: true, usedFunc: fallbackFunc };\n      }\n    }\n    \n    return { success: false, usedFunc: functionToCall };\n  }\n  \n  setTextarea(element, response.data!);\n  return { success: true, usedFunc: functionToCall };\n}\n\n","import { callFunc } from './api';\nimport { handleError } from './autofill';\n\n// Handle checkbox input elements\nexport async function handleCheckbox(element: HTMLInputElement, gofakeitFunc: string, value?: string): Promise<{ success: boolean, usedFunc: string }> {\n  // Find the checkbox group by name\n  const checkboxGroup = findCheckboxGroup(element);\n  \n  if (checkboxGroup.length === 0) {\n    console.warn('[Gofakeit Autofill] No checkbox group found for element:', element);\n    return { success: false, usedFunc: 'bool' };\n  }\n  \n  // Use boolean function if 'true' is passed, otherwise use the provided function\n  const functionToCall = gofakeitFunc === 'true' ? 'bool' : gofakeitFunc;\n  \n  // If value is provided (from batch), use it directly\n  if (value !== undefined) {\n    // Clear all checkboxes first\n    checkboxGroup.forEach(cb => {\n      cb.checked = false;\n      cb.dispatchEvent(new Event('change', { bubbles: true }));\n    });\n    \n    // For boolean values, check if it's true\n    const boolValue = String(value).toLowerCase() === 'true' || value === '1' || String(value).toLowerCase() === 'yes';\n    if (boolValue && checkboxGroup.length > 0) {\n      // Select the first checkbox if value is true\n      checkboxGroup[0].checked = true;\n      checkboxGroup[0].dispatchEvent(new Event('change', { bubbles: true }));\n    }\n    \n    return { success: true, usedFunc: functionToCall };\n  }\n  \n  // For checkbox groups, we want to select multiple checkboxes\n  if (gofakeitFunc === 'true') {\n    // Select roughly half of the checkboxes in the group\n    const numToSelect = Math.max(1, Math.ceil(checkboxGroup.length / 2));\n    \n    // Clear all checkboxes first\n    checkboxGroup.forEach(cb => {\n      cb.checked = false;\n      cb.dispatchEvent(new Event('change', { bubbles: true }));\n    });\n    \n    // Select random checkboxes using API\n    const selectedIndices = new Set<number>();\n    for (let i = 0; i < numToSelect; i++) {\n      const boolResponse = await callFunc('bool');\n      if (boolResponse.success) {\n        const shouldSelect = boolResponse.data!.toLowerCase() === 'true' || boolResponse.data!.toLowerCase() === '1';\n        if (shouldSelect) {\n          // Find an unselected checkbox\n          const availableIndices = Array.from({ length: checkboxGroup.length }, (_, i) => i)\n            .filter(i => !selectedIndices.has(i));\n          \n          if (availableIndices.length > 0) {\n            const randomIndex = availableIndices[Math.floor(Math.random() * availableIndices.length)];\n            selectedIndices.add(randomIndex);\n            checkboxGroup[randomIndex].checked = true;\n            checkboxGroup[randomIndex].dispatchEvent(new Event('change', { bubbles: true }));\n          }\n        }\n      }\n    }\n  } else {\n    // For custom functions, use the response to determine which checkboxes to select\n    const response = await callFunc(functionToCall);\n    \n    if (!response.success) {\n      console.warn(`[Gofakeit Autofill] Error for function ${functionToCall}:`, response.error);\n      \n      if (response.status === 400) {\n        handleError(element, '', functionToCall);\n      }\n      return { success: false, usedFunc: functionToCall };\n    }\n    \n    // Clear all checkboxes first\n    checkboxGroup.forEach(cb => {\n      cb.checked = false;\n      cb.dispatchEvent(new Event('change', { bubbles: true }));\n    });\n    \n    // Parse the response to determine which checkboxes to select\n    const values = response.data!.split(',').map(v => v.trim());\n    \n    checkboxGroup.forEach((cb, index) => {\n      const shouldCheck = values.includes(cb.value) || values.includes(index.toString());\n      cb.checked = shouldCheck;\n      cb.dispatchEvent(new Event('change', { bubbles: true }));\n    });\n  }\n  \n  return { success: true, usedFunc: functionToCall };\n}\n\n// Handle radio inputs\nexport async function handleRadio(element: HTMLInputElement, gofakeitFunc: string, value?: string): Promise<{ success: boolean, usedFunc: string, selectedElement?: HTMLInputElement }> {\n  const radioGroup = findRadioGroup(element);\n  // For radio buttons, when 'true' is passed, we actually use 'bool' function\n  const functionToCall = gofakeitFunc === 'true' ? 'bool' : gofakeitFunc;\n  \n  // If a specific value is provided, try to select that radio button\n  if (value !== undefined) {\n    // Clear all radio buttons first\n    radioGroup.forEach((rb: HTMLInputElement) => {\n      rb.checked = false;\n      rb.dispatchEvent(new Event('change', { bubbles: true }));\n    });\n    \n    // Try to find by value first, then by index\n    let selectedRadio = radioGroup.find((rb: HTMLInputElement) => rb.value === value);\n    if (!selectedRadio && !isNaN(Number(value))) {\n      const index = parseInt(value);\n      if (index >= 0 && index < radioGroup.length) {\n        selectedRadio = radioGroup[index];\n      }\n    }\n    \n    // If no match found, select the first one\n    if (selectedRadio) {\n      selectedRadio.checked = true;\n      selectedRadio.dispatchEvent(new Event('change', { bubbles: true }));\n    }\n    \n    return { success: true, usedFunc: functionToCall, selectedElement: selectedRadio };\n  }\n  \n  // For radio groups, we want to select exactly one radio button\n  if (gofakeitFunc === 'true') {\n    // Clear all radio buttons first\n    radioGroup.forEach((rb: HTMLInputElement) => {\n      rb.checked = false;\n      rb.dispatchEvent(new Event('change', { bubbles: true }));\n    });\n    \n    // Always select exactly one random radio button\n    const randomIndex = Math.floor(Math.random() * radioGroup.length);\n    radioGroup[randomIndex].checked = true;\n    radioGroup[randomIndex].dispatchEvent(new Event('change', { bubbles: true }));\n    \n    return { success: true, usedFunc: functionToCall, selectedElement: radioGroup[randomIndex] };\n  } else {\n    // For custom functions, use the response to determine which radio button to select\n    const response = await callFunc(functionToCall);\n    \n    if (!response.success) {\n      console.warn(`[Gofakeit Autofill] Error for function ${functionToCall}:`, response.error);\n      \n      if (response.status === 400) {\n        handleError(element, '', functionToCall);\n      }\n      return { success: false, usedFunc: functionToCall };\n    }\n    \n    // Clear all radio buttons first\n    radioGroup.forEach((rb: HTMLInputElement) => {\n      rb.checked = false;\n      rb.dispatchEvent(new Event('change', { bubbles: true }));\n    });\n    \n    // Parse the response to determine which radio button to select\n    const value = response.data!.trim();\n    \n    // Try to find by value first, then by index\n    let selectedRadio = radioGroup.find((rb: HTMLInputElement) => rb.value === value);\n    if (!selectedRadio && !isNaN(Number(value))) {\n      const index = parseInt(value);\n      if (index >= 0 && index < radioGroup.length) {\n        selectedRadio = radioGroup[index];\n      }\n    }\n    \n    // If no match found, select a random one to ensure exactly one is selected\n    if (selectedRadio) {\n      selectedRadio.checked = true;\n      selectedRadio.dispatchEvent(new Event('change', { bubbles: true }));\n      \n      return { success: true, usedFunc: functionToCall, selectedElement: selectedRadio };\n    } else {\n      // Fallback: select a random radio button\n      const randomIndex = Math.floor(Math.random() * radioGroup.length);\n      radioGroup[randomIndex].checked = true;\n      radioGroup[randomIndex].dispatchEvent(new Event('change', { bubbles: true }));\n      \n      return { success: true, usedFunc: functionToCall, selectedElement: radioGroup[randomIndex] };\n    }\n  }\n}\n\n// Helper function to find checkbox group\nfunction findCheckboxGroup(element: HTMLInputElement): HTMLInputElement[] {\n  if (element.type !== 'checkbox') return [element];\n  \n  // Look for checkboxes with the same name or in the same container\n  const name = element.name;\n  const container = element.closest('form, div, fieldset') || document;\n  \n  if (name) {\n    // Find checkboxes with the same name\n    return Array.from(container.querySelectorAll(`input[type=\"checkbox\"][name=\"${name}\"]`));\n  } else {\n    // Find checkboxes in the same container\n    return Array.from(container.querySelectorAll('input[type=\"checkbox\"]'));\n  }\n}\n\n// Helper function to find radio group\nfunction findRadioGroup(element: HTMLInputElement): HTMLInputElement[] {\n  if (element.type !== 'radio') return [element];\n  \n  // Look for radio buttons with the same name\n  const name = element.name;\n  \n  if (name) {\n    // Search the entire document for radio buttons with the same name\n    const radioButtons = Array.from(document.querySelectorAll(`input[type=\"radio\"][name=\"${name}\"]`)) as HTMLInputElement[];\n    return radioButtons;\n  } else {\n    // Find radio buttons in the same container\n    const container = element.closest('form, div, fieldset') || document;\n    const radioButtons = Array.from(container.querySelectorAll('input[type=\"radio\"]')) as HTMLInputElement[];\n    return radioButtons;\n  }\n}\n\n// Handle select dropdown\nexport async function handleSelectWithFunction(element: HTMLSelectElement, gofakeitFunc: string, value?: string): Promise<{ success: boolean, usedFunc: string }> {\n  const options = Array.from(element.options).map(option => option.value).filter(value => value !== '');\n  \n  if (options.length === 0) {\n    console.warn('[Gofakeit Autofill] Select element has no valid options:', element);\n    return { success: false, usedFunc: gofakeitFunc };\n  }\n  \n  // If value is provided (from batch), use it directly\n  if (value !== undefined) {\n    if (element.multiple) {\n      // Handle multiselect\n      Array.from(element.options).forEach(option => option.selected = false);\n      \n      // Parse comma-separated values\n      const selectedValues = value.split(',').map(val => val.trim()).filter(val => val !== '');\n      selectedValues.forEach(value => {\n        const option = element.options.namedItem(value) || Array.from(element.options).find(opt => opt.value === value);\n        if (option) option.selected = true;\n      });\n    } else {\n      // Try to set the value directly\n      const option = element.options.namedItem(value) || Array.from(element.options).find(opt => opt.value === value);\n      if (option) {\n        element.value = value;\n      } else {\n        // If the value doesn't match any option, select a random option\n        const validOptions = options.filter(opt => opt !== '');\n        if (validOptions.length > 0) {\n          const randomOption = validOptions[Math.floor(Math.random() * validOptions.length)];\n          element.value = randomOption;\n        } else {\n          // If no valid options, don't set any value\n          return { success: false, usedFunc: gofakeitFunc };\n        }\n      }\n    }\n    \n    element.dispatchEvent(new Event('change', { bubbles: true }));\n    return { success: true, usedFunc: gofakeitFunc === 'true' ? 'random' : gofakeitFunc };\n  }\n  \n  let response;\n  if (gofakeitFunc === 'true') {\n    // Use random selection for 'true' - randomly select from options\n    const randomIndex = Math.floor(Math.random() * options.length);\n    const selectedOption = options[randomIndex];\n    response = { success: true, data: selectedOption };\n  } else {\n    // Use custom function\n    response = await callFunc(gofakeitFunc);\n  }\n  \n  if (!response.success) {\n    console.warn(`[Gofakeit Autofill] Error for select:`, response.error);\n    if (response.status === 400) {\n      handleError(element, 'Failed to get selection');\n    }\n    return { success: false, usedFunc: gofakeitFunc };\n  }\n  \n  if (element.multiple) {\n    // Handle multiselect\n    Array.from(element.options).forEach(option => option.selected = false);\n    \n    if (gofakeitFunc === 'true') {\n      // For random selection, select multiple options (roughly half)\n      const numToSelect = Math.min(Math.ceil(options.length / 2), options.length);\n      const selectedValues = [response.data!];\n      \n      // Add more random selections\n      const remainingOptions = options.filter(opt => opt !== response.data!);\n      for (let i = 1; i < numToSelect && remainingOptions.length > 0; i++) {\n        const randomIndex = Math.floor(Math.random() * remainingOptions.length);\n        selectedValues.push(remainingOptions.splice(randomIndex, 1)[0]);\n      }\n      \n      selectedValues.forEach(value => {\n        const option = element.options.namedItem(value) || Array.from(element.options).find(opt => opt.value === value);\n        if (option) option.selected = true;\n      });\n    } else {\n      // Parse comma-separated values for custom function\n      const selectedValues = response.data!.split(',').map(val => val.trim()).filter(val => val !== '');\n      selectedValues.forEach(value => {\n        const option = element.options.namedItem(value) || Array.from(element.options).find(opt => opt.value === value);\n        if (option) option.selected = true;\n      });\n    }\n  } else {\n    element.value = response.data!;\n  }\n  \n  element.dispatchEvent(new Event('change', { bubbles: true }));\n  return { success: true, usedFunc: gofakeitFunc === 'true' ? 'random' : gofakeitFunc };\n}\n","import { callFunc } from './api';\nimport { handleError } from './autofill';\n\n// Get function name for number input (for batch processing)\nexport function getNumberInput(gofakeitFunc: string): string {\n  return gofakeitFunc === 'true' ? 'number' : gofakeitFunc;\n}\n\n// Set number input value (for batch processing)\nexport function setNumberInput(element: HTMLInputElement, value: string): void {\n  element.value = value;\n  element.dispatchEvent(new Event('input', { bubbles: true }));\n  element.dispatchEvent(new Event('change', { bubbles: true }));\n}\n\n// Handle number input elements\nexport async function handleNumberInput(element: HTMLInputElement, gofakeitFunc: string): Promise<{ success: boolean, usedFunc: string }> {\n  // Use number function if 'true' is passed, otherwise use the provided function\n  const functionToCall = getNumberInput(gofakeitFunc);\n  \n  const response = await callFunc(functionToCall);\n  \n  if (!response.success) {\n    console.warn(`[Gofakeit Autofill] Error for function ${functionToCall}:`, response.error);\n    \n    if (response.status === 400) {\n      handleError(element, '', functionToCall);\n    }\n    return { success: false, usedFunc: functionToCall };\n  }\n  \n  setNumberInput(element, response.data!);\n  return { success: true, usedFunc: functionToCall };\n}\n\n// Get function name for range input (for batch processing)\nexport function getRangeInput(element: HTMLInputElement): string {\n  const min = parseFloat(element.min) || 0;\n  const max = parseFloat(element.max) || 100;\n  return `number?min=${min}&max=${max}`;\n}\n\n// Set range input value (for batch processing)\nexport function setRangeInput(element: HTMLInputElement, value: string): void {\n  const numValue = parseFloat(value);\n  if (!isNaN(numValue)) {\n    const min = parseFloat(element.min) || 0;\n    const max = parseFloat(element.max) || 100;\n    const clampedValue = Math.max(min, Math.min(max, numValue));\n    element.value = clampedValue.toString();\n    element.dispatchEvent(new Event('input', { bubbles: true }));\n    element.dispatchEvent(new Event('change', { bubbles: true }));\n  }\n}\n\n// Handle range input elements\nexport async function handleRangeInput(element: HTMLInputElement): Promise<{ success: boolean, usedFunc: string }> {\n  // For range inputs, always use gofakeit API with min/max from the element\n  const functionToCall = getRangeInput(element);\n  \n  const response = await callFunc(functionToCall);\n  \n  if (!response.success) {\n    console.warn(`[Gofakeit Autofill] Error for range input:`, response.error);\n    \n    if (response.status === 400) {\n      handleError(element, 'Failed to get random number for range');\n    }\n    return { success: false, usedFunc: functionToCall };\n  }\n  \n  setRangeInput(element, response.data!);\n  return { success: true, usedFunc: functionToCall };\n}\n","import { GOFAKEIT_COLORS } from './styles';\nimport { handleDateTimeInput } from './input-datetime';\nimport { handleTextInput, handleTextarea, getTextarea, setTextInput, setTextarea } from './input-text';\nimport { handleCheckbox, handleRadio, handleSelectWithFunction } from './input-misc';\nimport { handleNumberInput, handleRangeInput, getRangeInput, setNumberInput, setRangeInput } from './input-number';\nimport { callMultiFunc, MultiFuncRequest, searchMultiFunc, FuncSearchRequest } from './api';\n\nexport interface AutofillSettings {\n  smart?: boolean;\n  staggered?: boolean;\n  staggerDelay?: number;\n}\n\n// ============================================================================\n// MAIN PUBLIC FUNCTIONS (Entry Points)\n// ============================================================================\n\n// Unified autofill function that handles all cases\nexport async function autofill(target?: HTMLElement | Element | string, settings?: AutofillSettings): Promise<boolean | void> {\n  const defaultSettings: AutofillSettings = { smart: true }; // Default to true for backward compatibility\n  const finalSettings = { ...defaultSettings, ...settings };\n  \n  // No parameters - autofill all form fields on the page\n  if (!target) {\n    return autofillAll(finalSettings);\n  }\n\n  // If target is a string, treat it as a CSS selector (ID, class, or other selector)\n  if (typeof target === 'string') {\n    const element = document.querySelector(target) as HTMLElement;\n    if (element) {\n      console.log(`[Gofakeit] Found element with selector \"${target}\":`, element);\n      target = element;\n    } else {\n      console.warn(`[Gofakeit] No element found with selector: \"${target}\"`);\n      showNotification(`No element found with selector: ${target}`, 'error');\n      return false;\n    }\n  }\n  \n  // If target is a container (has form fields), autofill the container\n  if (target instanceof HTMLElement && hasFormFields(target)) {\n    return autofillContainer(target, finalSettings);\n  }\n  \n  // If target is a form element, autofill just that element\n  if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement || target instanceof HTMLSelectElement) {\n    const success = await autofillElement(target, finalSettings);\n    if (!success) {\n      showNotification('Failed to autofill the specified element', 'error');\n    }\n    return success;\n  }\n  \n  // If target is a container but doesn't have form fields, try to find a container\n  if (target instanceof HTMLElement) {\n    const container = findFormContainer(target);\n    if (container) {\n      return autofillContainer(container, finalSettings);\n    }\n  }\n  \n  // For non-form elements, return false instead of falling back to autofill all\n  return false;\n}\n\n// Autofill all form fields on the page\nasync function autofillAll(settings: AutofillSettings): Promise<void> {\n  const elements = queryFormElements();\n  const smartMode = settings.smart ?? true;\n\n  // Smart mode: Fill ALL form fields (except those explicitly excluded)\n  // Manual mode: Only fill fields with data-gofakeit attributes\n  const targetsBase = smartMode\n    ? elements\n    : elements.filter((el) => (el as Element).hasAttribute('data-gofakeit'));\n  const targets = targetsBase.filter((el) => !isDataGofakeitFalse(el));\n\n  if (targets.length === 0) {\n    if (!smartMode) {\n      showNotification('No data-gofakeit fields exist. Turn on Smart mode to fill all form fields.', 'info');\n    } else {\n      showNotification('No form fields found to autofill', 'info');\n    }\n    return;\n  }\n\n  console.log(`[Gofakeit] Found ${targets.length} elements to generate data for`);\n  showNotification(`Starting data generation for ${targets.length} fields...`, 'info');\n\n  const results = await processElements(targets, settings);\n  showResults(results.success, results.failed, 'Autofill');\n}\n\n// Autofill all fields within a specific container\nasync function autofillContainer(container: HTMLElement, settings: AutofillSettings): Promise<void> {\n  const elements = queryFormElements(container);\n  const smartMode = settings.smart ?? true;\n\n  // Smart mode: Fill ALL form fields in container (except those explicitly excluded)\n  // Manual mode: Only fill fields with data-gofakeit attributes\n  const targetsBase = smartMode\n    ? elements\n    : elements.filter((el) => (el as Element).hasAttribute('data-gofakeit'));\n  const targets = targetsBase.filter((el) => !isDataGofakeitFalse(el));\n\n  if (targets.length === 0) {\n    if (!smartMode) {\n      showNotification('No data-gofakeit fields exist in this section. Turn on Smart mode to fill all form fields.', 'info');\n    } else {\n      showNotification('No form fields found in this container', 'info');\n    }\n    return;\n  }\n  \n  console.log(`[Gofakeit] Found ${targets.length} elements to generate data for in container`);\n  showNotification(`Starting data generation for ${targets.length} fields...`, 'info');\n  \n  const results = await processElements(targets, settings);\n  showResults(results.success, results.failed, 'Container autofill');\n}\n\n// Main autofill function that routes to specific handlers\nasync function autofillElement(element: Element, settings: AutofillSettings): Promise<boolean> {\n  const gofakeitFunc = element.getAttribute('data-gofakeit');\n  if (typeof gofakeitFunc === 'string' && gofakeitFunc.trim().toLowerCase() === 'false') {\n    return false;\n  }\n  \n  const smartMode = settings.smart ?? true;\n  // Smart mode: Fill any form field (even without data-gofakeit attribute)\n  // Manual mode: Only fill fields that have data-gofakeit attributes\n  if (!gofakeitFunc && !smartMode) {\n    return false;\n  }\n\n  try {\n    // Handle select dropdowns\n    if (element instanceof HTMLSelectElement) {\n      const funcToUse = (gofakeitFunc && gofakeitFunc !== 'true') ? gofakeitFunc : 'true';\n      const { success, usedFunc } = await handleSelectWithFunction(element, funcToUse);\n      if (success) {\n        showBadgeWithTiming(element, usedFunc, settings);\n      }\n      return success;\n    }\n    \n    // Handle textarea elements\n    if (element instanceof HTMLTextAreaElement) {\n      const funcToUse = (gofakeitFunc && gofakeitFunc !== 'true') ? gofakeitFunc : 'sentence';\n      const { success, usedFunc } = await handleTextarea(element, funcToUse);\n      if (success) {\n        showBadgeWithTiming(element, usedFunc, settings);\n      }\n      return success;\n    }\n    \n    // Handle input elements\n    if (element instanceof HTMLInputElement) {\n      const inputType = element.type.toLowerCase();\n      \n      // Handle checkbox inputs\n      if (inputType === 'checkbox') {\n        const passToHandler = (gofakeitFunc && gofakeitFunc !== 'true') ? gofakeitFunc : 'true';\n        const { success, usedFunc } = await handleCheckbox(element, passToHandler);\n        if (success) {\n          showBadgeWithTiming(element, usedFunc, settings);\n        }\n        return success;\n      }\n      \n      // Handle radio inputs\n      if (inputType === 'radio') {\n        const passToHandler = (gofakeitFunc && gofakeitFunc !== 'true') ? gofakeitFunc : 'true';\n        const { success, usedFunc, selectedElement } = await handleRadio(element, passToHandler);\n        if (success) {\n          // Show function badge over the selected radio button, not the original one\n          const elementToShowBadge = selectedElement || element;\n          showBadgeWithTiming(elementToShowBadge, usedFunc, settings);\n        }\n        return success;\n      }\n      \n      // Handle range inputs\n      if (inputType === 'range') {\n        const { success, usedFunc } = await handleRangeInput(element);\n        if (success) {\n          showBadgeWithTiming(element, usedFunc, settings);\n        }\n        return success;\n      }\n      \n      // Handle all other input types (text, email, tel, password, search, url, color, number, date, etc.)\n      const inferred = (gofakeitFunc && gofakeitFunc !== 'true') ? gofakeitFunc : await searchFunctionForInput(element);\n      \n      // Route to appropriate handler based on input type\n      if (inputType === 'number') {\n        const { success, usedFunc } = await handleNumberInput(element, inferred);\n        if (success) {\n          showBadgeWithTiming(element, usedFunc, settings);\n        }\n        return success;\n      }\n      \n      if (inputType === 'date' || inputType === 'time' || inputType === 'datetime-local' || \n          inputType === 'month' || inputType === 'week') {\n        const { success, usedFunc } = await handleDateTimeInput(element, inferred);\n        if (success) {\n          showBadgeWithTiming(element, usedFunc, settings);\n        }\n        return success;\n      }\n      \n      // Handle text inputs (text, email, tel, password, search, url, color, etc.)\n      const { success, usedFunc } = await handleTextInput(element, inferred);\n      if (success) {\n        showBadgeWithTiming(element, usedFunc, settings);\n      }\n      return success;\n    }\n    \n    console.warn('[Gofakeit] Unsupported element type:', element);\n    return false;\n    \n  } catch (error) {\n    console.error('[Gofakeit] Unexpected error generating data for element:', element, error);\n    return false;\n  }\n}\n\n// ============================================================================\n// PROCESSING FUNCTIONS (Called by main functions)\n// ============================================================================\n\n// Query all form elements that can be autofilled\nfunction queryFormElements(container?: HTMLElement): Element[] {\n  const selector = 'input, textarea, select';\n  const nodeList = container ? container.querySelectorAll(selector) : document.querySelectorAll(selector);\n  const elements: Element[] = [];\n  nodeList.forEach((el) => {\n    if (el instanceof HTMLInputElement) {\n      if (el.type === 'hidden' || el.disabled || el.readOnly) return;\n      elements.push(el);\n    } else if (el instanceof HTMLTextAreaElement) {\n      if (el.disabled || el.readOnly) return;\n      elements.push(el);\n    } else if (el instanceof HTMLSelectElement) {\n      if (el.disabled) return;\n      elements.push(el);\n    }\n  });\n  return elements;\n}\n\nfunction isDataGofakeitFalse(el: Element): boolean {\n  const val = (el as Element).getAttribute && (el as Element).getAttribute('data-gofakeit');\n  return typeof val === 'string' && val.trim().toLowerCase() === 'false';\n}\n\n// Get unique elements, handling checkbox and radio groups\nfunction getUniqueElements(elements: Element[]): Element[] {\n  const uniqueElements: Element[] = [];\n  const processedGroups = new Set<string>();\n  \n  for (const element of elements) {\n    if (element instanceof HTMLInputElement) {\n      const inputType = element.type.toLowerCase();\n      \n      if (inputType === 'checkbox' || inputType === 'radio') {\n        const name = element.name;\n        if (name && processedGroups.has(name)) {\n          // Skip if we've already processed this group\n          continue;\n        }\n        if (name) {\n          processedGroups.add(name);\n        }\n      }\n    }\n    \n    uniqueElements.push(element);\n  }\n  \n  return uniqueElements;\n}\n\n// Process multiple elements and track results using batched API calls\nasync function processElements(elements: Element[], settings: AutofillSettings): Promise<{ success: number, failed: number }> {\n  let successfulCount = 0;\n  let failedCount = 0;\n  \n  // Get unique elements to avoid processing checkbox/radio groups multiple times\n  const uniqueElements = getUniqueElements(elements);\n\n  // Separate input elements from other elements\n  const searchInputElements: HTMLInputElement[] = [];\n  const otherElements: Element[] = [];\n  \n  for (const element of uniqueElements) {\n    const gofakeitFunc = element.getAttribute('data-gofakeit');\n    \n    // Check if element has a specific function value (not \"true\" or \"false\")\n    const hasSpecificFunction = gofakeitFunc && \n      gofakeitFunc.trim().toLowerCase() !== 'true' && \n      gofakeitFunc.trim().toLowerCase() !== 'false';\n    \n    if (element instanceof HTMLInputElement) {\n      const inputType = element.type.toLowerCase();\n      if (needsSearchApi(inputType) && !hasSpecificFunction) {\n        // Only use search API for elements that need it and don't have specific functions\n        searchInputElements.push(element);\n      } else {\n        // For excluded input types or elements with specific functions, add them to otherElements\n        otherElements.push(element);\n      }\n    } else {\n      otherElements.push(element);\n    }\n  }\n\n  // Use search API to get functions for all searchable input elements at once\n  let inputFunctionMap = new Map<HTMLInputElement, string>();\n  if (searchInputElements.length > 0) {\n    try {\n      inputFunctionMap = await searchFunctionsForInputs(searchInputElements);\n    } catch (error) {\n      console.warn('[Gofakeit Autofill] Search API failed, falling back to individual function detection:', error);\n      // Fallback to individual function detection\n      for (const element of searchInputElements) {\n        const func = await getElementFunction(element, settings);\n        if (func) {\n          inputFunctionMap.set(element, func);\n        }\n      }\n    }\n  }\n\n  // Process excluded elements individually (they don't use batch API)\n  const excludedElements: Element[] = [];\n  const batchElements: { element: Element, func: string }[] = [];\n  \n  // Add input elements with their search API functions to batch\n  searchInputElements.forEach(element => {\n    const func = inputFunctionMap.get(element);\n    if (func) {\n      batchElements.push({ element, func });\n    }\n  });\n  \n  // Process other elements (select, textarea, checkbox, radio, etc.)\n  for (const element of otherElements) {\n    try {\n      const func = await getElementFunction(element, settings);\n      if (func) {\n        // Check if this is an excluded type that should be processed individually\n        if (element instanceof HTMLInputElement) {\n          const inputType = element.type.toLowerCase();\n          if (['checkbox', 'radio', 'range', 'file', 'button', 'submit', 'reset', 'image', 'color', 'date', 'time', 'datetime-local', 'month', 'week'].includes(inputType)) {\n            // Process excluded types individually\n            excludedElements.push(element);\n            continue;\n          }\n        }\n        // Add to batch for other types (select, textarea, etc.)\n        batchElements.push({ element, func });\n      }\n    } catch (error) {\n      failedCount++;\n      console.warn(`[Gofakeit Autofill] Failed to get function for element:`, element, error);\n    }\n  }\n\n  // Process excluded elements with appropriate timing\n  const testMode = (globalThis as any).__GOFAKEIT_TEST_MODE__;\n  const staggered = testMode ? false : (settings.staggered ?? true);\n  \n  if (staggered) {\n    // Process excluded elements individually with staggered timing\n    for (let i = 0; i < excludedElements.length; i++) {\n      const element = excludedElements[i];\n      const staggerDelay = settings.staggerDelay ?? 50;\n      \n      if (i > 0) {\n        await new Promise(resolve => setTimeout(resolve, staggerDelay));\n      }\n      \n      try {\n        const success = await autofillElement(element, settings);\n        if (success) {\n          successfulCount++;\n        } else {\n          failedCount++;\n        }\n      } catch (error) {\n        failedCount++;\n        console.warn(`[Gofakeit Autofill] Failed to process excluded element:`, element, error);\n      }\n    }\n  } else {\n    // Process excluded elements all at once for fast mode\n    const promises = excludedElements.map(async (element) => {\n      try {\n        const success = await autofillElement(element, settings);\n        return success;\n      } catch (error) {\n        console.warn(`[Gofakeit Autofill] Failed to process excluded element:`, element, error);\n        return false;\n      }\n    });\n    \n    const results = await Promise.all(promises);\n    results.forEach(success => {\n      if (success) {\n        successfulCount++;\n      } else {\n        failedCount++;\n      }\n    });\n  }\n\n  // Process batch elements if any exist\n  if (batchElements.length === 0) {\n    return { success: successfulCount, failed: failedCount };\n  }\n\n  // Create batch requests\n  const requests: MultiFuncRequest[] = batchElements.map((item, index) => ({\n    id: `req_${index}`,\n    func: item.func\n  }));\n\n  // Make single batch API call\n  const batchResponse = await callMultiFunc(requests);\n  \n  if (!batchResponse.success || !batchResponse.data) {\n    console.error('[Gofakeit Autofill] Batch API call failed:', batchResponse.error);\n    return { success: successfulCount, failed: failedCount + batchElements.length };\n  }\n\n  // Process responses using existing handlers with staggered timing\n  for (let i = 0; i < batchElements.length; i++) {\n    const { element, func } = batchElements[i];\n    const response = batchResponse.data[i];\n    \n    // Add staggered delay for visual effect if enabled\n    const testMode = (globalThis as any).__GOFAKEIT_TEST_MODE__;\n    const staggered = testMode ? false : (settings.staggered ?? true);\n    const staggerDelay = settings.staggerDelay ?? 50;\n    if (staggered && i > 0) {\n      await new Promise(resolve => setTimeout(resolve, staggerDelay));\n    }\n    \n    if (response && response.error) {\n      // Handle API errors - display error message above the field\n      failedCount++;\n      console.warn(`[Gofakeit Autofill] API error for element:`, element, response.error);\n      showFunctionBadge(element, response.error, 'error');\n    } else if (response && response.value !== null) {\n      try {\n        // Use the existing autofillElement function with the batch response value\n        const success = await autofillElementWithValue(element, func, response.value, settings);\n        if (success) {\n          successfulCount++;\n          \n          // Monitor if the value gets cleared after a short delay\n          setTimeout(() => {\n            if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n              if (element.value === '') {\n                console.warn('[Gofakeit Autofill] Value was cleared for element:', element);\n              }\n            } else if (element instanceof HTMLSelectElement) {\n              if (element.value === '') {\n                console.warn('[Gofakeit Autofill] Value was cleared for select:', element);\n              }\n            }\n          }, 1000);\n        } else {\n          failedCount++;\n        }\n      } catch (error) {\n        failedCount++;\n        console.warn(`[Gofakeit Autofill] Failed to apply value to element:`, element, error);\n      }\n    } else {\n      failedCount++;\n      console.warn(`[Gofakeit Autofill] No valid response for element:`, element);\n    }\n  }\n\n  return { success: successfulCount, failed: failedCount };\n}\n\n// Get the function name for an element (same logic as autofillElement but returns function name)\nasync function getElementFunction(element: Element, settings: AutofillSettings): Promise<string | null> {\n  const gofakeitFunc = element.getAttribute('data-gofakeit');\n  if (typeof gofakeitFunc === 'string' && gofakeitFunc.trim().toLowerCase() === 'false') {\n    return null;\n  }\n  \n  const smartMode = settings.smart ?? true;\n  if (!gofakeitFunc && !smartMode) {\n    return null;\n  }\n\n  try {\n    // Handle select dropdowns\n    if (element instanceof HTMLSelectElement) {\n      return (gofakeitFunc && gofakeitFunc !== 'true') ? gofakeitFunc : 'word';\n    }\n    \n    // Handle textarea elements\n    if (element instanceof HTMLTextAreaElement) {\n      return getTextarea(gofakeitFunc || 'true');\n    }\n    \n    // Handle input elements\n    if (element instanceof HTMLInputElement) {\n      const inputType = element.type.toLowerCase();\n      \n      // Handle checkbox inputs\n      if (inputType === 'checkbox') {\n        return (gofakeitFunc && gofakeitFunc !== 'true') ? gofakeitFunc : 'bool';\n      }\n      \n      // Handle radio inputs\n      if (inputType === 'radio') {\n        return (gofakeitFunc && gofakeitFunc !== 'true') ? gofakeitFunc : 'true';\n      }\n      \n      // Handle range inputs\n      if (inputType === 'range') {\n        return getRangeInput(element);\n      }\n      \n      // For text inputs with specific functions, return the function directly\n      if (gofakeitFunc && gofakeitFunc !== 'true') {\n        return gofakeitFunc;\n      }\n      \n      // For all other input types, use search API (this is a fallback for individual elements)\n      return await searchFunctionForInput(element);\n    }\n    \n    console.warn('[Gofakeit] Unsupported element type for batching:', element);\n    return null;\n    \n  } catch (error) {\n    console.error('[Gofakeit] Unexpected error getting function for element:', element, error);\n    return null;\n  }\n}\n\n\n// Autofill an element with a pre-fetched value (for batch processing)\nasync function autofillElementWithValue(element: Element, func: string, value: string, settings?: AutofillSettings): Promise<boolean> {\n  try {\n    // Handle select dropdowns\n    if (element instanceof HTMLSelectElement) {\n      const { success, usedFunc } = await handleSelectWithFunction(element, func, value);\n      if (success) {\n        showBadgeWithTiming(element, usedFunc, settings);\n      }\n      return success;\n    }\n    \n    // Handle textarea elements\n    if (element instanceof HTMLTextAreaElement) {\n      setTextarea(element, value);\n      showBadgeWithTiming(element, func, settings);\n      return true;\n    }\n    \n    // Handle input elements\n    if (element instanceof HTMLInputElement) {\n      const inputType = element.type.toLowerCase();\n      \n      // Handle checkbox inputs\n      if (inputType === 'checkbox') {\n        const { success, usedFunc } = await handleCheckbox(element, func, value);\n        if (success) {\n          showBadgeWithTiming(element, usedFunc, settings);\n        }\n        return success;\n      }\n      \n      // Handle radio inputs\n      if (inputType === 'radio') {\n        const { success, usedFunc } = await handleRadio(element, func, value);\n        if (success) {\n          showBadgeWithTiming(element, usedFunc, settings);\n        }\n        return success;\n      }\n      \n      // Handle number inputs\n      if (inputType === 'number') {\n        setNumberInput(element, value);\n        showBadgeWithTiming(element, func, settings);\n        return true;\n      }\n      \n      // Handle range inputs\n      if (inputType === 'range') {\n        setRangeInput(element, value);\n        showBadgeWithTiming(element, func, settings);\n        return true;\n      }\n      \n      // Handle date/time inputs\n      if (inputType === 'date' || inputType === 'time' || inputType === 'datetime-local' || \n          inputType === 'month' || inputType === 'week') {\n        const { success, usedFunc } = await handleDateTimeInput(element, func, value);\n        if (success) {\n          showBadgeWithTiming(element, usedFunc, settings);\n        }\n        return success;\n      }\n      \n      // Handle text inputs (text, email, tel, password, search, url, color, etc.)\n      setTextInput(element, value);\n      showBadgeWithTiming(element, func, settings);\n      return true;\n    }\n    \n    console.warn('[Gofakeit] Unsupported element type:', element);\n    return false;\n    \n  } catch (error) {\n    console.error('[Gofakeit] Unexpected error generating data for element:', element, error);\n    return false;\n  }\n}\n\n// Show results notification\nfunction showResults(successfulCount: number, failedCount: number, context: string): void {\n  // Show successful count notification\n  if (successfulCount > 0) {\n    console.log(`[Gofakeit] ${context} completed successfully for ${successfulCount} fields`);\n    showNotification(`Successfully generated data for ${successfulCount} fields!`, 'success');\n  }\n  \n  // Show failed count notification\n  if (failedCount > 0) {\n    console.error(`[Gofakeit] ${context} failed for ${failedCount} fields`);\n    showNotification(`Failed to generate data for ${failedCount} fields.`, 'error');\n  }\n  \n  // If no fields were processed at all\n  if (successfulCount === 0 && failedCount === 0) {\n    console.log(`[Gofakeit] ${context} - no fields were processed`);\n    showNotification(`No fields were processed.`, 'info');\n  }\n}\n\n// ============================================================================\n// UTILITY FUNCTIONS (Called by various functions)\n// ============================================================================\n\n// Show function badge with staggered timing\nfunction showBadgeWithTiming(element: Element, func: string, settings?: AutofillSettings): void {\n  const testMode = (globalThis as any).__GOFAKEIT_TEST_MODE__;\n  const staggered = testMode ? false : (settings?.staggered ?? true);\n  const staggerDelay = settings?.staggerDelay ?? 50;\n  \n  // Only delay the badge if staggered is enabled, using the staggerDelay from settings\n  const actualDelay = staggered ? staggerDelay : 0;\n  setTimeout(() => {\n    showFunctionBadge(element, func);\n  }, actualDelay);\n}\n\n// Handle error display and field highlighting\nexport function handleError(element: Element, error: string, functionName?: string): void {\n  if (element instanceof HTMLElement) {\n    element.style.border = `2px solid #dc3545`;\n    \n    setTimeout(() => {\n      element.style.border = '';\n    }, 5000);\n  }\n  \n  const message = functionName ? `Invalid function: ${functionName}` : error;\n  showFunctionBadge(element, message, 'error');\n}\n\n// Check if an element contains form fields\nexport function hasFormFields(element: HTMLElement): boolean {\n  const formFields = element.querySelectorAll('input, textarea, select');\n  return formFields.length > 0;\n}\n\n// Check if an element is a form field with data-gofakeit attribute\nexport function isFormField(element: HTMLElement): boolean {\n  return (\n    (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA' || element.tagName === 'SELECT') &&\n    element.hasAttribute('data-gofakeit')\n  );\n}\n\n// Extract nearby/associated label text for context\nfunction getAssociatedLabelText(input: HTMLInputElement): string {\n  const texts: string[] = [];\n  const id = input.id;\n  // aria-labelledby\n  const labelledBy = input.getAttribute('aria-labelledby');\n  if (labelledBy) {\n    labelledBy.split(/\\s+/).forEach((ref) => {\n      const el = document.getElementById(ref);\n      if (el && el.textContent) texts.push(el.textContent);\n    });\n  }\n  // explicit label[for]\n  if (id) {\n    try {\n      const lbl = document.querySelector('label[for=\"' + id.replace(/\"/g, '\\\\\"') + '\"]') as HTMLLabelElement | null;\n      if (lbl && lbl.textContent) texts.push(lbl.textContent);\n    } catch { /* ignore */ }\n  }\n  // implicit parent label\n  const closestLabel = input.closest('label');\n  if (closestLabel && closestLabel.textContent) texts.push(closestLabel.textContent);\n  // previous sibling label (common in some UIs)\n  const prev = input.previousElementSibling as HTMLElement | null;\n  if (prev && prev.tagName === 'LABEL' && prev.textContent) texts.push(prev.textContent);\n  return texts.join(' ').toLowerCase();\n}\n\n// Determine if an input type needs search API for function detection\nfunction needsSearchApi(inputType: string): boolean {\n  // These input types have their own specific handling and don't need search API\n  const skipSearchTypes = ['checkbox', 'radio', 'select', 'range', 'file', 'button', 'submit', 'reset', 'image', 'color', 'week', 'date', 'time', 'datetime-local', 'month'];\n  return !skipSearchTypes.includes(inputType);\n}\n\n// Get a default function for input types that don't need search API\nexport function getDefaultFunctionForInputType(inputType: string): string {\n  switch (inputType) {\n    case 'checkbox':\n    case 'radio':\n    case 'select':\n      return 'true';\n    case 'range':\n      return 'number?min=0&max=100';\n    case 'file':\n      return 'word';\n    case 'button':\n    case 'submit':\n    case 'reset':\n    case 'image':\n      return 'word';\n    case 'color':\n      return 'hexcolor';\n    case 'week':\n      return 'generateWeek';\n    case 'date':\n      return 'generateDate';\n    case 'time':\n      return 'generateTime';\n    case 'datetime-local':\n      return 'generateDateTime';\n    case 'month':\n      return 'generateMonth';\n    default:\n      return 'word';\n  }\n}\n\n// Get type-specific fallback functions for when search API doesn't find good matches\nfunction getTypeSpecificFallback(inputType: string): string {\n  switch (inputType) {\n    case 'email':\n      return 'email';\n    case 'tel':\n      return 'phone';\n    case 'number':\n      return 'number';\n    case 'date':\n      return 'date';\n    case 'time':\n      return 'time';\n    case 'datetime-local':\n      return 'datetime';\n    case 'month':\n      return 'month';\n    case 'week':\n      return 'week';\n    case 'url':\n      return 'url';\n    case 'password':\n      return 'password';\n    case 'search':\n      return 'word';\n    case 'color':\n      return 'color';\n    case 'text':\n    default:\n      return 'word';\n  }\n}\n\n// Create a comprehensive search query from input field characteristics\nfunction createSearchQuery(input: HTMLInputElement): string {\n  const type = input.type.toLowerCase();\n  const name = (input.name || '').toLowerCase();\n  const id = (input.id || '').toLowerCase();\n  const placeholder = (input.placeholder || '').toLowerCase();\n  const autocomplete = (input.autocomplete || '').toLowerCase();\n  const ariaLabel = (input.getAttribute('aria-label') || '').toLowerCase();\n  const labelText = getAssociatedLabelText(input);\n\n  // Build a comprehensive search query with all available information\n  const queryParts = [\n    type,\n    name,\n    id,\n    placeholder,\n    autocomplete,\n    ariaLabel,\n    labelText\n  ].filter(part => part && part.trim());\n\n  // Join all parts with spaces to create a comprehensive search query\n  const searchQuery = queryParts.join(' ').toLowerCase()\n    .replace(/[^\\w\\s]/g, ' ') // Remove special characters\n    .replace(/\\s+/g, ' ') // Normalize whitespace\n    .trim();\n\n  return searchQuery || 'text input';\n}\n\n// Search for functions using the API endpoint based on input field characteristics\nasync function searchFunctionForInput(input: HTMLInputElement): Promise<string> {\n  const type = input.type.toLowerCase();\n  \n  // Skip search API for input types that don't need it\n  if (!needsSearchApi(type)) {\n    return getDefaultFunctionForInputType(type);\n  }\n\n  const searchQuery = createSearchQuery(input);\n\n  try {\n    const searchRequest: FuncSearchRequest = {\n      id: input.id || input.name || `input_${Date.now()}`,\n      query: searchQuery\n    };\n\n    const response = await searchMultiFunc([searchRequest]);\n    \n    if (response.success && response.data && response.data.length > 0) {\n      const searchResult = response.data[0];\n      if (searchResult.results && searchResult.results.length > 0) {\n        // Return the highest scoring function\n        const bestMatch = searchResult.results[0];\n        return bestMatch.name;\n      }\n    }\n  } catch (error) {\n    console.warn('[Gofakeit] Function search failed, falling back to default function:', error);\n  }\n\n  // Fallback to default function if search fails\n  return getDefaultFunctionForInputType(type);\n}\n\n// Search for functions for multiple inputs using the API endpoint\nexport async function searchFunctionsForInputs(inputs: HTMLInputElement[]): Promise<Map<HTMLInputElement, string>> {\n  const functionMap = new Map<HTMLInputElement, string>();\n  \n  if (inputs.length === 0) {\n    return functionMap;\n  }\n\n  try {\n    // Create search requests for all inputs using the shared createSearchQuery function\n    const searchRequests: FuncSearchRequest[] = inputs.map((input, index) => {\n      const searchQuery = createSearchQuery(input);\n      \n      return {\n        id: input.id || input.name || `input_${index}`,\n        query: searchQuery\n      };\n    });\n\n    const response = await searchMultiFunc(searchRequests);\n    \n    if (response.success && response.data) {\n      // Map results back to inputs with improved fallback logic\n      for (let i = 0; i < response.data.length; i++) {\n        const searchResult = response.data[i];\n        const input = inputs[i];\n        const inputType = input.type.toLowerCase();\n        \n        if (searchResult.results && searchResult.results.length > 0) {\n          const bestMatch = searchResult.results[0];\n          // Only use the search result if it has a reasonable score\n          if (bestMatch.score >= 100) {\n            functionMap.set(input, bestMatch.name);\n          } else {\n            // Use type-specific fallback for low-scoring results\n            functionMap.set(input, getTypeSpecificFallback(inputType));\n          }\n        } else {\n          // Fallback to type-specific function if no search results\n          functionMap.set(input, getTypeSpecificFallback(inputType));\n        }\n      }\n    } else {\n      // Fallback to default functions for all inputs if search fails\n      for (const input of inputs) {\n        functionMap.set(input, getDefaultFunctionForInputType(input.type.toLowerCase()));\n      }\n    }\n  } catch (error) {\n    console.warn('[Gofakeit] Multi-function search failed, falling back to default functions:', error);\n    // Fallback to default functions for all inputs\n    for (const input of inputs) {\n      functionMap.set(input, getDefaultFunctionForInputType(input.type.toLowerCase()));\n    }\n  }\n\n  return functionMap;\n}\n\n// Find the closest container that has form fields with data-gofakeit attributes\nexport function findFormContainer(element: HTMLElement): HTMLElement | null {\n  // Check if the current element has form fields\n  if (hasFormFields(element)) {\n    return element;\n  }\n  \n  // Check parent elements\n  let parent = element.parentElement;\n  while (parent) {\n    if (hasFormFields(parent)) {\n      return parent;\n    }\n    parent = parent.parentElement;\n  }\n  \n  return null;\n}\n\n// Simple notification function (can be overridden by the consuming application)\nfunction showNotification(message: string, type: 'success' | 'error' | 'info' = 'info'): void {\n  console.log(`[Gofakeit ${type.toUpperCase()}] ${message}`);\n}\n\n// ============================================================================\n// BADGE FUNCTIONALITY\n// ============================================================================\n\n// Global tracking of active function badges\nconst activeBadges = new Map<\n  Element,\n  {\n    badge: HTMLElement;\n    timeout: ReturnType<typeof setTimeout>;\n    cleanup: () => void;\n  }\n>();\n\n// Display a small badge showing the function used for this field\nexport function showFunctionBadge(\n  element: Element,\n  funcName: string,\n  status: \"success\" | \"error\" = \"success\"\n): void {\n  if (!(element instanceof HTMLElement)) return;\n\n  // Remove any existing badges for this element\n  removeExistingBadges(element);\n\n  const badge = document.createElement(\"div\");\n  badge.textContent = funcName;\n  badge.style.position = \"fixed\";\n  badge.style.fontFamily = \"Arial, sans-serif\";\n  badge.style.fontSize = \"11px\";\n  badge.style.padding = \"3px 8px\";\n  badge.style.borderRadius = \"6px\";\n  badge.style.boxShadow = \"0 2px 6px rgba(0,0,0,0.25)\";\n  badge.style.zIndex = \"2147483647\";\n  badge.style.opacity = \"0\";\n  badge.style.transform = \"translateY(-6px)\";\n  badge.style.transition = \"opacity 200ms ease, transform 200ms ease\";\n  badge.style.pointerEvents = \"none\";\n\n  // Apply styling based on status\n  if (status === \"error\") {\n    badge.style.background = GOFAKEIT_COLORS.error;\n    badge.style.color = \"#fff\";\n    badge.style.border = `1px solid ${GOFAKEIT_COLORS.error}`;\n  } else {\n    badge.style.background = GOFAKEIT_COLORS.primary;\n    badge.style.color = \"#000\";\n  }\n\n  const updatePosition = () => {\n    const rect = element.getBoundingClientRect();\n    const vh = window.innerHeight || document.documentElement.clientHeight;\n    const vw = window.innerWidth || document.documentElement.clientWidth;\n\n    // If the element is completely out of the viewport, hide the badge entirely\n    const outOfView =\n      rect.bottom <= 0 || rect.top >= vh || rect.right <= 0 || rect.left >= vw;\n    if (outOfView) {\n      badge.style.display = \"none\";\n      return;\n    }\n\n    // Otherwise, ensure it's visible and position above-left of the field\n    if (badge.style.display === \"none\") badge.style.display = \"block\";\n    const top = rect.top - 8;\n    const left = rect.left;\n    badge.style.top = `${top}px`;\n    badge.style.left = `${left}px`;\n  };\n\n  document.body.appendChild(badge);\n  updatePosition();\n\n  // Animate in\n  requestAnimationFrame(() => {\n    badge.style.opacity = \"1\";\n    badge.style.transform = \"translateY(-12px)\";\n  });\n\n  // Track movement while visible\n  const onScroll = () => updatePosition();\n  const onResize = () => updatePosition();\n  window.addEventListener(\"scroll\", onScroll, true);\n  window.addEventListener(\"resize\", onResize, true);\n\n  // Observe element size/position changes\n  let ro: ResizeObserver | null = null;\n  if (typeof ResizeObserver !== \"undefined\") {\n    ro = new ResizeObserver(() => updatePosition());\n    try {\n      ro.observe(element);\n    } catch {\n      /* ignore */\n    }\n  }\n\n  // Create cleanup function\n  const cleanup = () => {\n    window.removeEventListener(\"scroll\", onScroll, true);\n    window.removeEventListener(\"resize\", onResize, true);\n    if (ro) {\n      try {\n        ro.disconnect();\n      } catch {\n        /* ignore */\n      }\n      ro = null;\n    }\n    if (badge.parentNode) badge.parentNode.removeChild(badge);\n    activeBadges.delete(element);\n  };\n\n  // Animate out and remove after extended delay\n  const DISPLAY_MS = 6000;\n  const timeout = setTimeout(() => {\n    badge.style.opacity = \"0\";\n    badge.style.transform = \"translateY(-6px)\";\n    setTimeout(cleanup, 220);\n  }, DISPLAY_MS);\n\n  // Track this badge\n  activeBadges.set(element, { badge, timeout, cleanup });\n}\n\n// Remove existing badges for a specific element\nfunction removeExistingBadges(element: Element): void {\n  // For radio buttons, remove badges for all radio buttons in the same group\n  if (\n    element instanceof HTMLInputElement &&\n    element.type === \"radio\" &&\n    element.name\n  ) {\n    const radioGroup = document.querySelectorAll(\n      `input[type=\"radio\"][name=\"${element.name}\"]`\n    );\n    radioGroup.forEach((radio) => {\n      const existing = activeBadges.get(radio);\n      if (existing) {\n        clearTimeout(existing.timeout);\n        existing.cleanup();\n        activeBadges.delete(radio);\n      }\n    });\n  } else {\n    // For other elements, just remove the badge for this specific element\n    const existing = activeBadges.get(element);\n    if (existing) {\n      clearTimeout(existing.timeout);\n      existing.cleanup();\n      activeBadges.delete(element);\n    }\n  }\n}","\n      import { autofill } from \"./src/index.ts\";\n\n      // Make functions available globally\n      window.autofill = async (target) => {\n        try {\n          // Get current settings\n          const settings = getCurrentSettings();\n\n          if (target) {\n            // If target is a string, treat it as a CSS selector (ID, class, or other)\n            if (typeof target === \"string\") {\n              // Scroll to the section first\n              const element = document.querySelector(target);\n              if (element) {\n                element.scrollIntoView({ behavior: \"smooth\", block: \"start\" });\n                \n                // Wait a moment for the scroll to complete, then autofill\n                setTimeout(async () => {\n                  await autofill(target, settings);\n                  showStatus(\n                    ` ${target} section filled successfully!`,\n                    \"success\"\n                  );\n                }, 500);\n              } else {\n                showStatus(\" Element not found: \" + target, \"error\");\n              }\n            } else {\n              await autofill(target, settings);\n              showStatus(\" Element filled successfully!\", \"success\");\n            }\n          } else {\n            // No target - autofill all\n            await autofill(undefined, settings);\n            showStatus(\" All fields filled successfully!\", \"success\");\n          }\n        } catch (error) {\n          showStatus(\" Error filling fields: \" + error.message, \"error\");\n        }\n      };\n\n      // Function to handle category selection from dropdown\n      window.handleCategorySelection = async () => {\n        const selector = document.getElementById(\"categorySelector\");\n        const selectedCategory = selector.value;\n\n        if (!selectedCategory) {\n          return;\n        }\n\n        try {\n          // Map category values to their heading text\n          const categoryHeadingMap = {\n            \"person-category\": \" Person Category\",\n            \"address-category\": \" Address Category\",\n            \"company-category\": \" Company Category\",\n            \"payment-category\": \" Payment Category\",\n            \"internet-category\": \" Internet Category\",\n            \"time-category\": \" Time Category\",\n            \"language-category\": \" Language Category\",\n            \"word-category\": \" Word Category\",\n            \"color-category\": \" Color Category\",\n            \"animal-category\": \" Animal Category\",\n            \"food-category\": \" Food Category\",\n            \"car-category\": \" Car Category\",\n            \"game-category\": \" Game Category\",\n            \"misc-category\": \" Misc Category\",\n          };\n\n          // Find the specific category heading by text content\n          const headingText = categoryHeadingMap[selectedCategory];\n          let categoryHeading = null;\n          if (headingText) {\n            const allHeadings = document.querySelectorAll(\"h4\");\n            for (const heading of allHeadings) {\n              if (heading.textContent?.includes(headingText)) {\n                categoryHeading = heading;\n                break;\n              }\n            }\n          }\n\n          if (categoryHeading) {\n            categoryHeading.scrollIntoView({\n              behavior: \"smooth\",\n              block: \"start\",\n            });\n          } else {\n            // Fallback: scroll to the categories section\n            const section = document.getElementById(\"categories\");\n            if (section) {\n              section.scrollIntoView({ behavior: \"smooth\", block: \"start\" });\n            }\n          }\n\n          // Wait a moment for the scroll to complete, then autofill the specific fields\n          setTimeout(async () => {\n            // Find the category container\n            const categoryContainer = document.getElementById(selectedCategory);\n            if (!categoryContainer) {\n              showStatus(\" Category container not found!\", \"error\");\n              return;\n            }\n\n            try {\n              // Get current settings\n              const settings = getCurrentSettings();\n\n              // Use the main autofill function with the category container\n              await autofill(categoryContainer, settings);\n\n              // Count filled elements\n              let filledCount = 0;\n              const inputs = categoryContainer.querySelectorAll(\n                \"input, textarea, select\"\n              );\n              inputs.forEach((element) => {\n                if (element instanceof HTMLInputElement) {\n                  if (element.type === \"checkbox\" || element.type === \"radio\") {\n                    if (element.checked) filledCount++;\n                  } else if (element.value) {\n                    filledCount++;\n                  }\n                } else if (\n                  element instanceof HTMLTextAreaElement ||\n                  element instanceof HTMLSelectElement\n                ) {\n                  if (element.value) filledCount++;\n                }\n              });\n\n              const categoryName = selector.options[selector.selectedIndex].text;\n              showStatus(\n                ` ${categoryName} filled successfully! (${filledCount} fields)`,\n                \"success\"\n              );\n            } catch (error) {\n              console.warn(\"Failed to fill category:\", error);\n              showStatus(\n                \" Error filling category: \" + error.message,\n                \"error\"\n              );\n            }\n\n            // Reset the dropdown\n            selector.value = \"\";\n          }, 500);\n        } catch (error) {\n          showStatus(\" Error filling category: \" + error.message, \"error\");\n          // Reset the dropdown even on error\n          selector.value = \"\";\n        }\n      };\n\n      // Function to get current settings from the UI controls\n      function getCurrentSettings() {\n        const smartMode = document.getElementById(\"smartMode\").checked;\n        const staggeredMode = document.getElementById(\"staggeredMode\").checked;\n        const staggerDelay = parseInt(\n          document.getElementById(\"staggerDelay\").value\n        );\n\n        return {\n          smart: smartMode,\n          staggered: staggeredMode,\n          staggerDelay: staggerDelay,\n        };\n      }\n\n      // Function to autofill with current settings\n      window.autofillWithCurrentSettings = async () => {\n        try {\n          const settings = getCurrentSettings();\n          await autofill(undefined, settings);\n\n          const modeText = settings.smart ? \"Smart Mode\" : \"Manual Mode\";\n          const staggerText = settings.staggered\n            ? ` (${settings.staggerDelay}ms delay)`\n            : \" (no stagger)\";\n          showStatus(\n            ` All fields filled with ${modeText}${staggerText}!`,\n            \"success\"\n          );\n        } catch (error) {\n          showStatus(\" Error filling fields: \" + error.message, \"error\");\n        }\n      };\n\n      // Update stagger delay value display and handle theme toggle\n      document.addEventListener(\"DOMContentLoaded\", function () {\n        const staggerDelay = document.getElementById(\"staggerDelay\");\n        const staggerDelayValue = document.getElementById(\"staggerDelayValue\");\n        const themeToggle = document.getElementById(\"themeToggle\");\n        const themeIcon = themeToggle.querySelector(\".theme-icon\");\n\n        if (staggerDelay && staggerDelayValue) {\n          staggerDelay.addEventListener(\"input\", function () {\n            staggerDelayValue.textContent = this.value;\n          });\n        }\n\n        // Handle theme toggle\n        if (themeToggle) {\n          // Get user's saved preference or system preference\n          const savedTheme = localStorage.getItem(\"theme\");\n          const systemPrefersDark = window.matchMedia(\n            \"(prefers-color-scheme: dark)\"\n          ).matches;\n\n          // Use saved preference if available, otherwise use system preference\n          const shouldUseDark =\n            savedTheme === \"dark\" || (savedTheme === null && systemPrefersDark);\n\n          if (shouldUseDark) {\n            document.documentElement.setAttribute(\"data-theme\", \"dark\");\n            themeIcon.textContent = \"\";\n          } else {\n            themeIcon.textContent = \"\";\n          }\n\n          themeToggle.addEventListener(\"click\", function () {\n            const isDark = document.documentElement.hasAttribute(\"data-theme\");\n\n            if (isDark) {\n              // Switch to light mode\n              document.documentElement.removeAttribute(\"data-theme\");\n              localStorage.setItem(\"theme\", \"light\");\n              themeIcon.textContent = \"\";\n            } else {\n              // Switch to dark mode\n              document.documentElement.setAttribute(\"data-theme\", \"dark\");\n              localStorage.setItem(\"theme\", \"dark\");\n              themeIcon.textContent = \"\";\n            }\n          });\n\n          // Listen for system preference changes\n          window\n            .matchMedia(\"(prefers-color-scheme: dark)\")\n            .addEventListener(\"change\", function (e) {\n              // Only update if user hasn't set a preference\n              if (localStorage.getItem(\"theme\") === null) {\n                if (e.matches) {\n                  document.documentElement.setAttribute(\"data-theme\", \"dark\");\n                  themeIcon.textContent = \"\";\n                } else {\n                  document.documentElement.removeAttribute(\"data-theme\");\n                  themeIcon.textContent = \"\";\n                }\n              }\n            });\n        }\n      });\n\n      window.clearAll = () => {\n        // only search in main content container, not sidebar\n        const mainContent = document.querySelector(\".main-content\");\n        if (!mainContent) return;\n        \n        const inputs = mainContent.querySelectorAll(\"input, textarea, select\");\n        inputs.forEach((input) => {\n          if (input.type === \"checkbox\" || input.type === \"radio\") {\n            input.checked = false;\n          } else {\n            input.value = \"\";\n          }\n        });\n        showStatus(\" All fields cleared!\", \"success\");\n      };\n\n      function showStatus(message, type) {\n        const status = document.getElementById(\"status\");\n        status.textContent = message;\n        status.style.display = \"block\";\n        status.className = `status ${type} show`;\n\n        setTimeout(() => {\n          status.classList.remove(\"show\");\n          // Hide the status element completely after animation\n          setTimeout(() => {\n            status.style.display = \"none\";\n          }, 300);\n        }, 3000);\n      }\n\n      // Initialize the page\n      console.log(\" Gofakeit Autofill Comprehensive Testing loaded!\");\n      console.log(\n        \"This page tests the search API with various input contexts and categories.\"\n      );\n      console.log(\n        \"Check the browser network tab to see search API calls in action!\"\n      );\n    "],"names":["GOFAKEIT_COLORS","GOFAKEIT_API_BASE","callFunc","func","questionMarkIndex","functionName","queryString","params","searchParams","key","value","numValue","makeRequest","callMultiFunc","requests","processedRequests","req","index","id","makeMultiRequest","searchMultiFunc","makeSearchRequest","method","url","body","options","response","error","getDateTimeInput","element","gofakeitFunc","inputType","setDateTimeInput","generateTime","hour","minute","generateMonth","year","month","generateDate","day","generateDateTime","generateWeek","weekYearResponse","weekResponse","week","getISOWeek","date","d","week1","handleDateTimeInput","functionToCall","finalValue","handleError","fallbackFunc","getDefaultFunctionForInputType","fallbackResponse","dateMatch","datetimeMatch","getTextInput","setTextInput","handleTextInput","getTextarea","setTextarea","handleTextarea","handleCheckbox","checkboxGroup","findCheckboxGroup","cb","numToSelect","selectedIndices","i","boolResponse","availableIndices","_","randomIndex","values","v","shouldCheck","handleRadio","radioGroup","findRadioGroup","rb","selectedRadio","name","container","handleSelectWithFunction","option","val","opt","validOptions","randomOption","selectedValues","remainingOptions","getNumberInput","setNumberInput","handleNumberInput","getRangeInput","min","max","setRangeInput","clampedValue","handleRangeInput","autofill","target","settings","finalSettings","autofillAll","showNotification","hasFormFields","autofillContainer","success","autofillElement","findFormContainer","elements","queryFormElements","smartMode","targets","el","isDataGofakeitFalse","results","processElements","showResults","funcToUse","usedFunc","showBadgeWithTiming","passToHandler","selectedElement","inferred","searchFunctionForInput","selector","nodeList","getUniqueElements","uniqueElements","processedGroups","successfulCount","failedCount","searchInputElements","otherElements","hasSpecificFunction","needsSearchApi","inputFunctionMap","searchFunctionsForInputs","getElementFunction","excludedElements","batchElements","staggerDelay","resolve","promises","item","batchResponse","staggered","showFunctionBadge","autofillElementWithValue","context","message","getAssociatedLabelText","input","texts","labelledBy","ref","lbl","closestLabel","prev","getTypeSpecificFallback","createSearchQuery","type","placeholder","autocomplete","ariaLabel","labelText","part","searchQuery","searchRequest","searchResult","inputs","functionMap","searchRequests","bestMatch","parent","activeBadges","funcName","status","removeExistingBadges","badge","updatePosition","rect","vh","vw","top","left","onScroll","onResize","ro","cleanup","timeout","radio","existing","getCurrentSettings","showStatus","selectedCategory","headingText","categoryHeading","allHeadings","heading","section","categoryContainer","filledCount","categoryName","staggeredMode","modeText","staggerText","staggerDelayValue","themeToggle","themeIcon","savedTheme","systemPrefersDark","e","mainContent"],"mappings":"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"}