{"version":3,"file":"index.cjs","sources":["../src/api.ts","../src/styles.ts","../src/autofill.ts","../index.html?html-proxy&index=1.js"],"sourcesContent":["// Base URL for the Gofakeit API\nconst GOFAKEIT_API_BASE = 'https://api.gofakeit.com/funcs';\n\n// Interface for function parameters\nexport interface FetchFuncParams {\n  [key: string]: string | number | boolean | string[];\n}\n\nexport interface FetchFuncResponse {\n  success: boolean;\n  data?: string;\n  error?: string;\n  status?: number;\n}\n\n// Multi-function request interface\nexport interface FetchFuncMultiRequest {\n  id?: string;\n  func: string;\n  params?: FetchFuncParams;\n}\n\n// Multi-function response item interface\nexport interface FetchFuncMultiResponseItem {\n  id?: string;\n  value: string | number | boolean | null;\n  error?: string;\n}\n\n// Multi-function response interface\nexport interface FetchFuncMultiResponse {\n  success: boolean;\n  data?: FetchFuncMultiResponseItem[];\n  error?: string;\n  status?: number;\n}\n\n// Function search request interface\nexport interface FetchFuncSearchRequest {\n  id: string;\n  query: string;\n}\n\n// Function search result interface\nexport interface FetchFuncSearchResult {\n  name: string; // function name for API usage\n  score: number; // relevance score (0-100)\n  reasons: string[]; // why it matched\n}\n\n// Function search response item interface\nexport interface FetchFuncSearchResponseItem {\n  id: string;\n  query: string;\n  results: FetchFuncSearchResult[];\n}\n\n// Multi-function search response interface\nexport interface FetchFuncSearchResponse {\n  success: boolean;\n  data?: FetchFuncSearchResponseItem[];\n  error?: string;\n  status?: number;\n}\n\n// Fetch data from gofakeit API\nexport async function fetchFunc(\n  func: string,\n  params?: FetchFuncParams\n): Promise<FetchFuncResponse> {\n  const { func: funcName, params: extractedParams } = parseFunctionString(func);\n\n  // Merge extracted params with provided params (provided params take precedence)\n  const finalParams = { ...extractedParams, ...(params || {}) };\n\n  // Always use POST request\n  return makeRequest('POST', `${GOFAKEIT_API_BASE}/${funcName}`, finalParams);\n}\n\n// Call multiple functions in a single request\nexport async function fetchFuncMulti(\n  requests: FetchFuncMultiRequest[]\n): Promise<FetchFuncMultiResponse> {\n  if (requests.length === 0) {\n    return {\n      success: false,\n      error: 'No functions provided',\n    };\n  }\n\n  // Process each request to extract function name and parameters\n  const processedRequests: FetchFuncMultiRequest[] = requests.map(\n    (req, index) => {\n      const { func, id, params } = req;\n      const { func: funcName, params: extractedParams } =\n        parseFunctionString(func);\n\n      // Merge extracted params with provided params (provided params take precedence)\n      const finalParams = { ...extractedParams, ...(params || {}) };\n\n      return {\n        id: id || `req_${index}`,\n        func: funcName,\n        params: finalParams,\n      };\n    }\n  );\n\n  return makeRequest<FetchFuncMultiResponse>(\n    'POST',\n    `${GOFAKEIT_API_BASE}/multi`,\n    processedRequests\n  );\n}\n\n// Search for multiple functions in a single request\nexport async function fetchFuncSearch(\n  requests: FetchFuncSearchRequest[]\n): Promise<FetchFuncSearchResponse> {\n  if (requests.length === 0) {\n    return {\n      success: false,\n      error: 'No search queries provided',\n    };\n  }\n\n  return makeRequest<FetchFuncSearchResponse>(\n    'POST',\n    `${GOFAKEIT_API_BASE}/search`,\n    requests\n  );\n}\n\n// Base HTTP request function\n// Unified HTTP request function for all API calls\nasync function makeRequest<T>(\n  method: 'GET' | 'POST',\n  url: string,\n  body?: FetchFuncParams | FetchFuncMultiRequest[] | FetchFuncSearchRequest[]\n): Promise<T> {\n  try {\n    const options: {\n      method: string;\n      headers: Record<string, string>;\n      body?: string;\n    } = {\n      method: method,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    };\n\n    if (method === 'POST' && body) {\n      options.body = JSON.stringify(body);\n    }\n\n    const response = await fetch(url, options);\n\n    if (!response.ok) {\n      return {\n        success: false,\n        error: `HTTP error! status: ${response.status}`,\n        status: response.status,\n      } as T;\n    }\n\n    // Determine response parsing based on URL\n    let data;\n    if (url.includes('/multi') || url.includes('/search')) {\n      data = await response.json();\n    } else {\n      data = await response.text();\n    }\n\n    return {\n      success: true,\n      data: data,\n    } as T;\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    } as T;\n  }\n}\n\n// Parse function string to extract function name and parameters\nexport function parseFunctionString(func: string): {\n  func: string;\n  params: FetchFuncParams;\n} {\n  const questionMarkIndex = func.indexOf('?');\n\n  if (questionMarkIndex !== -1) {\n    // Function has query parameters - extract them\n    const functionName = func.substring(0, questionMarkIndex);\n    const queryString = func.substring(questionMarkIndex + 1);\n\n    // Parse query parameters into an object\n    const params: FetchFuncParams = {};\n    const searchParams = new URLSearchParams(queryString);\n\n    for (const [key, value] of searchParams.entries()) {\n      // Try to parse as number if possible\n      const numValue = parseFloat(value);\n      params[key] = isNaN(numValue) ? value : numValue;\n    }\n\n    return { func: functionName, params };\n  } else {\n    // Simple function with no parameters\n    return { func: func, params: {} };\n  }\n}\n","// Centralized style tokens for injected UI (avoid dependency on site CSS)\n\nexport const GOFAKEIT_COLORS = {\n  primary: '#ffa000',\n  white: '#ffffff',\n  success: '#48c774',\n  error: '#ff3860',\n  info: '#209cee',\n  text: '#333333',\n  border: '#686868',\n  background: '#22272e',\n};\n\nexport const GOFAKEIT_SPACING = {\n  base: 16, // px\n  half: 8, // px\n  quarter: 4, // px\n};\n\nexport const GOFAKEIT_BORDER = {\n  radius: 4, // px\n  width: 2, // px\n};\n\nexport const GOFAKEIT_FONT = {\n  size: 12, // px\n  family: 'Helvetica, Arial, sans-serif',\n};\n","import {\n  fetchFuncMulti,\n  FetchFuncMultiRequest,\n  fetchFuncSearch,\n  FetchFuncSearchRequest,\n  FetchFuncParams,\n} from './api';\nimport {\n  GOFAKEIT_COLORS,\n  GOFAKEIT_SPACING,\n  GOFAKEIT_BORDER,\n  GOFAKEIT_FONT,\n} from './styles';\n\nexport enum AutofillStatus {\n  IDLE = 'idle',\n  STARTING = 'starting',\n  INITIALIZING = 'initializing',\n  DETERMINING_FUNCTIONS = 'determining_functions',\n  GETTING_VALUES = 'getting_values',\n  SETTING_VALUES = 'setting_values',\n  COMPLETED = 'completed',\n  ERROR = 'error',\n}\n\nexport interface AutofillSettings {\n  mode?: 'auto' | 'manual';\n  stagger?: number;\n  badges?: number;\n  debug?: boolean;\n\n  // Callbacks\n  onStatusChange?: (status: AutofillStatus, state: AutofillState) => void;\n}\n\nexport interface AutofillState {\n  status: AutofillStatus;\n  elements: AutofillElement[];\n}\n\nexport interface AutofillElement {\n  id: string; // id of the element\n  name: string; // name of the element\n  element: Element; // element to autofill\n  type: string; // element type\n  function: string; // function that will be used to autofill the element\n  search: string; // search query that will be used to autofill the element\n  value: string; // value of the autofill result\n  error: string; // error message\n}\n\nexport interface AutofillResult {\n  elements: AutofillElement[];\n  error?: string;\n}\n\nexport interface Results {\n  success: number;\n  failed: number;\n  elements: AutofillElement[];\n}\n\nexport class Autofill {\n  public settings: AutofillSettings;\n  public state: AutofillState;\n\n  constructor(settings: AutofillSettings = {}) {\n    this.settings = {\n      mode: 'auto',\n      stagger: 50,\n      badges: 3000,\n      debug: false,\n      ...settings,\n    };\n\n    this.state = {\n      status: AutofillStatus.IDLE,\n      elements: [],\n    };\n  }\n\n  // ============================================================================\n  // MAIN FILL FUNCTION\n  // ============================================================================\n\n  async fill(target?: HTMLElement | Element | string): Promise<Results> {\n    this.updateStatus(AutofillStatus.STARTING);\n    this.state.elements = []; // Clear previous elements\n\n    // Step 1: Set all target elements based on the target parameter\n    this.setElements(target);\n\n    if (this.state.elements.length === 0) {\n      this.debug('info', 'No form fields found to fill');\n      // Only set to idle if we're not already in error state\n      if (this.state.status !== AutofillStatus.ERROR) {\n        this.updateStatus(AutofillStatus.IDLE);\n      }\n      return this.results();\n    }\n\n    // Step 2: Determine functions for elements that need search\n    await this.setElementFunctions();\n    this.updateStatus(AutofillStatus.DETERMINING_FUNCTIONS);\n\n    // Step 3: Get values for all elements via multi-function API\n    await this.getElementValues();\n    this.updateStatus(AutofillStatus.GETTING_VALUES);\n\n    // Step 4: set values to the actual form elements\n    await this.setElementValues();\n    this.updateStatus(AutofillStatus.SETTING_VALUES);\n\n    // Return the results\n    this.updateStatus(AutofillStatus.COMPLETED);\n    return this.results();\n  }\n\n  // ============================================================================\n  // Step 1: Set all target elements based on the target parameter\n  // ============================================================================\n\n  // Public method to set form elements based on target parameter\n  public setElements(target?: HTMLElement | Element | string): void {\n    const allFormElements: Element[] = [];\n\n    if (target) {\n      if (typeof target === 'string') {\n        // For string selectors, get the matching elements and search within them\n        const elements = document.querySelectorAll(target);\n        if (elements.length === 0) {\n          this.debug('error', `No element found with selector: \"${target}\"`);\n          this.updateStatus(AutofillStatus.ERROR);\n          this.state.elements = [];\n          return;\n        }\n        // Search within each matching element for form elements\n        elements.forEach(el => {\n          if (\n            el instanceof HTMLInputElement ||\n            el instanceof HTMLTextAreaElement ||\n            el instanceof HTMLSelectElement\n          ) {\n            // If the element itself is a form element, add it\n            if (this.shouldSkipElement(el)) return;\n            allFormElements.push(el);\n          } else {\n            // If it's not a form element, search within it for form elements\n            const selector = 'input, textarea, select';\n            const nodeList = el.querySelectorAll(selector);\n\n            nodeList.forEach(formEl => {\n              // Skip hidden, disabled, or readonly elements\n              if (this.shouldSkipElement(formEl)) return;\n              allFormElements.push(formEl);\n            });\n          }\n        });\n      } else if (target instanceof HTMLElement || target instanceof Element) {\n        // For element targets, check if the element itself is a form element\n        if (\n          target instanceof HTMLInputElement ||\n          target instanceof HTMLTextAreaElement ||\n          target instanceof HTMLSelectElement\n        ) {\n          // Skip hidden, disabled, or readonly elements\n          if (this.shouldSkipElement(target)) {\n            this.state.elements = [];\n            return;\n          }\n          allFormElements.push(target);\n        } else {\n          // If it's not a form element, search within it\n          const selector = 'input, textarea, select';\n          const nodeList = target.querySelectorAll(selector);\n\n          nodeList.forEach(el => {\n            // Skip hidden, disabled, or readonly elements\n            if (this.shouldSkipElement(el)) return;\n            allFormElements.push(el);\n          });\n        }\n      }\n    } else {\n      // No target specified, search the entire document\n      const selector = 'input, textarea, select';\n      const nodeList = document.querySelectorAll(selector);\n\n      nodeList.forEach(el => {\n        // Skip hidden, disabled, or readonly elements\n        if (this.shouldSkipElement(el)) return;\n        allFormElements.push(el);\n      });\n    }\n\n    // Step 3: Filter elements based on mode and data-gofakeit attributes\n    const mode = this.settings.mode ?? 'auto';\n    const filteredElements: Element[] = [];\n\n    for (const element of allFormElements) {\n      const gofakeitFunc = element.getAttribute('data-gofakeit');\n\n      // Skip if explicitly disabled\n      if (\n        typeof gofakeitFunc === 'string' &&\n        gofakeitFunc.trim().toLowerCase() === 'false'\n      ) {\n        continue;\n      }\n\n      // In manual mode, only include elements with data-gofakeit attribute\n      if (mode === 'manual' && !gofakeitFunc) {\n        continue;\n      }\n\n      // In auto mode, include all elements (with or without data-gofakeit)\n      filteredElements.push(element);\n    }\n\n    // Loop through filteredElements and create AutofillElement objects\n    const autofillElements: AutofillElement[] = [];\n    for (const element of filteredElements) {\n      // random 8 digit alphanumeric string\n      const id =\n        Math.random().toString(36).substring(2, 15) +\n        Math.random().toString(36).substring(2, 15);\n\n      // add new element to the autofillElements array\n      autofillElements.push({\n        id: id,\n        name: element.getAttribute('name') || '',\n        element,\n        type: this.getElementType(element),\n        function: '',\n        search: this.getElementSearch(element as HTMLInputElement),\n        value: '',\n        error: '',\n      });\n    }\n\n    this.state.elements = autofillElements;\n\n    // Debug output for element selection\n    if (autofillElements.length > 0) {\n      this.debug(\n        'info',\n        `Found ${autofillElements.length} elements to generate data for`\n      );\n    }\n  }\n\n  // Check if an element should be skipped (hidden, disabled, or readonly)\n  public shouldSkipElement(element: Element): boolean {\n    if (element instanceof HTMLInputElement) {\n      return element.type === 'hidden' || element.disabled || element.readOnly;\n    } else if (element instanceof HTMLTextAreaElement) {\n      return element.disabled || element.readOnly;\n    } else if (element instanceof HTMLSelectElement) {\n      return element.disabled;\n    }\n    return false;\n  }\n\n  // Get the element type\n  private getElementType(element: Element): string {\n    if (element instanceof HTMLInputElement) {\n      return element.type.toLowerCase();\n    } else if (element instanceof HTMLTextAreaElement) {\n      return 'textarea';\n    } else if (element instanceof HTMLSelectElement) {\n      return 'select';\n    }\n    return 'unknown';\n  }\n\n  // Get the comprehensive search string for an element\n  public getElementSearch(el: Element): string {\n    // Get label text from various sources\n    const labelTexts: string[] = [];\n    const id = el.id;\n\n    // aria-labelledby\n    const labelledBy = el.getAttribute('aria-labelledby');\n    if (labelledBy) {\n      labelledBy.split(/\\s+/).forEach(ref => {\n        const labelEl = document.getElementById(ref);\n        if (labelEl && labelEl.textContent)\n          labelTexts.push(labelEl.textContent);\n      });\n    }\n\n    // explicit label[for]\n    if (id) {\n      const lbl = document.querySelector(\n        'label[for=\"' + id.replace(/\"/g, '\\\\\"') + '\"]'\n      ) as HTMLLabelElement | null;\n      if (lbl && lbl.textContent) labelTexts.push(lbl.textContent);\n    }\n\n    // implicit parent label\n    const closestLabel = el.closest('label');\n    if (closestLabel && closestLabel.textContent)\n      labelTexts.push(closestLabel.textContent);\n\n    // previous sibling label (common in some UIs)\n    const prev = el.previousElementSibling as HTMLElement | null;\n    if (prev && prev.tagName === 'LABEL' && prev.textContent)\n      labelTexts.push(prev.textContent);\n\n    const labelText = labelTexts.join(' ').toLowerCase();\n\n    // Get additional element attributes for comprehensive search\n    const type = el instanceof HTMLInputElement ? el.type.toLowerCase() : '';\n    const name = (el.getAttribute('name') || '').toLowerCase();\n    const elementId = (el.id || '').toLowerCase();\n    const placeholder =\n      el instanceof HTMLInputElement\n        ? (el.placeholder || '').toLowerCase()\n        : '';\n    const autocomplete =\n      el instanceof HTMLInputElement\n        ? (el.autocomplete || '').toLowerCase()\n        : '';\n    const ariaLabel = (el.getAttribute('aria-label') || '').toLowerCase();\n\n    // Build a comprehensive search query with all available information\n    const queryParts = [\n      type,\n      name,\n      elementId,\n      placeholder,\n      autocomplete,\n      ariaLabel,\n      labelText,\n    ].filter(part => part && part.trim());\n\n    // Join all parts with spaces to create a comprehensive search query\n    const searchQuery = queryParts\n      .join(' ')\n      .toLowerCase()\n      .replace(/[^\\w\\s]/g, ' ') // Remove special characters\n      .replace(/\\s+/g, ' ') // Normalize whitespace\n      .trim();\n\n    return searchQuery;\n  }\n\n  // ============================================================================\n  // Step 2: Determine functions for elements that need search\n  // ============================================================================\n\n  public async setElementFunctions(): Promise<void> {\n    this.debug(\n      'info',\n      `Determining functions for ${this.state.elements.length} elements`\n    );\n\n    // Step 1: Loop through elements and set functions for types that don't need search\n    const elementsNeedingSearch: AutofillElement[] = [];\n\n    for (const el of this.state.elements) {\n      const functionName = this.getElementFunction(el.element);\n\n      if (functionName !== null) {\n        // Function determined - use it directly\n        el.function = functionName;\n      } else {\n        // Function needs search - add to search array\n        elementsNeedingSearch.push(el);\n      }\n    }\n\n    // Step 2: Handle elements that need search\n    if (elementsNeedingSearch.length > 0) {\n      this.debug(\n        'info',\n        `${elementsNeedingSearch.length} elements need function search`\n      );\n\n      // Create search requests using existing search values from state\n      const searchRequests: FetchFuncSearchRequest[] =\n        elementsNeedingSearch.map((el, index) => {\n          return {\n            id:\n              el.element.id ||\n              el.element.getAttribute('name') ||\n              `input_${index}`,\n            query: el.search,\n          };\n        });\n\n      const response = await fetchFuncSearch(searchRequests);\n\n      if (response.success && response.data) {\n        // Map results back to elements - use first result regardless of score\n        for (let i = 0; i < response.data.length; i++) {\n          const searchResult = response.data[i];\n          const el = elementsNeedingSearch[i];\n\n          if (searchResult.results && searchResult.results.length > 0) {\n            // Use the first result, not based on score\n            el.function = searchResult.results[0].name;\n          } else {\n            // Fallback to type-specific function if no search results\n            el.function = this.getElementFunctionFallback(el.element);\n          }\n        }\n      } else {\n        // Fallback to type-specific functions if search fails\n        for (const el of elementsNeedingSearch) {\n          el.function = this.getElementFunctionFallback(el.element);\n        }\n      }\n    }\n\n    this.debug('info', 'Function determination complete');\n  }\n\n  public getElementFunction(element: Element): string | null {\n    const gofakeitFunc = element.getAttribute('data-gofakeit');\n    const elementType = this.getElementType(element);\n\n    if (gofakeitFunc && gofakeitFunc !== 'true') {\n      // Specific function provided - use it directly\n      return gofakeitFunc;\n    } else if (gofakeitFunc === 'true') {\n      // Function is 'true' - check if element type needs search\n      const needsSearch = this.elementTypeNeedsSearch(elementType);\n\n      if (needsSearch) {\n        // Element type needs search - return null\n        return null;\n      } else {\n        // Element type doesn't need search - use fallback function even with data-gofakeit=\"true\"\n        return this.getElementFunctionFallback(element);\n      }\n    } else {\n      // No function specified - check if element type needs search\n      const needsSearch = this.elementTypeNeedsSearch(elementType);\n\n      if (needsSearch) {\n        // Element type needs search - return null\n        return null;\n      } else {\n        // Element type doesn't need search - use fallback function\n        return this.getElementFunctionFallback(element);\n      }\n    }\n  }\n\n  private elementTypeNeedsSearch(elementType: string): boolean {\n    const skipSearchTypes = [\n      'checkbox',\n      'radio',\n      'select',\n      'number',\n      'range',\n      'file',\n      'button',\n      'submit',\n      'reset',\n      'image',\n      'week',\n      'date',\n      'time',\n      'datetime-local',\n      'month',\n      'color',\n    ];\n    return !skipSearchTypes.includes(elementType);\n  }\n\n  // If the element doesnt have a function and search doesnt return a function,\n  // we will use a fallback function\n  private getElementFunctionFallback(element: Element): string {\n    if (element instanceof HTMLInputElement) {\n      const elementType = element.type.toLowerCase();\n\n      switch (elementType) {\n        case 'date':\n        case 'datetime-local':\n        case 'month':\n        case 'week': {\n          // Check if input has min/max attributes to determine if it should use daterange\n          const min = element.getAttribute('min');\n          const max = element.getAttribute('max');\n          return min || max ? 'daterange' : 'date';\n        }\n        case 'time':\n          return 'time';\n        case 'text':\n          return 'word';\n        case 'email':\n          return 'email';\n        case 'tel':\n          return 'phone';\n        case 'url':\n          return 'url';\n        case 'password':\n          return 'password';\n        case 'search':\n          return 'word';\n        case 'number':\n        case 'range': {\n          // Check if input has min/max attributes to determine if it should use number with parameters\n          const min = element.getAttribute('min');\n          const max = element.getAttribute('max');\n          return min || max ? 'number' : 'number'; // Both use 'number' function, but with different parameters\n        }\n        case 'color':\n          return 'hexcolor';\n        case 'checkbox':\n          return 'bool';\n        case 'radio':\n          return 'randomstring';\n        default:\n          return 'word';\n      }\n    } else if (element instanceof HTMLTextAreaElement) {\n      return 'sentence';\n    } else if (element instanceof HTMLSelectElement) {\n      return 'randomstring';\n    }\n\n    return 'word';\n  }\n\n  // ============================================================================\n  // Step 3: Get values for all elements via multi-function API\n  // ============================================================================\n\n  // Get values for all elements via multi-function API\n  public async getElementValues(): Promise<void> {\n    this.debug('info', 'Starting value generation...');\n    const elementsNeedingValues = this.state.elements.filter(\n      el => el.function && !el.error\n    );\n\n    if (elementsNeedingValues.length === 0) {\n      this.debug('info', 'No elements need value generation');\n      return;\n    }\n\n    this.debug(\n      'info',\n      `Getting values for ${elementsNeedingValues.length} elements from API`\n    );\n\n    const requests: FetchFuncMultiRequest[] = [];\n    const processedNames: string[] = []; // Track processed radio group names\n    const requestToElementMap: AutofillElement[] = []; // Map requests to elements\n\n    // Process each element, adding parameters based on function type\n    for (const el of elementsNeedingValues) {\n      // Skip radio elements that are part of a group we've already processed\n      if (el.type === 'radio' && el.name && processedNames.includes(el.name)) {\n        continue;\n      }\n\n      const request: FetchFuncMultiRequest = {\n        id: el.id,\n        func: el.function,\n      };\n\n      // Add parameters based on element type\n      switch (el.type) {\n        case 'select':\n          request.params = this.paramsSelect(el.element as HTMLSelectElement);\n          break;\n        case 'radio': {\n          // For radio groups, get all radio elements with the same name\n          const radioGroup = elementsNeedingValues.filter(\n            otherEl => otherEl.type === 'radio' && otherEl.name === el.name\n          );\n          request.params = this.paramsRadio(radioGroup);\n          // Mark this radio group as processed\n          if (el.name) {\n            processedNames.push(el.name);\n          }\n          break;\n        }\n        case 'date':\n        case 'datetime-local':\n        case 'month': {\n          const params = this.paramsDate(el);\n          if (params && (params.startdate || params.enddate)) {\n            request.func = 'daterange';\n            request.params = params;\n          } else {\n            request.params = params;\n          }\n          break;\n        }\n        case 'time': {\n          // For time inputs, use 'time' function with format\n          request.params = { format: 'HH:mm' };\n          break;\n        }\n        case 'week': {\n          const params = this.paramsWeek(el);\n          if (params && (params.startdate || params.enddate)) {\n            request.func = 'daterange';\n            request.params = params;\n          } else {\n            request.func = 'date';\n            request.params = params;\n          }\n          break;\n        }\n        case 'number':\n        case 'range': {\n          const params = this.paramsNumber(el);\n          request.params = params;\n          break;\n        }\n        // Add other element type cases here as needed\n        default:\n          // No special parameters needed\n          break;\n      }\n\n      requests.push(request);\n      requestToElementMap.push(el);\n    }\n\n    const response = await fetchFuncMulti(requests);\n\n    if (response.success && response.data) {\n      // Map results back to elements using the correct mapping\n      for (let i = 0; i < response.data.length; i++) {\n        const result = response.data[i];\n        const el = requestToElementMap[i];\n\n        if (result.value !== null && result.value !== undefined) {\n          el.value = String(result.value);\n        } else if (result.error) {\n          el.error = result.error;\n        } else {\n          el.error = 'Unknown API error';\n        }\n      }\n    } else {\n      // Set error for all elements if the request failed\n      for (const el of elementsNeedingValues) {\n        el.error = response.error || 'API request failed';\n      }\n    }\n\n    this.debug('info', 'Value generation complete');\n  }\n\n  // ============================================================================\n  // Step 4: Set values to the actual form elements\n  // ============================================================================\n\n  // Set values to the actual form elements\n  public async setElementValues(): Promise<void> {\n    this.debug('info', 'Starting value application...');\n    if (this.state.elements.length === 0) {\n      this.debug('info', 'No elements to apply values to');\n      return;\n    }\n\n    this.debug('info', `Processing ${this.state.elements.length} elements`);\n\n    // Track processed radio group names to avoid duplicate badges\n    const processedRadioNames: string[] = [];\n\n    // Process all elements with optional staggering and show badges for each\n    for (let i = 0; i < this.state.elements.length; i++) {\n      const el = this.state.elements[i];\n      let elementToShowBadge: AutofillElement | null = null;\n\n      // Handle different element types\n      switch (el.type) {\n        case 'radio':\n          // Only process if we haven't already processed this radio group\n          if (el.name && !processedRadioNames.includes(el.name)) {\n            processedRadioNames.push(el.name);\n            elementToShowBadge = this.setRadioGroup(el);\n          }\n          break;\n        default:\n          // Only set value if el has a valid value and no error\n          if (el.value !== undefined && el.value !== null && !el.error) {\n            this.setElementValue(el);\n          }\n          elementToShowBadge = el;\n          break;\n      }\n\n      // Show badge for the appropriate element\n      if (\n        this.settings.badges &&\n        this.settings.badges > 0 &&\n        elementToShowBadge\n      ) {\n        this.showBadge(elementToShowBadge);\n      }\n\n      // Add delay between applications (except for the last one) if stagger is enabled\n      if (\n        this.settings.stagger &&\n        this.settings.stagger > 0 &&\n        i < this.state.elements.length - 1\n      ) {\n        await new Promise(resolve =>\n          setTimeout(resolve, this.settings.stagger)\n        );\n      }\n    }\n\n    this.debug('info', 'Value application complete');\n  }\n\n  private setRadioGroup(el: AutofillElement): AutofillElement | null {\n    // Find all radio elements in the same group\n    const radioGroup = this.state.elements.filter(\n      otherEl => otherEl.type === 'radio' && otherEl.name === el.name\n    );\n\n    // Find the radio element that matches the returned value\n    const selectedRadio = radioGroup.find(radioEl => {\n      const input = radioEl.element as HTMLInputElement;\n\n      // Check if the value attribute is explicitly set\n      const hasExplicitValue = input.hasAttribute('value');\n\n      // First try to match by value attribute if it's explicitly set or not the default \"on\"\n      if (\n        (hasExplicitValue || input.value !== 'on') &&\n        input.value === el.value\n      ) {\n        return true;\n      }\n\n      // If value is \"on\" (default) or no match, try to match by label text\n      const label = document.querySelector(`label[for=\"${input.id}\"]`);\n      if (label && label.textContent && label.textContent.trim() === el.value) {\n        return true;\n      }\n\n      // Final fallback: match by id\n      if (input.id === el.value) {\n        return true;\n      }\n\n      return false;\n    });\n\n    if (selectedRadio && !selectedRadio.error) {\n      // Uncheck all radios in the same group first\n      const radioName = (selectedRadio.element as HTMLInputElement).name;\n      if (radioName) {\n        const otherRadios = document.querySelectorAll(\n          `input[type=\"radio\"][name=\"${radioName}\"]`\n        );\n        otherRadios.forEach(radio => {\n          (radio as HTMLInputElement).checked = false;\n        });\n      }\n\n      // Check the selected radio button\n      (selectedRadio.element as HTMLInputElement).checked = true;\n      (selectedRadio.element as HTMLInputElement).dispatchEvent(\n        new Event('change', { bubbles: true })\n      );\n\n      // Return the selected radio element for badge display\n      return selectedRadio;\n    } else if (el.error) {\n      // Return the original element if there's an error\n      return el;\n    }\n\n    return null;\n  }\n\n  private setElementValue(el: AutofillElement): void {\n    const element = el.element;\n\n    if (element instanceof HTMLInputElement) {\n      const elementType = element.type.toLowerCase();\n\n      switch (elementType) {\n        case 'checkbox':\n          this.setCheckboxValue(element, el.value);\n          break;\n        case 'radio':\n          this.setRadioValue(element, el.value);\n          break;\n        case 'number':\n        case 'range':\n        case 'date':\n        case 'time':\n        case 'datetime-local':\n        case 'month':\n        case 'color':\n          this.setGeneralValue(element, el.value);\n          break;\n        case 'week':\n          // Convert date value to week format\n          this.setGeneralValue(element, this.convertDateToWeek(el.value));\n          break;\n        default:\n          this.setGeneralValue(element, el.value);\n      }\n    } else if (element instanceof HTMLTextAreaElement) {\n      this.setGeneralValue(element, el.value);\n    } else if (element instanceof HTMLSelectElement) {\n      this.setSelectValue(element, el.value);\n    }\n  }\n\n  // ============================================================================\n  // ELEMENT TYPE SPECIFIC FUNCTIONS\n  // ============================================================================\n\n  private setGeneralValue(\n    element: HTMLInputElement | HTMLTextAreaElement,\n    value: string\n  ): void {\n    element.value = value;\n    element.dispatchEvent(new Event('input', { bubbles: true }));\n    element.dispatchEvent(new Event('change', { bubbles: true }));\n  }\n\n  private setCheckboxValue(\n    element: HTMLInputElement,\n    value: string | boolean\n  ): void {\n    const boolValue = value === 'true' || value === true;\n    element.checked = boolValue;\n    element.dispatchEvent(new Event('change', { bubbles: true }));\n  }\n\n  private setRadioValue(\n    element: HTMLInputElement,\n    value: string | boolean\n  ): void {\n    const boolValue = value === 'true' || value === true;\n\n    if (boolValue) {\n      // Uncheck other radios in the same group\n      const radioName = element.name;\n      if (radioName) {\n        const otherRadios = document.querySelectorAll(\n          `input[type=\"radio\"][name=\"${radioName}\"]`\n        );\n        otherRadios.forEach(radio => {\n          if (radio !== element) {\n            (radio as HTMLInputElement).checked = false;\n          }\n        });\n      }\n\n      element.checked = true;\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n    } else {\n      element.checked = false;\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n    }\n  }\n\n  private setSelectValue(element: HTMLSelectElement, value: string): void {\n    // Try to find an option with the exact value\n    const exactMatch = Array.from(element.options).find(\n      option => option.value === value\n    );\n    if (exactMatch) {\n      element.value = value;\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n      return;\n    }\n\n    // Try to find an option with matching text content\n    const textMatch = Array.from(element.options).find(option =>\n      option.textContent?.toLowerCase().includes(value.toLowerCase())\n    );\n    if (textMatch) {\n      element.value = textMatch.value;\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n      return;\n    }\n\n    // Fallback: select a random non-empty option\n    const nonEmptyOptions = Array.from(element.options).filter(\n      option => option.value && option.value.trim() !== ''\n    );\n    if (nonEmptyOptions.length > 0) {\n      const randomOption =\n        nonEmptyOptions[Math.floor(Math.random() * nonEmptyOptions.length)];\n      element.value = randomOption.value;\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n    }\n  }\n\n  private showBadge(el: AutofillElement): void {\n    // Remove any existing badge for this element\n    this.removeBadge(el.id);\n\n    // Create badge element with optimized styling\n    const badge = document.createElement('div');\n    badge.id = `gofakeit-badge-${el.id}`;\n    const isError = Boolean(el.error && el.error.trim() !== '');\n    badge.textContent = isError ? el.error : el.function;\n\n    // Batch all style changes to minimize reflows\n    const badgeStyles = {\n      position: 'fixed',\n      zIndex: '999999',\n      padding: `${GOFAKEIT_SPACING.quarter}px ${GOFAKEIT_SPACING.half}px`,\n      borderRadius: `${GOFAKEIT_BORDER.radius}px`,\n      fontSize: `${GOFAKEIT_FONT.size}px`,\n      fontWeight: 'bold',\n      fontFamily: GOFAKEIT_FONT.family,\n      boxShadow: '0 2px 4px rgba(0,0,0,0.2)',\n      pointerEvents: 'none',\n      userSelect: 'none',\n      transition: 'opacity 0.3s ease-in-out',\n      opacity: '0',\n      whiteSpace: 'nowrap',\n      backgroundColor: isError\n        ? GOFAKEIT_COLORS.error\n        : GOFAKEIT_COLORS.primary,\n      color: isError ? GOFAKEIT_COLORS.white : GOFAKEIT_COLORS.text,\n    };\n\n    // Apply all styles at once\n    Object.assign(badge.style, badgeStyles);\n\n    // Append badge to body\n    document.body.appendChild(badge);\n\n    // Performance optimizations\n    let lastRect: DOMRect | null = null;\n    let animationId: number | null = null;\n    let isVisible = true;\n    let lastVisibilityCheck = 0;\n    const VISIBILITY_CHECK_INTERVAL = 100; // Check visibility every 100ms instead of every frame\n\n    // Cache scrollable parents to avoid repeated DOM traversal\n    const scrollableParents = this.getScrollableParents(el.element);\n    const parentRects = new Map<Element, DOMRect>();\n\n    // Function to check if element is visible (optimized)\n    const checkElementVisibility = (element: Element): boolean => {\n      const rect = element.getBoundingClientRect();\n\n      // Quick window viewport check first\n      if (\n        rect.top < 0 ||\n        rect.left < 0 ||\n        rect.bottom > window.innerHeight ||\n        rect.right > window.innerWidth\n      ) {\n        return false;\n      }\n\n      // Check cached scrollable parents\n      for (const parent of scrollableParents) {\n        let parentRect = parentRects.get(parent);\n        if (!parentRect) {\n          parentRect = parent.getBoundingClientRect();\n          parentRects.set(parent, parentRect);\n        }\n\n        // Check if element is within parent bounds\n        if (\n          rect.top < parentRect.top ||\n          rect.left < parentRect.left ||\n          rect.bottom > parentRect.bottom ||\n          rect.right > parentRect.right\n        ) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    // Optimized position update function\n    const updateBadgePosition = () => {\n      const rect = el.element.getBoundingClientRect();\n\n      // Check if element has moved (position or size changed)\n      const hasMoved =\n        !lastRect ||\n        rect.top !== lastRect.top ||\n        rect.left !== lastRect.left ||\n        rect.width !== lastRect.width ||\n        rect.height !== lastRect.height;\n\n      if (hasMoved) {\n        lastRect = rect;\n\n        // Only check visibility periodically to reduce DOM queries\n        const now = performance.now();\n        if (now - lastVisibilityCheck > VISIBILITY_CHECK_INTERVAL) {\n          isVisible = checkElementVisibility(el.element);\n          lastVisibilityCheck = now;\n          // Clear parent rects cache periodically\n          parentRects.clear();\n        }\n\n        if (isVisible) {\n          // Position badge above the element\n          const top = rect.top - 30; // Offset based upon badge size\n          const left = rect.left;\n\n          // Batch style updates to minimize reflows\n          badge.style.cssText += `top:${top}px;left:${left}px;display:block;`;\n        } else {\n          // Hide badge if element is not visible\n          badge.style.display = 'none';\n        }\n      }\n\n      // Continue the animation loop\n      animationId = requestAnimationFrame(updateBadgePosition);\n    };\n\n    // Start the position tracking loop\n    updateBadgePosition();\n\n    // Store animation ID for cleanup\n    (badge as any)._animationId = animationId;\n\n    // Trigger fade-in animation\n    requestAnimationFrame(() => {\n      badge.style.opacity = '1';\n    });\n\n    // Auto-remove after duration with fade-out animation\n    setTimeout(() => {\n      this.removeBadge(el.id);\n    }, this.settings.badges);\n  }\n\n  // Helper method to cache scrollable parents\n  private getScrollableParents(element: Element): Element[] {\n    const scrollableParents: Element[] = [];\n    let parent = element.parentElement;\n\n    while (parent && parent !== document.body) {\n      const style = getComputedStyle(parent);\n      const overflow = style.overflow + style.overflowY + style.overflowX;\n\n      if (overflow.includes('scroll') || overflow.includes('auto')) {\n        scrollableParents.push(parent);\n      }\n\n      parent = parent.parentElement;\n    }\n\n    return scrollableParents;\n  }\n\n  private removeBadge(autofillElementId: string): void {\n    const existingBadge = document.getElementById(\n      `gofakeit-badge-${autofillElementId}`\n    );\n\n    // If badge doesn't exist, return\n    if (!existingBadge) {\n      return;\n    }\n\n    // Clean up animation frame immediately\n    const animationId = (existingBadge as any)._animationId;\n    if (animationId) {\n      cancelAnimationFrame(animationId);\n      (existingBadge as any)._animationId = null; // Clear reference\n    }\n\n    // Trigger fade-out animation\n    existingBadge.style.opacity = '0';\n\n    // Remove element after animation completes\n    setTimeout(() => {\n      // Double-check badge still exists before removing\n      if (existingBadge.parentNode) {\n        existingBadge.remove();\n      }\n    }, 300); // Match the transition duration\n  }\n\n  // ============================================================================\n  // PARAMETER GENERATION FUNCTIONS\n  // ============================================================================\n\n  private paramsSelect(\n    element: HTMLSelectElement\n  ): FetchFuncParams | undefined {\n    const options = Array.from(element.options)\n      .map(option => option.value)\n      .filter(value => value !== ''); // Filter out empty values\n\n    if (options.length > 0) {\n      return {\n        strs: options,\n      };\n    }\n    return undefined;\n  }\n\n  private paramsRadio(\n    radioGroup: AutofillElement[]\n  ): FetchFuncParams | undefined {\n    const values = radioGroup\n      .map(el => {\n        const input = el.element as HTMLInputElement;\n\n        // Check if the value attribute is explicitly set\n        const hasExplicitValue = input.hasAttribute('value');\n\n        // Use value attribute if it's explicitly set or if it's not the default \"on\"\n        if (\n          hasExplicitValue ||\n          (input.value && input.value.trim() !== '' && input.value !== 'on')\n        ) {\n          return input.value;\n        }\n\n        // Fallback to label text\n        const label = document.querySelector(`label[for=\"${input.id}\"]`);\n        if (label && label.textContent) {\n          return label.textContent.trim();\n        }\n\n        // Final fallback to id\n        return input.id;\n      })\n      .filter(value => value !== ''); // Filter out empty values\n\n    if (values.length > 0) {\n      return {\n        strs: values,\n      };\n    }\n    return undefined;\n  }\n\n  private convertDateToWeek(dateValue: string): string {\n    // Convert date string (yyyy-MM-dd) to week format (yyyy-Www)\n    try {\n      const date = new Date(dateValue + 'T00:00:00');\n      const year = date.getFullYear();\n\n      // Get the week number using ISO week calculation\n      const startOfYear = new Date(year, 0, 1);\n      const days = Math.floor(\n        (date.getTime() - startOfYear.getTime()) / (24 * 60 * 60 * 1000)\n      );\n      const weekNumber = Math.ceil((days + startOfYear.getDay() + 1) / 7);\n\n      // Format as yyyy-Www (with leading zero for week number)\n      return `${year}-W${weekNumber.toString().padStart(2, '0')}`;\n    } catch (error) {\n      // If conversion fails, return a default week value\n      const currentYear = new Date().getFullYear();\n      return `${currentYear}-W01`;\n    }\n  }\n\n  private convertWeekToDate(weekValue: string): string {\n    // Convert week format (yyyy-Www) to date format (yyyy-MM-dd)\n    try {\n      const match = weekValue.match(/^(\\d{4})-W(\\d{2})$/);\n      if (!match) {\n        throw new Error('Invalid week format');\n      }\n\n      const year = parseInt(match[1]);\n      const week = parseInt(match[2]);\n\n      // Calculate the date for the first day of the week\n      const jan1 = new Date(year, 0, 1);\n      const daysToAdd = (week - 1) * 7;\n      const targetDate = new Date(\n        jan1.getTime() + daysToAdd * 24 * 60 * 60 * 1000\n      );\n\n      // Format as yyyy-MM-dd\n      const month = (targetDate.getMonth() + 1).toString().padStart(2, '0');\n      const day = targetDate.getDate().toString().padStart(2, '0');\n      return `${year}-${month}-${day}`;\n    } catch (error) {\n      // If conversion fails, return a default date\n      const currentYear = new Date().getFullYear();\n      return `${currentYear}-01-01`;\n    }\n  }\n\n  private paramsDate(el: AutofillElement): FetchFuncParams | undefined {\n    const input = el.element as HTMLInputElement;\n    const min = input.getAttribute('min');\n    const max = input.getAttribute('max');\n\n    // Determine format based on input type\n    let format: string;\n    switch (el.type) {\n      case 'datetime-local':\n        format = 'yyyy-MM-ddTHH:mm';\n        break;\n      case 'month':\n        format = 'yyyy-MM';\n        break;\n      case 'date':\n      default:\n        format = 'yyyy-MM-dd';\n        break;\n    }\n\n    const params: any = {\n      format: format,\n    };\n\n    // If no min/max attributes, return just format\n    if (!min && !max) {\n      return params;\n    }\n\n    // Set startdate (min) or allow api to use default\n    if (min) {\n      params.startdate = min;\n    }\n\n    // Set enddate (max) or allow api to use default\n    if (max) {\n      params.enddate = max;\n    }\n\n    return params;\n  }\n\n  private paramsWeek(el: AutofillElement): FetchFuncParams {\n    const input = el.element as HTMLInputElement;\n    const min = input.getAttribute('min');\n    const max = input.getAttribute('max');\n\n    const params: any = {\n      format: 'yyyy-MM-dd', // Week inputs use date format for API calls\n    };\n\n    // Convert week format min/max attributes to date format for API\n    if (min) {\n      params.startdate = this.convertWeekToDate(min);\n    }\n\n    if (max) {\n      params.enddate = this.convertWeekToDate(max);\n    }\n\n    return params;\n  }\n\n  private paramsNumber(el: AutofillElement): FetchFuncParams {\n    const input = el.element as HTMLInputElement;\n    const min = input.getAttribute('min');\n    const max = input.getAttribute('max');\n\n    const params: any = {};\n\n    if (min) {\n      params.min = parseInt(min, 10);\n    }\n    if (max) {\n      params.max = parseInt(max, 10);\n    }\n    return params;\n  }\n\n  // ============================================================================\n  // MISC UTILITY FUNCTIONS\n  // ============================================================================\n\n  // Debug logging function controlled by settings.debug\n  private debug(type: 'warning' | 'error' | 'info', message: string): void {\n    if (this.settings.debug) {\n      const prefix = `[Gofakeit] ${type.toUpperCase()}:`;\n\n      switch (type) {\n        case 'error':\n          console.error(prefix, message);\n          break;\n        case 'warning':\n          console.warn(prefix, message);\n          break;\n        case 'info':\n        default:\n          console.log(prefix, message);\n          break;\n      }\n    }\n  }\n\n  // Reset state to initial values - useful for testing\n  public resetState(): void {\n    this.state = {\n      status: AutofillStatus.IDLE,\n      elements: [],\n    };\n  }\n\n  // Update status and trigger callback\n  private updateStatus(status: AutofillStatus): void {\n    this.state.status = status;\n    if (this.settings.onStatusChange) {\n      // Create a copy of state to prevent reference issues\n      const stateCopy = { ...this.state, elements: [...this.state.elements] };\n      this.settings.onStatusChange(status, stateCopy);\n    }\n  }\n\n  private results(): Results {\n    const successfulElements = this.state.elements.filter(\n      element => element.value && !element.error\n    );\n    const failedElements = this.state.elements.filter(element => element.error);\n\n    // Prepare results data for callback\n    const resultsData: Results = {\n      success: successfulElements.length,\n      failed: failedElements.length,\n      elements: this.state.elements,\n    };\n\n    this.debug('info', `\\n🎯 Autofill Results Summary:`);\n    this.debug('info', `   Total elements: ${this.state.elements.length}`);\n    this.debug('info', `   Successful: ${successfulElements.length}`);\n    this.debug('info', `   Failed: ${failedElements.length}`);\n\n    // Show notification\n    if (successfulElements.length > 0 && failedElements.length === 0) {\n      this.debug(\n        'warning',\n        `Successfully generated data for ${successfulElements.length} fields!`\n      );\n    } else if (successfulElements.length > 0 && failedElements.length > 0) {\n      this.debug(\n        'warning',\n        `Generated data for ${successfulElements.length} fields, ${failedElements.length} failed`\n      );\n    } else if (failedElements.length > 0) {\n      this.debug(\n        'error',\n        `Failed to generate data for ${failedElements.length} fields`\n      );\n    } else {\n      this.debug('warning', 'No fields were processed');\n    }\n\n    return resultsData;\n  }\n}\n","\n      import { Autofill, AutofillStatus } from './src/index.ts';\n\n      // Mobile Sidebar Functionality\n      function initMobileSidebar() {\n        const sidebar = document.getElementById('sidebar');\n        const sidebarToggle = document.getElementById('sidebarToggle');\n        const sidebarOverlay = document.getElementById('sidebarOverlay');\n\n        function openSidebar() {\n          sidebar.classList.add('open');\n          sidebarOverlay.classList.add('active');\n          sidebarToggle.classList.add('active');\n          document.body.style.overflow = 'hidden';\n        }\n\n        function closeSidebar() {\n          sidebar.classList.remove('open');\n          sidebarOverlay.classList.remove('active');\n          sidebarToggle.classList.remove('active');\n          document.body.style.overflow = '';\n        }\n\n        // Toggle sidebar\n        if (sidebarToggle) {\n          sidebarToggle.addEventListener('click', () => {\n            if (sidebar.classList.contains('open')) {\n              closeSidebar();\n            } else {\n              openSidebar();\n            }\n          });\n        }\n\n        // Close sidebar when clicking overlay\n        if (sidebarOverlay) {\n          sidebarOverlay.addEventListener('click', closeSidebar);\n        }\n\n        // Close sidebar on escape key\n        document.addEventListener('keydown', e => {\n          if (e.key === 'Escape' && sidebar.classList.contains('open')) {\n            closeSidebar();\n          }\n        });\n\n        // Auto-open sidebar when autofill buttons are clicked on mobile\n        function handleAutofillClick() {\n          if (window.innerWidth <= 768) {\n            openSidebar();\n          }\n        }\n\n        // Add event listeners to autofill buttons\n        const autofillButtons = document.querySelectorAll(\n          'button[onclick*=\"autofill\"]'\n        );\n        autofillButtons.forEach(button => {\n          button.addEventListener('click', handleAutofillClick);\n        });\n      }\n\n      // Initialize mobile sidebar when DOM is loaded\n      document.addEventListener('DOMContentLoaded', initMobileSidebar);\n\n      // Helper function for mobile-aware scrolling\n      function scrollToElement(element, offset = 0) {\n        if (!element) {\n          return;\n        }\n\n        const isMobile = window.innerWidth <= 768;\n\n        if (isMobile) {\n          // Calculate dynamic header offset based on actual header height + spacing\n          const mobileHeader = document.querySelector('.mobile-header');\n          const headerHeight = mobileHeader ? mobileHeader.offsetHeight : 60; // fallback to 60px\n          const spacing = 16; // CSS var(--spacing-md) = 14px, using 16px for a bit more breathing room\n          const headerOffset = headerHeight + spacing;\n\n          // For mobile, temporarily add scroll-margin-top to create offset\n          const originalScrollMargin = element.style.scrollMarginTop;\n          element.style.scrollMarginTop = headerOffset + 'px';\n\n          element.scrollIntoView({\n            behavior: 'smooth',\n            block: 'start',\n          });\n\n          // Remove the scroll-margin-top after scrolling completes\n          setTimeout(() => {\n            element.style.scrollMarginTop = originalScrollMargin;\n          }, 500);\n        } else {\n          // For desktop, use normal scrollIntoView\n          element.scrollIntoView({\n            behavior: 'smooth',\n            block: 'start',\n          });\n        }\n      }\n\n      // Make functions available globally\n      window.autofill = async target => {\n        try {\n          // Get current settings\n          const settings = getCurrentSettings();\n\n          if (target) {\n            // If target is a string, treat it as a CSS selector (ID, class, or other)\n            if (typeof target === 'string') {\n              // Scroll to the section first\n              const element = document.querySelector(target);\n              if (element) {\n                scrollToElement(element);\n\n                // Wait a moment for the scroll to complete, then fill\n                setTimeout(async () => {\n                  const manager = new Autofill(settings);\n                  await manager.fill(target);\n                  showStatus(\n                    `✅ ${target} section filled successfully!`,\n                    'success'\n                  );\n                }, 500);\n              } else {\n                showStatus('❌ Element not found: ' + target, 'error');\n              }\n            } else {\n              const manager = new Autofill(settings);\n              await manager.fill(target);\n              showStatus('✅ Element filled successfully!', 'success');\n            }\n          } else {\n            // No target - fill all\n            const manager = new Autofill(settings);\n            await manager.fill(undefined);\n            showStatus('✅ All fields filled successfully!', 'success');\n          }\n        } catch (error) {\n          showStatus('❌ Error filling fields: ' + error.message, 'error');\n        }\n      };\n\n      // Function to handle category selection from dropdown\n      window.handleCategorySelection = async () => {\n        const selector = document.getElementById('categorySelector');\n        const selectedCategory = selector.value;\n\n        if (!selectedCategory) {\n          return;\n        }\n\n        try {\n          // Map category values to their heading text\n          const categoryHeadingMap = {\n            'person-category': '👤 Person Category',\n            'address-category': '🏠 Address Category',\n            'company-category': '🏢 Company Category',\n            'payment-category': '💳 Payment Category',\n            'internet-category': '🌐 Internet Category',\n            'time-category': '⏰ Time Category',\n            'language-category': '🗣️ Language Category',\n            'word-category': '📝 Word Category',\n            'color-category': '🎨 Color Category',\n            'animal-category': '🐾 Animal Category',\n            'food-category': '🍕 Food Category',\n            'car-category': '🚗 Car Category',\n            'game-category': '🎮 Game Category',\n            'misc-category': '🎲 Misc Category',\n          };\n\n          // Find the specific category heading by text content\n          const headingText = categoryHeadingMap[selectedCategory];\n          let categoryHeading = null;\n          if (headingText) {\n            const allHeadings = document.querySelectorAll('h4');\n            for (const heading of allHeadings) {\n              if (heading.textContent?.includes(headingText)) {\n                categoryHeading = heading;\n                break;\n              }\n            }\n          }\n\n          if (categoryHeading) {\n            scrollToElement(categoryHeading);\n          } else {\n            // Fallback: scroll to the categories section\n            const section = document.getElementById('categories');\n            if (section) {\n              scrollToElement(section);\n            }\n          }\n\n          // Wait a moment for the scroll to complete, then autofill the specific fields\n          setTimeout(async () => {\n            // Find the category container\n            const categoryContainer = document.getElementById(selectedCategory);\n            if (!categoryContainer) {\n              showStatus('❌ Category container not found!', 'error');\n              return;\n            }\n\n            try {\n              // Get current settings\n              const settings = getCurrentSettings();\n\n              // Use the main fill function with the category container\n              const manager = new Autofill(settings);\n              await manager.fill(categoryContainer);\n\n              // Count filled elements\n              let filledCount = 0;\n              const inputs = categoryContainer.querySelectorAll(\n                'input, textarea, select'\n              );\n              inputs.forEach(element => {\n                if (element instanceof HTMLInputElement) {\n                  if (element.type === 'checkbox' || element.type === 'radio') {\n                    if (element.checked) filledCount++;\n                  } else if (element.value) {\n                    filledCount++;\n                  }\n                } else if (\n                  element instanceof HTMLTextAreaElement ||\n                  element instanceof HTMLSelectElement\n                ) {\n                  if (element.value) filledCount++;\n                }\n              });\n\n              const categoryName =\n                selector.options[selector.selectedIndex].text;\n              showStatus(\n                `✅ ${categoryName} filled successfully! (${filledCount} fields)`,\n                'success'\n              );\n            } catch (error) {\n              console.warn('Failed to fill category:', error);\n              showStatus(\n                '❌ Error filling category: ' + error.message,\n                'error'\n              );\n            }\n\n            // Reset the dropdown\n            selector.value = '';\n          }, 500);\n        } catch (error) {\n          showStatus('❌ Error filling category: ' + error.message, 'error');\n          // Reset the dropdown even on error\n          selector.value = '';\n        }\n      };\n\n      // Function to get current settings from the UI controls\n      function getCurrentSettings() {\n        const mode = document.querySelector('input[name=\"mode\"]:checked').value;\n        const stagger = parseInt(document.getElementById('stagger').value);\n        const badges = parseInt(document.getElementById('badges').value);\n        const debug = document.getElementById('debugMode').checked;\n\n        return {\n          mode: mode,\n          stagger: stagger,\n          badges: badges,\n          debug: debug,\n          onStatusChange: (status, state) => {\n            if (debug) {\n              const timestamp = new Date().toLocaleTimeString();\n              const emoji =\n                status === 'error' ? '❌' : status === 'idle' ? '⏸️' : '🔄';\n              const style =\n                'color: #9c27b0; font-weight: bold; background: #f3e5f5; padding: 2px 4px; border-radius: 3px;';\n              console.log(\n                `%c[Status ${timestamp}] ${emoji} ${status.toUpperCase()}:`,\n                style,\n                state\n              );\n            }\n\n            // Close sidebar on mobile when autofill starts\n            if (status === AutofillStatus.STARTING) {\n              const sidebar = document.getElementById('sidebar');\n              const sidebarOverlay = document.getElementById('sidebarOverlay');\n              const sidebarToggle = document.getElementById('sidebarToggle');\n\n              if (sidebar && sidebar.classList.contains('open')) {\n                sidebar.classList.remove('open');\n                if (sidebarOverlay) sidebarOverlay.classList.remove('active');\n                if (sidebarToggle) sidebarToggle.classList.remove('active');\n                document.body.style.overflow = '';\n              }\n            }\n\n            // Update status display in UI\n            const statusElement = document.getElementById('status');\n            if (statusElement) {\n              const statusText =\n                {\n                  idle: 'Ready',\n                  starting: 'Starting...',\n                  initializing: 'Initializing inputs...',\n                  determining_functions: 'Determining functions...',\n                  getting_values: 'Getting values...',\n                  setting_values: 'Setting values...',\n                  completed: 'Completed!',\n                  error: 'Error occurred',\n                }[status] || status;\n\n              statusElement.textContent = statusText;\n              statusElement.className = `status ${status}`;\n            }\n\n            // Show progress for certain statuses\n            if (status === 'getting_values' || status === 'setting_values') {\n              const processedCount = state.elements.filter(\n                element => element.value || element.error\n              ).length;\n              const totalCount = state.elements.length;\n              if (totalCount > 0) {\n                showStatus(\n                  `Processing ${processedCount}/${totalCount} fields...`,\n                  'info'\n                );\n              }\n            }\n          },\n        };\n      }\n\n      // Function to fill with current settings\n      window.autofillWithCurrentSettings = async () => {\n        try {\n          const settings = getCurrentSettings();\n          const manager = new Autofill(settings);\n          await manager.fill(undefined);\n\n          const modeText =\n            settings.mode === 'auto' ? 'Auto Mode' : 'Manual Mode';\n          const staggerText =\n            settings.stagger > 0\n              ? ` (${settings.stagger}ms stagger)`\n              : ' (no stagger)';\n          showStatus(\n            `✅ All fields filled with ${modeText}${staggerText}!`,\n            'success'\n          );\n        } catch (error) {\n          showStatus('❌ Error filling fields: ' + error.message, 'error');\n        }\n      };\n\n      // Update stagger delay value display and handle theme toggle\n      document.addEventListener('DOMContentLoaded', function () {\n        const stagger = document.getElementById('stagger');\n        const staggerValue = document.getElementById('staggerValue');\n        const badges = document.getElementById('badges');\n        const badgesValue = document.getElementById('badgesValue');\n        const themeToggle = document.getElementById('themeToggle');\n        const themeIcon = themeToggle.querySelector('.theme-icon');\n\n        if (stagger && staggerValue) {\n          stagger.addEventListener('input', function () {\n            staggerValue.textContent = this.value + 'ms';\n          });\n        }\n\n        if (badges && badgesValue) {\n          badges.addEventListener('input', function () {\n            badgesValue.textContent = this.value + 'ms';\n          });\n        }\n\n        // Handle theme toggle\n        if (themeToggle) {\n          // Get user's saved preference or system preference\n          const savedTheme = localStorage.getItem('theme');\n          const systemPrefersDark = window.matchMedia(\n            '(prefers-color-scheme: dark)'\n          ).matches;\n\n          // Use saved preference if available, otherwise use system preference\n          // Since dark is now default, we need to check if user wants light mode\n          const shouldUseLight =\n            savedTheme === 'light' ||\n            (savedTheme === null && !systemPrefersDark);\n\n          if (shouldUseLight) {\n            document.documentElement.setAttribute('data-theme', 'light');\n            themeIcon.textContent = '🌙';\n          } else {\n            // Dark is default, no data-theme attribute needed\n            themeIcon.textContent = '☀️';\n          }\n\n          themeToggle.addEventListener('click', function () {\n            const isLight =\n              document.documentElement.hasAttribute('data-theme') &&\n              document.documentElement.getAttribute('data-theme') === 'light';\n\n            if (isLight) {\n              // Switch to dark mode (default)\n              document.documentElement.removeAttribute('data-theme');\n              localStorage.setItem('theme', 'dark');\n              themeIcon.textContent = '☀️';\n            } else {\n              // Switch to light mode\n              document.documentElement.setAttribute('data-theme', 'light');\n              localStorage.setItem('theme', 'light');\n              themeIcon.textContent = '🌙';\n            }\n          });\n\n          // Listen for system preference changes\n          window\n            .matchMedia('(prefers-color-scheme: dark)')\n            .addEventListener('change', function (e) {\n              // Only update if user hasn't set a preference\n              if (localStorage.getItem('theme') === null) {\n                if (e.matches) {\n                  // System prefers dark, use default (dark)\n                  document.documentElement.removeAttribute('data-theme');\n                  themeIcon.textContent = '☀️';\n                } else {\n                  // System prefers light, switch to light\n                  document.documentElement.setAttribute('data-theme', 'light');\n                  themeIcon.textContent = '🌙';\n                }\n              }\n            });\n        }\n      });\n\n      window.clearAll = () => {\n        // only search in main content container, not sidebar\n        const mainContent = document.querySelector('.main-content');\n        if (!mainContent) return;\n\n        const inputs = mainContent.querySelectorAll('input, textarea, select');\n        inputs.forEach(input => {\n          if (input.type === 'checkbox' || input.type === 'radio') {\n            input.checked = false;\n          } else {\n            input.value = '';\n          }\n        });\n        showStatus('🧹 All fields cleared!', 'success');\n      };\n\n      window.clearBadges = () => {\n        const badges = document.querySelectorAll(\n          '[data-gofakeit-badge=\"true\"]'\n        );\n        badges.forEach(badge => badge.remove());\n        showStatus('🎯 All badges cleared!', 'success');\n      };\n\n      function showStatus(message, type) {\n        const status = document.getElementById('status');\n        status.textContent = message;\n        status.className = `status ${type}`;\n      }\n\n      // Initialize the page\n      console.log('🎯 Gofakeit Fill Comprehensive Testing loaded!');\n      console.log(\n        'This page tests the search API with various input contexts and categories.'\n      );\n      console.log(\n        'Check the browser network tab to see search API calls in action!'\n      );\n      console.log(\n        'New features: Badge system, debug mode, and improved error handling!'\n      );\n    "],"names":["GOFAKEIT_API_BASE","fetchFuncMulti","requests","processedRequests","req","index","func","id","params","funcName","extractedParams","parseFunctionString","finalParams","makeRequest","fetchFuncSearch","method","url","body","options","response","data","error","questionMarkIndex","functionName","queryString","searchParams","key","value","numValue","GOFAKEIT_COLORS","GOFAKEIT_SPACING","GOFAKEIT_BORDER","GOFAKEIT_FONT","AutofillStatus","Autofill","settings","target","allFormElements","elements","el","formEl","mode","filteredElements","element","gofakeitFunc","autofillElements","labelTexts","labelledBy","ref","labelEl","lbl","closestLabel","prev","labelText","type","name","elementId","placeholder","autocomplete","ariaLabel","part","elementsNeedingSearch","searchRequests","i","searchResult","elementType","min","max","elementsNeedingValues","processedNames","requestToElementMap","request","radioGroup","otherEl","result","processedRadioNames","elementToShowBadge","resolve","selectedRadio","radioEl","input","label","radioName","radio","boolValue","option","textMatch","nonEmptyOptions","randomOption","badge","isError","badgeStyles","lastRect","animationId","isVisible","lastVisibilityCheck","VISIBILITY_CHECK_INTERVAL","scrollableParents","parentRects","checkElementVisibility","rect","parent","parentRect","updateBadgePosition","now","top","left","style","overflow","autofillElementId","existingBadge","values","dateValue","date","year","startOfYear","days","weekNumber","weekValue","match","week","jan1","daysToAdd","targetDate","month","day","format","message","prefix","status","stateCopy","successfulElements","failedElements","resultsData","initMobileSidebar","sidebar","sidebarToggle","sidebarOverlay","openSidebar","closeSidebar","e","handleAutofillClick","button","scrollToElement","offset","mobileHeader","headerOffset","originalScrollMargin","getCurrentSettings","showStatus","selector","selectedCategory","headingText","categoryHeading","allHeadings","heading","section","categoryContainer","filledCount","categoryName","stagger","badges","debug","state","timestamp","statusElement","statusText","processedCount","totalCount","modeText","staggerText","staggerValue","badgesValue","themeToggle","themeIcon","savedTheme","systemPrefersDark","mainContent"],"mappings":"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"}